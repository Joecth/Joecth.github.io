---
layout: post
categories: Languages
tag: []
date: 2019-05-06

---

#### 

查詢時將區間映射到樹上的各個節點並取出值作比節，達到 lg(N) 的級別。



![image-20200506125234854](https://tva1.sinaimg.cn/large/007S8ZIlgy1geimzfa16cj31620oah0o.jpg)

```python
public class SegmentTreeNode {
    public int start, end, max;
    public SegmentTreeNode left, right;
    public SegmentTreeNode(int start, int end, int max) {
        this.start = start;
        this.end = end;
        this.max = max
        this.left = this.right = null;
    }
}
```

> 首先线段树是`一棵二叉树`, 平常我们所指的线段树都是指一维线段树。 故名思义, 线段树能解决的是线段上的问题, 这个线段也可指`区间`.
> 我们先来看线段树的逻辑结构。
>
> 一颗线段树的构造就是根据区间的性质的来构造的, 如下是一棵区间`[0, 3]`的线段树，每个`[start, end]`都是一个二叉树中的节点。
>
> ```
>           [0,3]
>          /     \
>     [0,1]       [2,3]
>     /   \       /   \
>  [0,0] [1,1] [2,2] [3,3]
> ```
>
> 区间划分大概就是上述的区间划分。可以看出每次都将区间的长度一分为二,数列长度为n,所以线段树的高度是`log(n)`,这是很多高效操作的基础。
> 上述的区间存储的只是区间的左右边界。我们可以将区间的最大值加入进来,也就是树中的Node需要存储left，right左右子节点外，还需要存储`start, end, val`区间的范围和区间内表示的值。
>
> ```
>             [0,3]
>            (val=4)
>          /         \
>      [0,1]         [2,3]
>     (val=4)       (val=3)
>     /    \         /    \
>  [0,0]  [1,1]   [2,2]  [3,3]
> (val=1)(val=4) (val=2)(val=3)
> ```
>
> 区间的第三维就是区间的最大值。
> 加这一维的时候只需要在建完了左右区间之后，根据左右区间的最大值来更新当前区间的最大值即可，即当前子树的最大值是左子树的最大和右子树的最大值里面选出来的最大值。
>
> 因为每次将区间的长度一分为二,所有创造的节点个数，即底层有n个节点，那么倒数第二次约n/2个节点，倒数第三次约n/4个节点，依次类推：
>
> ```
>     n + 1/2 * n + 1/4 * n + 1/8 * n + ...
> =   (1 + 1/2 + 1/4 + 1/8 + ...) * n
> =   2n
> 所以构造线段树的时间复杂度和空间复杂度都为O(n)
> ```