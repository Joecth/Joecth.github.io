---
layout: post
categories: LC
tag: []
date: 2020-02-11

---



## Recursion Ⅱ

|                               |      |      |      | status | coded |      |
| ----------------------------- | ---- | ---- | ---- | ------ | ----- | ---- |
| [904 Fruit Into Basket](#904) |      |      |      | v      | v     |      |
| [51 N-Queens](#51)            |      |      |      | v      | v     |      |
| [52 N-Queens Ⅱ](#52)          |      |      |      | v      | v     |      |



## Process

|                                  |      |      |      | status | coded |      |
| -------------------------------- | ---- | ---- | ---- | ------ | ----- | ---- |
| [929 Unique Email Address](#929) |      |      |      | v      | v     |      |
| [Odd Even Jump]                  |      |      |      |        |       |      |
| [Licese Key Formatting]          |      |      |      |        |       |      |
| [904 Fruit Into Baskets](#904)   |      |      |      | v      |       |      |



## Arrays and Strings

|                                                        |      |                        |        | status | coded |          |
| ------------------------------------------------------ | ---- | ---------------------- | ------ | ------ | ----- | -------- |
| [3 Longest Substring Without Repeating Characters](#3) |      |                        |        | v      | v     |          |
| [11 Container with Most Water](#11)                    |      |                        |        | v      | v     |          |
| [15 3Sum](#15)                                         |      |                        |        | v      | v     |          |
| [31 Next Permutation](#31)                             |      |                        |        | v      | v     | 待review |
| [43 Multiply Strings](#43)                             |      |                        |        | v      | v     |          |
| [48 Rotate Image](#48)                                 |      |                        |        | v      | v     |          |
| [Jump Game]                                            |      |                        |        |        |       |          |
| [66 Plus One](#66)                                     |      |                        |        | v      | v     |          |
| [Minumum Window Substring]                             |      |                        |        |        |       |          |
| [Read N Characters Given]                              |      |                        |        |        |       |          |
| [Longest Substring with At ]                           |      |                        |        |        |       |          |
| [Missing Ranges]                                       |      |                        |        |        |       |          |
| [Nezxt Closet Time]                                    |      |                        |        |        |       |          |
| [Expressive Wods]                                      |      |                        |        |        |       |          |
| [Find And Replace in String]                           |      |                        |        |        |       |          |
| [Maximize Distance to ]                                |      |                        |        |        |       |          |
| [20 Valid Parentheses](#20)                            |      |                        |        | v      | v     |          |
| [23 Merge K Sorted Lists](#23)                         |      |                        |        | v      | v     |          |
| [42 Trapping Rain Water](#42)                          |      | 當時感覺來了DP一次就對 | 2 ptrs | v      | v     |          |
| [215 Kth Largest Element in an Array](#215)            |      |                        |        | v      | v     |          |



## Linked List

|                                            |      |                                                              |               | status | Coded |      |
| ------------------------------------------ | ---- | ------------------------------------------------------------ | ------------- | ------ | ----- | ---- |
| [2 Add Two Numbers](#2)                    |      |                                                              |               | v      | v     |      |
| [19 Remove Nth Node From End of List](#19) |      | 讓快的先走，開始rm時候要小心就是                             |               | v      | v     |      |
| [21 Merge Two Sorted Lists](#21)           |      |                                                              |               | v      | v     |      |
| [138 Copy List with Random Pointer](#138)  |      | bottom up recursive 解時記得要先把做出來的node 加到visited, 不然random會一直叫下去不停 | 待試iterative | v      | v     |      |



## Trees & Graphs

|                                          |      |                           |                | status | Coded |      |
| ---------------------------------------- | ---- | ------------------------- | -------------- | ------ | ----- | ---- |
| [Binary Tree Maximum Path Sum]           |      |                           |                |        |       |      |
| **[127 Word Ladder](#127)**              |      | 用了双向BFS， 目前仍是TLE | 待嘗試動態建圖 | v      |       |      |
| [200 Number of Islands](#200)            |      | BFS 是最好的解，就熟它吧  |                | v      | v     |      |
| [Course Schedule Ⅱ]                      |      |                           |                |        |       |      |
| [222 Count Complete Tree Nodes](#222)    |      |                           |                | v      | v     |      |
| [543 Diameter of Binary Tree](#543)      |      |                           |                | v      | v     |      |
| [951 Flip Equivalent Binary Trees](#951) |      |                           |                | v      | v     |      |



## Recursion

|                                                |      |      |      | status | coded |      |
| ---------------------------------------------- | ---- | ---- | ---- | ------ | ----- | ---- |
| [17 Letter Combination of a Phone Number](#17) |      |      |      | v      | v     |      |
|                                                |      |      |      |        |       |      |
|                                                |      |      |      |        |       |      |



## Sorting and Searching

|                                                              |      |      |      | status | coded |      |
| ------------------------------------------------------------ | ---- | ---- | ---- | ------ | ----- | ---- |
|                                                              |      |      |      |        |       |      |
| [34 Find First and Last Position of Element in Sorted Array](#34) |      |      |      | v      | v     |      |
| [56 Merge Intervals](#56)                                    |      |      |      | v      | v     |      |
|                                                              |      |      |      |        |       |      |
| [242 Valid Anagram](#242)                                    |      |      |      | v      | v     |      |
|                                                              |      |      |      |        |       |      |
| [852 Peak Index in a Mountain Array](#852)                   |      |      |      | v      | v     |      |



## DP

|                            |      |      |      | status | coded |      |
| -------------------------- | ---- | ---- | ---- | ------ | ----- | ---- |
| Longest Palindromic Subse  |      |      |      |        |       |      |
| [53 Maximum Subarray](#53) |      |      |      | v      | v     |      |
|                            |      |      |      |        |       |      |



## Design

|                       |      |      |      | status | Coded |      |
| --------------------- | ---- | ---- | ---- | ------ | ----- | ---- |
| [146 LRU Cache](#146) |      |      |      | v      | v     |      |
| [155 Min Stack](#155) |      |      |      | v      | v     |      |
|                       |      |      |      |        |       |      |



### <a name="2">2</a>

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
'''
2 4  3 
5 6  4 

7 10 
'''
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        carry = 0
        dummy = cur = ListNode(0)
        # loop = 0
        
        while l1 or l2:
            # total = l1.val + l2.val + carry
            m, n = l1.val if l1 else 0, l2.val if l2 else 0
            total = m + n + carry
            carry, digit = total//10, total%10
            cur.next = ListNode(digit)
            cur = cur.next
            l1, l2 = l1.next if l1 else None, l2.next if l2 else None
            
        '''
        while l1 and l2:
            total = l1.val + l2.val + carry
            carry, digit = total//10, total%10  # 2 5 -> 0 7, 4 6 => 1 0
            # result = total * (10**loop) + result    # 10**1, 700    700   7*100 + 107
            cur.next = ListNode(digit)
            cur = cur.next
            l1, l2 = l1.next, l2.next
            # loop += 1
        
        rem = l1 if l1 else l2
        while rem:
            total = rem.val + carry
            carry, digit = total//10, total%10
            cur.next = ListNode(digit)
            cur = cur.next
            # result = total * (10**loop) + result
            rem = rem.next
        '''
        if carry:
            cur.next = ListNode(carry)
        
        return dummy.next
```



### <a name="3">3</a>

```python
'''
　 a　b　c　a　b　c　b　b　
             i     j
-1 0 
{a:0, b:1, c:2}  --> {a:3, b:1, c:2} max_len = max(j - i, max_len)
                 --> {a:3, b:4, c:5} max_len = max(j - i, max_len)
                 --> {a:3, b:4, c:5} max_len = max(j - i, max_len)
                 
　 a　b　c　a　b　c　b　b　c a d
                   i j  --> {a:3, b:7, c:5} max_len = max(j - i, max_len)
                   we can del d[a]  del[c] 
                   BUT,
                 --> i = max(i, d[a])
'''
'''
     a b c a b c b b  a 
             j   i 
i   0    2  
j   0
od  {a}  {a b c}

    j       i       od                                                  dis
    0       0       {a:0}                                                   1  
    0       1       {a:0 b:1}                                                  2
    0       2       {a:0 b:1 c:2}                                                     3
    0       3       {a:0 b:1 c:2}    ==>      while j 1   i 3   {b:1 c:2 a:3}          3
    1       4       {b:1 c:2 a:3}     =>      while j 2   i 4   {c a b}           3
    2       5       {}
'''
from collections import OrderedDict
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s:
            return 0
        od = OrderedDict()  # position od
        j = -1
        g_max = cur_max = 0
        rec = []
        for i in range(len(s)):
            sym = s[i]
            if sym not in od:
                od[sym] = i
            else:                           # a b c b 
                # while sym in od_pos:
                    # del od_pos[sym]
                j = max(od[sym], j)
                od[sym] = i     # a 0
                # sym = od[j]
                
            cur_max = i - j
            if cur_max > g_max:
                g_max = cur_max
                rec.append((i, j))
                
        return g_max
        
        # i = -1
        # max_len = 0
        # lkup = {}
        # for j in range(len(s)):
        #     if s[j] not in lkup:
        #         lkup[s[j]] = j
        #     else:
        #         i = max(lkup[s[j]], i)   # e.g. i at 7, doesn't go back to (6, c)
        #                                 # move i before update lkup[s[i]]
        #         lkup[s[j]] = j  # {a:3, b:1, c:2}
        #     max_len = max(max_len, j - i)   # 2 - (-1) = 3
        # return max_len
                
            # if s[j] in lkup:
            #     max_len = max(max_len, j - i)
            # lkup[s[j]] = i
```



### <a name="11">11</a>

```python
'''
=== Mis-Understanding ===
            [1,8,6,2,5,4,8,3,7]
l_larger =  [0 0 1 1 2 1 5 1 2]
r_larger =  [1 5 4 1 2 1 0 1 0]

width[i] = l_larger[i] + r_larger[i]
water = height[i] * width[i]

=== Again-Understanding ==> Still Wrong ! ===
            [1,8,6,2, 5, 4, 8, 3, 7]
l_dis =     [0 0 1 2  3  4  5  6  7]
r_dis =     [8 5 6 5  4  3  0  1  0]
ans      =. [8 0 6 10 12 12 40 21 49]
width[i] = l_larger[i] + r_larger[i]
water = height[i] * width[i]

'''
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r = 0, len(height)-1
        
        g_area = area = 0
        rec = []
        while l < r:
            h = min(height[l], height[r])    
            area = h * (r-l)
            if height[l] <= height[r]:
                l += 1
            else:
                r -= 1
        
            if area > g_area:
                g_area = area
                rec.append((l, r))
                print(l, r)
        return g_area
        
        n = len(height)
        l, r  = 0, len(height)-1
        g_max = cur_area = 0 
        
        while l < r:
            cur_area = (r - l) * min(height[l], height[r])
            g_max = max(g_max, cur_area)
            if height[l] <= height[r]:
                l += 1
            else:
                r -= 1
        return g_max
```



### <a name="15">15</a>

```python

# i, l, r
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        for i in range(len(nums)-2):
            l, r = i+1, len(nums)-1
            if nums[i] and nums[i] + nums[r-1] + nums[r] > 0:
                break
            if nums[r] < 0 and nums[i] + nums[i+1] + nums[r] < 0:      # nums[i] still has chance to overbeat l & r
                continue    
            if i > 0 and nums[i] == nums[i-1]:
                continue
            
            
            total = nums[i] + nums[l] + nums[r]
            if total == 0:
                res.append([i, l, r])
                # while l<r and nums[l] == nums[l+1]:
                while l+1<r and nums[l] == nums[l+1]:    
                    l += 1
                l += 1
                # while l<rnums[r] == nums[r-1]:
                while r-1>l and l<rnums[r] == nums[r-1]:
                    r -= 1
                r -= 1
            elif total < 0:
                l += 1
            else:
                r -= 1
            
        
        
        
        nums.sort()
        res = []
        for i in range(len(nums)-2):  # i, l, r
            l, r = i + 1, len(nums) - 1
            total = nums[i] + nums[l] + nums[r] # prune here
            # if nums[i] > 0:     # left most
            #     return res      
            # if nums[r] < 0:     # right most
            #     return res
            if nums[i] > 0 and nums[i] + nums[l] + nums[r] > 0: # r can be small
                break
            if nums[r] < 0 and nums[i] + nums[r-1] + nums[r] < 0:
                continue
            if i > 0 and nums[i] == nums[i-1]:
                continue
            
            while l < r:            # -99 8 10 99
                total = nums[i] + nums[l] + nums[r]
                if total == 0: 
                    res.append([nums[i], nums[l], nums[r]])
                    ''' The following "whiles" are CRUCIAL...'''
                    # -4 -1 -1 0 1 2 
                    #        idx
                    #     i   1  
                    #     l   2
                    #     r   5
                    ''' #[-2 -1 0 1 2 3] failed for [-1 0 1] 'cause l & r overlapped '''
                    while l < r and nums[l+1] == nums[l]:  
                        l += 1
                    # l += 1
                    while r > l and nums[r-1] == nums[r]:
                        r -= 1
                    # r -= 1
                    #'''                    
                    l, r = l + 1, r - 1   #''' l+1 should before while of r '''
                elif total < 0:
                    l += 1
                else:
                    r -= 1
        return res
```



### <a name="17">17</a>

```python
# 2 3 4
# a d g
# b e h
# c f i

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        self.d = {'1':'', '2':'abc', '3':'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}
        self.result = []
        self.helper(digits, '', 0)        # THIS IS ALREADY OK!
        # print(self.result)    
        return self.result
    
    
    def helper(self, digits, item, level):
        if level == len(digits):
            # self.result.append(item.copy())   # String has no attribute copy
            self.result.append(item)    # just call permutation here! Another backtracking for PERMUTATION
            return 
        
        cur_digit = digits[level]   # 2         3        
        cur_candidates = self.d[cur_digit]          # abc,      def
        for i in range(len(cur_candidates)):
            item += cur_candidates[i]     # def   
            self.helper(digits, item, level+1)
            item = item[:-1]    # pop()
```



### <a name="19">19</a>

```python
1 > 2 > 3 > 4 > 5


# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        if not head:
            return None
        
        dummy = cur = later = ListNode(0)
        dummy.next = head
        
        count = 0
        while count < n and cur:
            cur = cur.next
            count += 1
            
        if n < count:
            return None
        
        '''
        0 1 2 3 4 5 
              l   c
        '''
        '''
        0  1
        l  c
        '''
        while cur.next:
            cur = cur.next
            later = later.next
        
        if later.next:
            ''' remove later.next '''
            # later.next.next = None
            later.next = later.next.next
            # later.next = None
            
        return dummy.next
```



### <a name="20">20</a>

```python
class Solution:
    def isValid(self, s: str) -> bool:
        d = {'(': ')', '[':']', '{':'}'}
        
        S = []
        for c in s:
            if c == '(' or c == '[' or c =='{':
                S.append(c)
            else:
                if not S:
                    return False
                else:
                    elem = S.pop()
                    if d[elem] != c:
                        return False

        return not S
```





### <a name="21">21</a>

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
'''
    1 2 4 
    i
    1 3 4 
cur -> smaller one
'''
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        # return l2 if not l1
        # return l1 if not l2
        if not l1: return l2
        if not l2: return l1
        dummy = cur = ListNode(0)
        # dummy.next = 
        self.helper2(cur, l1, l2)
        return dummy.next
        
    def helper2(self, root, l1, l2):
        if not root:
            return None
        if not l1:
            root.next = l2
            return 
        if not l2:
            root.next = l1
            return 
        
        if l1.val <= l2.val:
            root.next = l1
            l1 = l1.next        
        else:
            root.next = l2
            l2 = l2.next
            
        root = root.next
        self.helper2(root, l1, l2)
        

    def mergeTwoLists_alsoOK(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        dummy = ListNode(0)
        
        # self.helper(l1, l2)   # Iterative
        self.recursive(dummy, l1, l2)
        return dummy.next
    '''
    Input: 1->2->4, 1->3->4
    Output: 1->1->2->3->4->4
    '''
    ''' recursive '''
    def recursive(self, root, l1, l2):
        if not l2:
            root.next = l1
            return None
        if not l1:
            root.next = l2
            return None
        
        if l1.val <= l2.val:
            root.next = l1
            l1 = l1.next
        else:
            root.next = l2
            l2 = l2.next
        # root = root.next
        
        self.recursive(root.next, l1, l2)
    
    ''' Iterative '''
    def helper(self, l1, l2):
        
        head = cur = ListNode(0) #l1 if l1.val <= l2.val else l2
        prev = None
        while l1 and l2:
            if l1.val <= l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        
        if not l2 and not l1:
            cur.next = None
            
        if not l2:
            cur.next = l1
        else:
            cur.next = l2
        
        return head.next
```



### <a name="23">23</a>

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
import heapq
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        # val, index 
        # 1, 0
        # 1, 1
        # 2, 2
        if not lists:
            return None
        # if not lists[0]:
        #     return None
        
        l = []  # for heapq
        for i in range(len(lists)):
            if lists[i]:                # CAUTION! for [[],[1]]
                val, idx = lists[i].val, i
                heapq.heappush(l, (val, idx))
            # lists[idx] = lists[idx].next  # CAUTION! 別跟31行重覆了
        
        root = curr = ListNode(-1)
        while True:
            if not l:
                break
            val, idx = heapq.heappop(l)
            # print(val, idx)
            # for update heapq
            lists[idx] = lists[idx].next

            if lists[idx] is not None:
                heapq.heappush(l, (lists[idx].val, idx))
                
            # for Result
            curr.next = ListNode(val)
            curr = curr.next
        
        return root.next
```



### <a name="31">31</a>

```python

'''
1 2 4  8  3  7 6  5   ==>   
          pvt r
'''
    
    # 3 5 7 4  6 9 8 7 6 5
from bisect import bisect_right
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        if not nums:
            return None
        
        if len(nums) == 1:
            return None
        
        r = len(nums)-1

        while r > 0 and nums[r] <= nums[r-1]:
            r -= 1
        
        if r == 0:   # 5 4 3 2 1
            # nums = nums[::-1]     # not in-place
            nums.reverse()
            return None
        
        #              # 1 2 3 4 5
        if r == len(nums) - 1:
            # nums[1:].reverse()  # DOESN'T WORK!!!
            nums[-1], nums[-2] = nums[-2], nums[-1]
            return None
        
        # if r == nums[]
        pvt = r
        # idx = bisect_right(nums[pvt:], nums[ref]) + r # WRONG!!!   # at 5
        r2 = len(nums)-1
        while r2 > r and nums[r2] <= nums[r-1]:
            r2 -= 1
        nums[r-1], nums[r2] = nums[r2], nums[r-1]
        nums[pvt:] = nums[pvt:][::-1]
        return None
        
```



### <a name="34">34</a>

```python
from bisect import * # bisect_left() bisect_right()
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums:
            return [-1, -1]
        
        l = bisect_left(nums, target)
        r = bisect_right(nums, target)
        if l == r:
            return [-1, -1]
        return [l, r-1]
```



### <a name="42">42</a>

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        return self.two_ptr(height)
        # height = [0,1,0,2,1,0,1,3,2,1,2,1]
        # l_max =  [0 0 1 1 2 2 2 2 3 3 3 3]
        # r_max =  [3 3 3 3 3 3 3 2 2 2 1 0]
        # min_nbr = min(l_max[i], r_max[i])
        # water[i] = height[i] < min_nbr ? (min_nbr-height[i]) * 1:0
        # return sum(water)
        return self.two_ptr(height)
        return self.dp_sol(height)
        
        
    def two_ptr(self, height):
        l, r = 0, len(height)-1
        l_max, r_max = 0, 0
        count = 0
        while l < r:
            # if height[l] < height[r]:     # This should behind updates of l and r, or FAILED in VALLEY as [2 0 2]
            #     l += 1
            # else:
            #     r -= 1
                
            if height[l] >= l_max:
                l_max = height[l]
            else:
                cur = max(min(l_max, r_max) * 1 - height[l], 0)
                count += cur
                # l += 1
            if height[r] >= r_max:
                r_max = height[r]
            else:
                cur = max(min(l_max, r_max) * 1 - height[r], 0)
                count += cur
                # r -= 1
                
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return count
        
    def dp_sol(self, height):
        n = len(height)
        l_max = [0] * n
        cur_max = 0
        for i in range(n):
            l_max[i] = cur_max
            cur_max = max(height[i], cur_max)
            
        r_max = [0] * n
        cur_max = 0
        for j in reversed(range(n)):
            r_max[j] = cur_max
            cur_max = max(height[j], cur_max)
            
        
        res = 0
        for k in range(n):
            min_nbr = min(l_max[k], r_max[k])
            res += (min_nbr-height[k])*1 if height[k] < min_nbr else 0
            
        return res
```



### <a name="43">43</a>

```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        a = self.string2num(num1)
        b = self.string2num(num2)
        
        return str(a*b)
        
    def string2num(self, n):
        ret = 0
        for i in range(len(n)):
            digit = ord(n[i]) - ord('0')
            ret = 10*ret + digit
        
        return ret
```



### <a name="48">48</a>

```python

'''
1 2 4  8  3  7 6  5   ==>   
          pvt r
'''
    
    # 3 5 7 4  6 9 8 7 6 5
from bisect import bisect_right
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        if not nums:
            return None
        
        if len(nums) == 1:
            return None
        
        r = len(nums)-1

        while r > 0 and nums[r] <= nums[r-1]:
            r -= 1
        
        if r == 0:   # 5 4 3 2 1
            # nums = nums[::-1]     # not in-place
            nums.reverse()
            return None
        
        #              # 1 2 3 4 5
        if r == len(nums) - 1:
            # nums[1:].reverse()  # DOESN'T WORK!!!
            nums[-1], nums[-2] = nums[-2], nums[-1]
            return None
        
        # if r == nums[]
        pvt = r
        # idx = bisect_right(nums[pvt:], nums[ref]) + r # WRONG!!!   # at 5
        r2 = len(nums)-1
        while r2 > r and nums[r2] <= nums[r-1]:
            r2 -= 1
        nums[r-1], nums[r2] = nums[r2], nums[r-1]
        nums[pvt:] = nums[pvt:][::-1]
        return None
        
```



### <a name="51">51</a>

```python
from copy import deepcopy
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        self.result = []
        mark = [[0 for j in range(n)] for i in range(n)]
        location = [['.' for j in range(n)] for i in range(n)]
        self.gen(n, 0, mark, location)
        return self.result
    
    def gen(self, n, k, mark, location):  # k == level
        if k == n:
            self.result.append([''.join(row) for row in location])
            return 
        
        for j in range(n):  # row
            # print(k, j)
            if mark[k][j] == 0:
                # row_data += 
                tmp_mark = deepcopy(mark)
                location[k][j] = 'Q'
                mark = self.put_down_the_queen(n, k, j, mark)
                self.gen(n, k+1, mark, location)
                mark = deepcopy(tmp_mark)
                location[k][j] = '.'
        
    def put_down_the_queen(self, n, r, c, mark):
        dr = [ 0, 0, -1, 1, -1,  1, -1, 1]
        dc = [-1, 1,  0, 0, -1, -1,  1, 1]
        
        for i in range(0, n):
            for j in range(len(dc)):
                new_r = r + i * dr[j]
                new_c = c + i * dc[j]
                if new_c >=0 and new_r >=0 and new_c < n and new_r < n:
                    mark[new_r][new_c] = 1    
        return mark
```



### <a name="52">52</a>

```python
from copy import deepcopy
class Solution:
    def totalNQueens(self, n: int) -> int:
        attack_range = [[0 for j in range(n)] for i in range(n)]
        board = [['.' for j in range(n)] for i in range(n)]
        self.result = []
        self.helper(0, n, attack_range, board)
        
        return len(self.result)
        
    def helper(self, row, n, attack_range, board):
        if row == n:
            self.result.append(deepcopy(board))
            return 
        
        for col in range(n):
            if attack_range[row][col] == 1:
                continue
                
            tmp_attack = deepcopy(attack_range)
            attack_range = self.put_down_queen(n, row, col, attack_range)
            board[row][col] = 'Q'
            
            self.helper(row+1, n, attack_range, board)
            attack_range = deepcopy(tmp_attack)
            board[row][col] = '.'

    
    def put_down_queen(self, n, row, col, attack_range):
        # update attack_range
        drow = [1, -1, 0,  0, 1,  1, -1, -1]
        dcol = [0,  0, 1, -1, 1, -1,  1, -1]
        
        for k in range(len(drow)):
            for dis in range(n):
                new_row = row + dis*drow[k]
                new_col = col + dis*dcol[k]
                
                if new_row >= 0 and new_row < n and new_col >= 0 and new_col < n:
                    attack_range[new_row][new_col] = 1
        return attack_range
```



### <a name="53">53</a>

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]
        
        dp = [0] + [0] * len(nums)
        '''
        
            -2              1       -3 4 -1 2
 uptome      0              0    
       max(0, 0+-2)     max(0, 1)
        '''
        dp[1] = max(dp[0]+nums[0], nums[0]) 
        dp[2] = max(dp[1]+nums[1], nums[1])
        g = float('-inf')
        for j in range(1, len(dp)):
            dp[j] = max(dp[j-1] + nums[j-1], nums[j-1]) 
            g = max(g, dp[j])
        # return dp[-1]
        return g
```



### <a name="56">56</a>

```python
import heapq
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        return self.helper(intervals)
    
    def helper(self, intervals):
        if not intervals:
            return intervals
        result = []
        intervals_s = sorted(intervals, key=lambda x: x[0])
        prev_start, prev_end = intervals_s[0][0], intervals_s[0][1]
        for i in range(1, len(intervals)):
            # cur_end_time 
            if intervals_s[i][0] <= prev_end:
                prev_end = max(prev_end, intervals_s[i][1])
                # result.append([prev_start, intervals_s[i][1]])
            else:   # not able to merge
                result.append([prev_start, prev_end])
                prev_start = intervals_s[i][0]
                prev_end = intervals_s[i][1]
        result.append([prev_start, prev_end])
        
        return result
```



### <a name="66">66</a>

```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        # l = digits[:len(digits)-1] + [digits[-1]+1]
        # s = ''.join([str(num) for num in l])
        # res = []
        # res += [c for c in s]
        # return res
        if not digits:
            return digits
        
        s, t = ''.join([str(dg) for dg in digits]), '1'
        s = s[::-1]
        i = 0
        carry = 0
        result = []
        while i < len(s):
            num = ord(s[i]) - ord('0')
            m = 0
            if i < len(t):
                m = ord(t[i]) - ord('0')
            total = carry + num + m
            carry, digit = total//10, total%10
            result.append(digit)
            i += 1
        
        if carry:
            result.append(1)
        return result[::-1]
            
```



### <a name="138">138</a>

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""
from collections import deque
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head:
            return head
        visited = dict()
        return self.helper2(head, visited)
        
    ''' Build from Bottom Up '''
    def helper2(self, root, visited):
        if not root:
            return None
        if root in visited:
            return visited[root]
        
        copy = Node(root.val)
        visited[root] = copy            # This Line EARLIER than recursive call is CRUCIAL 
        N_ptr = self.helper2(root.next, visited)
        R_ptr = self.helper2(root.random, visited)
        
        copy.next = N_ptr
        copy.random = R_ptr
        # visited[root] = copy
        
        return copy
        
        
#     def helper(self, root, visited):
#         if not root:
#             return None
        
#         # for 1st node
#         # if root not in visited:
#         copy = Node(root.val)
#         visited[root] = copy
        
#         # if root.next:
#         copy_next = Node(root.next.val)
#         node.next = copy_next
#         visited[root.next] = copy_next
#         # if root.random:
#         copy_random = Node(root.random.val)
#         node.random = copy_random
#         visited[root.random] = copy_random
          
            
#         N_ptr = self.helper(root.next)#, visited)
#         R_ptr = self.helper(root.random)#, visited)
        
        
        
    def copyRandomList_copy(self, head: 'Node') -> 'Node':
        queue = []
        copy = {}
        if not head:
            return
        queue.append(head)
        copy[head] = Node(head.val,None,None)
        while queue:
            cur = queue.pop(0)
            n,r = cur.next,cur.random
            if n:
                if n not in copy:
                    copy[n] = Node(n.val,None,None)
                queue.append(n)
                copy[cur].next = copy[n]
            if r:
                if r not in copy:
                    copy[r] = Node(r.val,None,None)
                copy[cur].random = copy[r]
        return copy[head]
```



### <a name="146">146</a>

```python
from collections import OrderedDict
class LRUCache(object):

    def __init__(self, capacity):
        # self.od = collections.OrderedDict()
        # self.hash = {}
        # self.que = deque()
        self.od = OrderedDict()
        self.capacity = capacity

        
    def get(self, key):
        if key not in self.od:
            return -1
        else:
            res = self.od[key]
            del self.od[key]
            self.od[key] = res
            return res
    '''
        1 1 
        2 2

    cms 3 3  ==> del 1 1    del odr_dict[next(iter(odr_dict))]

        2 2
        3 3
    cms 2 2  ==> del d[2]
                 self.d[2] = value
    '''    
    def put(self, key, value):
        if key not in self.od:
            if self.capacity == len(self.od):
                del self.od[next(iter(self.od))]
            self.od[key] = value
        else:
            del self.od[key]
            self.od[key] = value
```



### <a name="155">155</a>

```python
import heapq
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.cur_min = float("inf")
        # self.min_idx = -1

    def push(self, x: int) -> None:
        if x < self.cur_min:
            self.cur_min = x
        self.stack += [(x, self.cur_min)]
        # self.min_idx = 

    def pop(self) -> None:
        # self.stack.pop(-1)[0] if self.stack else None
        v = self.stack.pop(-1)
        if self.stack:
            # if self.stack[-1][1] < self.cur_min:
            self.cur_min = self.stack[-1][1]
        else:
            self.cur_min = float("inf")    
        return v[0]
        
    def top(self) -> int:
        return self.stack[-1][0] if self.stack else None

    def getMin(self) -> int:
        # return min(self.stack)
        # return self.stack[-1][1] if self.stack else self.cur_min
        return self.cur_min

```



###  <a name="200">200</a>

```python
'''
1 1 1 1 0
1 1 0 1 0
1 1 0 1 0
0 0 0 0 0
'''
# for 
#     for 
#         bfs_graph
import numpy as np
from collections import deque
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        # arr = [[0 for j in range(len(grid[0])+1)] for i in range(len(grid)+1)]
        count = 0
        
        arr = np.pad(grid, ((1,1), (1,1)))
        print(arr)
        
        # for i in range(1, len(arr)):
        #     for j in range(1, len(arr[0])):
        for i in range(1, len(arr)-1):
            for j in range(1, len(arr[0])-1):
                if arr[i][j] == '1':
                    self.bfs((arr[i][j], i, j), arr)
                    count += 1
        return count
        
    def bfs(self, item, arr):
        Q = deque()
        Q.append(item)
        
        while Q:
            val, i, j = Q.popleft()
            if val == '1':
                arr[i][j] = '0'
                
            if arr[i][j-1] == '1':         # '0' is True...
                Q.append((arr[i][j-1], i, j-1))
                arr[i][j-1] = 'x'
            if arr[i-1][j] == '1':
                Q.append((arr[i-1][j], i-1, j))
                arr[i-1][j] = 'x'
            if arr[i][j+1] == '1':
                Q.append((arr[i][j+1], i, j+1))
                arr[i][j+1] = 'x'
            if arr[i+1][j] == '1':
                Q.append((arr[i+1][j], i+1, j))
                arr[i+1][j] = 'x'
```



### <a name="215">215</a>

**Complexity Analysis**

- Heap
  - Time complexity : \mathcal{O}(N \log k)O(*N*log*k*).
  - Space complexity : \mathcal{O}(k)O(*k*) to store the heap elements.
- QuickSelect
  - Time complexity : \mathcal{O}(N)O(*N*) in the average case, \mathcal{O}(N^2)O(*N*2) in the worst case.
  - Space complexity : \mathcal{O}(1)O(1).

```python
'''
def partition(l, r, arr)
    3 5 2 1 5 6 4   k=2

    pvt 3 l 2 r 4

    fn to set 3 at idx2
    while l<r:
        while arr[i] 5 < 3: wrong
            l ++
        l 2
        while arr[j]  > 3: till 1 idx -4 == idx 3
            r -- 
        r 3
        swap(arr[l], arr[r])
      3 1 2 5 5 6 4 
          l
          r
      2 1 3 5 5 6 4   
        return l
    
2 1 3 5 5 6 4   
1 2 3 4 5 6  2nd large means idx 4 == 6 - 2 
K largest means K_idx = len(arr) - K small
while l < r
    idx = partition()    
    K_idx = len(arr) - K
    if K_idx < idx:
        r = idx - 1
    elif k_idx > idx:
        l = idx +1
    else:
        break
return arr[K_idx]
'''
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        if not nums:
            return 0
        
        return self.helper(nums, 0, len(nums)-1)
    
    def helper(self, nums, i, j):
        if i >= j:
            return 0
        
        i, j = 0, len(nums)-1
        # 1 2 3 4 5 6
        
        # k = 2 ==> idx 4.  6-2
        k_idx = len(nums) - k
        while i < j:
            pvt_idx = self.partition(i, j, nums)
            if k_idx < pvt_idx:
                j = pvt_idx - 1
            elif k_idx > pvt_idx:
                i = pvt_idx + 1
            else:
                break
        return nums[k_idx]
            
    # 3 2 5 4 1 6
    def partition(self, l, r, arr):
        pvt = arr[l]
        ll = l+1
        while ll < r:    
            while arr[ll] < pvt and ll < r:
                ll += 1
            while arr[r] > pvt and ll < r:
                r -= 1
            arr[ll], arr[r] = arr[r], arr[ll]
            
        return ll




## TODO: k largest ==> len(nums) - k + 1 small
# 1 2 3 4 5 6
# k  = 2 ==> 5
# ks = 5 ==> 6-2+1
import heapq
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # l = nums
        if not nums:
            return 0

        heapq.heapify(nums) #O(N)
        ks = len(nums) - k + 1
        for i in range(ks-1):
            heapq.heappop(nums) # ks * O(lgN)
        return heapq.heappop(nums)
        
```



### <a name="222">222</a>

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
'''
    1               i0
   / \
  2   3    h 1      2^i children
 / \  /
4  5 6     h 2
1 count level by dfs, at each level, we should get 
'''
from collections import deque
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        return self.helper_recur(root)
        return self.helper_iter(root)
    
    def helper_recur(self, root):
        if not root:
            count = 0
            return count
        else:
            count = 1
        
        L = self.helper_recur(root.left)
        R = self.helper_recur(root.right)
        return count + L + R
        
        
        
    def helper_iter(self, root):
        Q = deque()
        Q.append(root)
        # level = 0   # expect get 2**level children
        count = 0
        height = 0
        while Q:       
            level_Q = deque()
            len_q = len(Q)
            for i in range(len_q):
                node = Q.popleft()  # 1 
                if node.left:
                    level_Q.append(node.left)
                if node.right:
                    level_Q.append(node.right)
            height += 1
            if len(level_Q) != 2**height:
                break
            Q = level_Q.copy()
        
        ans = 2**(height)-1 + len(level_Q)
        return ans
```

- Time complexity : \mathcal{O}(N)O(*N*).
- Space complexity : \mathcal{O}(d) = \mathcal{O}(\log N)O(*d*)=O(log*N*) to keep the recursion stack, where d is a tree depth.



### <a name="242">242</a>

```python
from collections import Counter
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        cs = Counter(s)
        ct = Counter(t)
        
        return cs == ct
```

**Complexity analysis**

- Time complexity : O(n)*O*(*n*). Time complexity is O(n)*O*(*n*) because accessing the counter table is a constant time operation.
- Space complexity : O(1)*O*(1). Although we do use extra space, the space complexity is O(1)*O*(1) because the table's size stays constant no matter how large n*n* is.

### <a name="253">253</a>

```python
import heapq
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        intervals = sorted(intervals, key=lambda x: x[0])   # sort according to start 
        if not intervals:
            return 0
        count = 0
        # 2nd start == 1st end , no need one more room
        # end = [intervals[0][1]]
        end = []        # shouldn't or two 5 for case [[1,5],[8,9],[8,9]] after first looping
        for interval in intervals:
            # cur_earliest_end = end[0]       # 9
            if  not end or interval[0] < end[0]:#cur_earliest_end:
                count += 1
            else:
                heapq.heappop(end)
            heapq.heappush(end, interval[1])    
        return count
```

- Time Complexity: O(N\log N)*O*(*N*log*N*).
  - There are two major portions that take up time here. One is `sorting` of the array that takes O(N\log N)*O*(*N*log*N*) considering that the array consists of N*N* elements.
  - Then we have the `min-heap`. In the worst case, all N*N* meetings will collide with each other. In any case we have N*N* add operations on the heap. In the worst case we will have N*N* extract-min operations as well. Overall complexity being (NlogN)(*N**l**o**g**N*) since extract-min operation on a heap takes O(\log N)*O*(log*N*).
- Space Complexity: O(N)*O*(*N*) because we construct the `min-heap` and that can contain N*N* elements in the worst case as described above in the time complexity section. Hence, the space complexity is O(N)*O*(*N*).

<img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbyhxbi09fj31dy0u0qan.jpg" alt="img" style="zoom:50%;" />



```python
public class Solution {
    public int minMeetingRooms(Interval[] intervals) {
        int[] starts = new int[intervals.length];
        int[] ends = new int[intervals.length];
        for(int i=0; i<intervals.length; i++) {
            starts[i] = intervals[i].start;
            ends[i] = intervals[i].end;
        }
        Arrays.sort(starts);
        Arrays.sort(ends);
        int rooms = 0;
        int endsItr = 0;
        for(int i=0; i<starts.length; i++) {
            if(starts[i]<ends[endsItr])
                rooms++;
            else
                endsItr++;
        }
        return rooms;
    }
}
```



### <a name="543">543</a>

```python
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.g_max = 0
        self.helper(root)
        return self.g_max
    # return height and calculate dia at root
    def helper(self, root):
        # if not root:
        if not root:
            return 0
        
        # L_diameter = self.helper(root.left)
        # R_diameter = self.helper(root.right)
        
        L_height = self.height(root.left)
        R_height = self.height(root.right)
        # diameter = L_height + R_height + 1
        diameter = L_height + R_height
        # self.g_max = max(self.g_max, diameter)
        
        L = self.helper(root.left)
        R = self.helper(root.right)
        self.g_max = max(self.g_max, diameter, L, R)
        # return 1 + max(L_height, R_height)        
        return diameter
        
    def height(self, root):
        if not root:
            return 0
        L = self.height(root.left)  
        R = self.height(root.right)
        return 1 + max(L, R)
```



### <a name="852">852</a>

```python
class Solution:
    def peakIndexInMountainArray(self, A: List[int]) -> int:
        l, r = 0, len(A)-1
        
        while l < r:
            mid = l + (r-l)//2
            if mid > 0 and mid < len(A)-1 and A[mid-1] < A[mid] and A[mid] > A[mid+1]:
                return mid
            if A[mid] < A[mid+1]:
                l = mid + 1
            else:
                r = mid - 1
        return l
```

##### Better

```python
class Solution:
    def peakIndexInMountainArray(self, A: List[int]) -> int:
        l, r = 0, len(A)-1
        
        while l < r:
            mid = l + (r-l)//2
            # if mid > 0 and mid < len(A)-1 and A[mid-1] < A[mid] and A[mid] > A[mid+1]:
            #     return mid
            if A[mid] < A[mid+1]:
                l = mid + 1
            else:
                # r = mid - 1
                r = mid
        return l
```



### <a name="904">904</a>

```python
'''
Lonest subarray with k charaters!!

    1 2 3 2 2 1 1 1 1 1 1 
　　j　　　　i　　　         open ( ]close
                          
j   i   od                                      amount
-1  0   {1:0}                                   1
-1  1   {1:0, 2:1 }                             2
 0  2   {1:0  2:1  3:2}  ==> {2:1  3:2}         2
 0  3   {2:3  3:2     }                         3
 0  4   {2:4  3:2     }                         4              record g_max
 2  5   {2:4  3:2  1:5}  ==> {3:2  1:5}         3              
同時維護　OrderedDict 跟指針難
                          
j   i   od                                      amount
-1  0   {1:0}                                   1
-1  1   {1:0, 2:1}                              2
 0  2   {1:0  2:1  3:2}  ==> same               2
 0  3   {1:0  2:3  3:2}                         3
 0  4   {1:0  2:4  3:2}                         4              record g_max
 2  5   {1:5  2:4  3:2}  ==> same               3              
X                          

j   i   od                                             amount
 0  0   {1:1}                                           1
 0  1   {1:1  2:1}                                      2
 0  2   {1:1  2:1  3:1}  ==> 1 2 {1:0  2:1  3:1}          2     i-j+1
 1  3   {1:0  2:2  3:1}                                 3
 1  4   {1:0  2:3  3:1}                                 4              record g_max
 1  5   {1:1  2:4  3:1}  ==> 2 5 {1:1  2:3  3:1}             3                               
                         ==> 3 5 {1:1  2:3  3:0}             3
'''
from collections import OrderedDict
class Solution:
    def totalFruit(self, tree: List[int]) -> int:
        od = OrderedDict()
        j = 0              
        g_max = cur_amount = 0
        res = []
        for i in range(len(tree)):
            val = tree[i]
            if val not in od:
                od[val] = 1
            else:
                od[val] += 1
            
            # if len(od) >= 2:
            while len(od) > 2:
                od[tree[j]] -= 1
                if od[tree[j]] == 0:
                    del od[tree[j]]
                j += 1
                
            cur_amount = i - j + 1
            if cur_amount > g_max:
                g_max = cur_amount
                res.append([j, i])
        # print(res)
        return g_max                          
                          
```



### <a name="929">929</a>

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        names = set()
        count = 0
        for mail in emails:
            local_name, domain_name = mail.split('@')
            local_first = local_name.split('+')[0]
            name = ''.join(local_first.split('.'))
            item = (name, domain_name)
            print(item)
            
            if item not in names:
                count += 1
                names.add(item)
        return count
        
    # def valid_mail(self, email):
        
```



### <a name="951">951</a>

```python
class Solution:
    def flipEquiv(self, root1: TreeNode, root2: TreeNode) -> bool:
        # if not root1 and not root2:
        #     return True
        # if not root1 or not root2:
        #     return False
        
        return self.helper(root1, root2)
        
    def helper(self, l, r):
        if not l and not r:
            return True
        if not l or not r:
            return False
        if l.val != r.val:
            return False
             
        # ll, lr = l.left, l.right
        # rl, rr = r.left, r.right
        return  self.helper(l.left, r.left) and self.helper(l.right, r.right) or \
                self.helper(l.left, r.right) and self.helper(l.right, r.left)
```

