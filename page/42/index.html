<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Joe Huang"><meta name="copyright" content="Joe Huang"><title>Awaken Desparado</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Joe Huang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">251</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">36</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Awaken Desparado</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Awaken Desparado</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/25/FFmpeg/2019-06-25-ffmpeg-cmds/">ffmpeg_cmds!</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ffmpeg/">ffmpeg</a></span><div class="content"><h2 id="rm-black-sides"><a href="#rm-black-sides" class="headerlink" title="rm black sides"></a>rm black sides</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">╰─○ ffplay -i vn_hflip.mp4 -t 5 -vf cropdetect</span><br><span class="line">╰─○ ffplay -i vn_hflip.mp4 -t 5 -vf crop=1280:528:0:96</span><br></pre></td></tr></table></figure>

<h2 id="save-to-json"><a href="#save-to-json" class="headerlink" title="save to json"></a>save to json</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -hide_banner -print_format json -show_streams -i vn_hflip.mp4 &gt; vn_json_streams.log</span><br></pre></td></tr></table></figure>

<h2 id="check-error"><a href="#check-error" class="headerlink" title="check error"></a>check error</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_frames vn_hflip.mp4 &gt; vn_show_frames.log</span><br></pre></td></tr></table></figure>

<h2 id="video-to-pics"><a href="#video-to-pics" class="headerlink" title="video to pics"></a>video to pics</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i vn_hflip.mp4 -r 40 -f image2         -t 1 my%d.jpg        <span class="comment">## 跟下一行比會多了幾張重覆的，因為比來的video就25fps而已</span></span><br><span class="line"><span class="string">""</span><span class="string">"2938"</span><span class="string">""</span>  ffmpeg -i vn_hflip.mp4 -r 25 -f image2 -t 1 my25_%d.jpg <span class="comment">## 跟上一行几乎一样，就是正常的25 rate</span></span><br><span class="line">ffmpeg -i vn_hflip.mp4 -vcodec mjpeg -ss 0:0:2 -t 0:0:1 0m%04d.jpg  <span class="comment">## 跟上面比主要就是从第二秒开始</span></span><br><span class="line"></span><br><span class="line">2937  ffmpeg -i vn_hflip.mp4 -r 40 -f image2 -t 1 my25_%d.jpg</span><br><span class="line">★★★ -r, -ss, -t  本来的video要变成的rate，开始、抓多久</span><br><span class="line"></span><br><span class="line">ffmpeg -i vn_hflip.mp4 -ss 00:00:14.435 -vframes 1 out.png</span><br><span class="line">★★★ -vframes 抓几张</span><br></pre></td></tr></table></figure>

<h2 id="pics-to-video"><a href="#pics-to-video" class="headerlink" title="pics to video"></a>pics to video</h2><p>把多个图像文件使用h264编码封装成avi文件，如有my0.jpg, my1.jpg … my99.jpg</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i my%d.jpg  -vcodec h264 my.avi</span><br></pre></td></tr></table></figure>



<p>-r 选项的用法：</p>
<p>预设是</p>
<p>以25FPS读入所有图片，所以len(Images[])会是输出的video的duration. </p>
<p>作出25FPS的video, 所以如果 -r加在 output前面，会进行插帧、删帧。</p>
<p>如果-r加在 input前面，就是每秒读进来几张图片</p>
<p>如果　ffmpeg -r 10 -i z-%5d.jpeg -vcodec h264 -r 60 out10in60out.mp4</p>
<p>那么因为每秒读进来10张而已，硬做成60fps的video，也是没用，因为中间只是内插成了60fps</p>
<h2 id="video-to-gif"><a href="#video-to-gif" class="headerlink" title="video to gif"></a>video to gif</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i vn_hflip.mp4 -ss 0 -r 1 -vframes 6 vn.gif</span><br><span class="line">ffmpeg -i vn_hflip.mp4 -ss 0 -vf fps=1 -vframes 6 vn_fps.gif <span class="comment"># 这个似乎比上面的好一些</span></span><br></pre></td></tr></table></figure>




<p>##EXTRACTION !!!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 2999  ffmpeg -i ../vn_hflip.mp4 -ss 00:00:00 -t 10 -vf fps=1 fps1_%d.png</span><br><span class="line">(joe_py36) ┌─[joe@JoeMBP2] - [~/Movies/exp/tmp] - [3003]</span><br><span class="line">└─[$] <span class="built_in">history</span> | grep r1                                                                                                                                                                           [22:06:04]</span><br><span class="line"> 2975  ffmpeg -i ../vn_hflip.mp4 -r 1 r1_%d.png</span><br><span class="line"> 2977  ffmpeg -i ../vn_hflip.mp4 -r 1 -vframes 6 r1_vframes_%d.png</span><br></pre></td></tr></table></figure>







<h2 id="add-logo"><a href="#add-logo" class="headerlink" title="add logo"></a>add logo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i vn_hflip.mp4 -i ~/Pictures/Sackboy_0.jpeg -filter_complex overlay=W-w:H-h vn_logo.avi</span><br><span class="line">    如右下角: ffmpeg -i God.rm -i logo.png -filter_complex overlay=W-w:H-h my.avi</span><br><span class="line">    如居中:  ffmpeg -i God.rm -i logo.png -filter_complex overlay=W/2-w/2:H/2-h/2 my.avi</span><br></pre></td></tr></table></figure>



</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/07/Web/2019-06-07-Requests'%20secret:%20pool_connections%20and%20pool_maxsize/">Web/2019-06-07-Requests' secret: pool_connections and pool_maxsize</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/">Web</a></span><div class="content"><p>from: <a href="https://www.cnblogs.com/pengyusong/p/5802929.html" target="_blank" rel="noopener">https://www.cnblogs.com/pengyusong/p/5802929.html</a></p>
<p>and <a href="https://laike9m.com/blog/requests-secret-pool_connections-and-pool_maxsize,89/" target="_blank" rel="noopener">https://laike9m.com/blog/requests-secret-pool_connections-and-pool_maxsize,89/</a></p>
<h1 id="Requests’-secret-pool-connections-and-pool-maxsize"><a href="#Requests’-secret-pool-connections-and-pool-maxsize" class="headerlink" title="Requests’ secret: pool_connections and pool_maxsize"></a><strong>Requests’ secret: pool_connections and pool_maxsize</strong></h1><p><a href="http://docs.python-requests.org/en/latest/" target="_blank" rel="noopener">Requests</a> 是一个python开发者众所周知的第三方库。因其简单的API和高性能，大多数人倾向于使用requests而不是urllib2作为访问http的标准库。然而很多使用requests库的人可能不知道内部原因，今天我就来解释以下俩个概念: <code>pool_connections</code> 和<code>pool_maxsize</code>.</p>
<p>从 <code>Session 开始</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">'https://www.google.com'</span>)</span><br></pre></td></tr></table></figure>

<p>这很简单，你可能知道requests’ <code>Session</code> 持有cookie. 但你知道 <code>Session</code> 有一个 <a href="http://docs.python-requests.org/en/latest/api/#requests.Session.mount" target="_blank" rel="noopener"><code>mount</code></a> 方法吗?</p>
<blockquote>
<p><code>mount(prefix, adapter)</code><br>Registers a connection adapter to a prefix.<br>Adapters are sorted in descending order by key length.</p>
</blockquote>
<p>不知道？很好，实际上你已经使用了这个方法当你初始化一个session对象时:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span><span class="params">(SessionRedirectMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Default connection adapters.</span></span><br><span class="line">        self.adapters = OrderedDict()</span><br><span class="line">        self.mount(<span class="string">'https://'</span>, HTTPAdapter())</span><br><span class="line">        self.mount(<span class="string">'http://'</span>, HTTPAdapter())</span><br></pre></td></tr></table></figure>

<p>现在，到了有趣的部分。如果你阅读过 Ian Cordasco’s 文章 <a href="http://www.coglib.com/~icordasc/blog/2014/12/retries-in-requests.html" target="_blank" rel="noopener">Retries in Requests</a>, 你应该知道 <code>HTTPAdapter</code> 可以提供重试功能. 但一个 <code>HTTPAdapter</code> 真实是什么? Quoted from <a href="http://docs.python-requests.org/en/latest/api/#requests.adapters.HTTPAdapter" target="_blank" rel="noopener">doc</a>:</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">requests</span>.<span class="title">adapters</span>.<span class="title">HTTPAdapter</span><span class="params">(pool_connections=<span class="number">10</span>, pool_maxsize=<span class="number">10</span>, max_retries=<span class="number">0</span>, pool_block=False)</span></span></span><br></pre></td></tr></table></figure>

<p>The built-in HTTP Adapter for urllib3.</p>
<p>Provides a general-case interface for Requests sessions to contact HTTP and HTTPS urls by implementing the Transport Adapter interface. This class will usually be created by the Session class under the covers.</p>
<p>Parameters:</p>
<ul>
<li><code>pool_connections</code> – The number of urllib3 connection pools to cache.</li>
<li><code>pool_maxsize</code> – The maximum number of connections to save in the pool.</li>
<li><code>max_retries(int)</code> – The maximum number of retries each connection should attempt. Note, this applies only to failed DNS lookups, socket connections and connection timeouts, never to requests where data has made it to the server. By default, Requests does not retry failed connections. If you need granular control over the conditions under which we retry a request, import urllib3’s Retry class and pass that instead.</li>
<li><code>pool_block</code> – Whether the connection pool should block for connections. Usage:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="keyword">import</span> requests</span><br><span class="line">&gt;&gt; s = requests.Session()</span><br><span class="line">&gt;&gt; a = requests.adapters.HTTPAdapter(max_retries=<span class="number">3</span>)</span><br><span class="line">&gt;&gt; s.mount(<span class="string">'http://'</span>, a)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果上面的文档使你迷惑，这里是我的解释: HTTP Adapter 所做的就是：根据不同的目标url，对每个不同的请求提供不同的配置，还记得上面的代码吗？</p>
<p>　　　　what HTTP Adapter does is simply <strong>providing different configurations for different requests according to target url</strong>. Remember the code above?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.mount(<span class="string">'https://'</span>, HTTPAdapter())</span><br><span class="line">self.mount(<span class="string">'http://'</span>, HTTPAdapter())</span><br></pre></td></tr></table></figure>

<p>它创建了俩个 <code>HTTPAdapter</code> 对象使用默认的参数：<code>pool_connections=10, pool_maxsize=10, max_retries=0, pool_block=False</code>, 并且挂载到 <code>https://</code> 和 <code>http:// 相对路径</code>, 意思是第一个配置在你访问 <code>http://xxx 会使用到， 第二个会在你访问 ``https://xxx</code>. 尽管上面俩个配置是相同的，请求http和https仍然是隔离的。我们会在下面看到说明。</p>
<p>就像我说的，这篇文章的目的主要是解释 <code>pool_connections</code> and <code>pool_maxsize</code>.</p>
<p>首先，让我们看看 <code>pool_connections</code>. 昨天我在stackoverflow提出了一个问题：<a href="http://stackoverflow.com/questions/34837026/whats-the-meaning-of-pool-connections-in-requests-adapters-httpadapter" target="_blank" rel="noopener">question</a> ，因为我不确定我是否理解正确，这个问题的回答消除了我的不确定性。HTTP，众所周知，是基于TCP协议，一个HTTP连接也是一个TCP连接，它是由一个五元组唯一标识:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;protocol&gt;, &lt;src addr&gt;, &lt;src port&gt;, &lt;dest addr&gt;, &lt;dest port&gt;)</span><br></pre></td></tr></table></figure>

<p>就是说，你针对 <code>www.example.com 建立了一个HTTP/TCP连接</code>, 假设服务器支持 <code>Keep-Alive</code>, 下一次你发送请求到 <code>www.example.com/a</code> or <code>www.example.com/b</code>, 你可以使用相同的连接，因为五元组没有改变. 实际上, <a href="http://docs.python-requests.org/en/latest/user/advanced/#keep-alive" target="_blank" rel="noopener">requests’ Session 自动会帮你处理</a> 并且重用连接，只要它能.</p>
<p>这个问题是，什么决定了你是否可以重用老的连接？是的，就是 <code>pool_connections</code>!</p>
<blockquote>
<p>pool_connections – The number of urllib3 connection pools to cache.</p>
</blockquote>
<p>我知道，我知道，我也不想引入很多术语, 这是最后一个，我发誓. 简单的理解它， 一个host对应的一个连接池：<strong>one connection pool corresponds to one host</strong>, 嗯，就是这个意思.</p>
<p>这是一个例子，无关的行已被忽略:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.mount(<span class="string">'https://'</span>, HTTPAdapter(pool_connections=1))</span><br><span class="line">s.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">s.get(<span class="string">'https://www.zhihu.com'</span>)</span><br><span class="line">s.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">"output</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.baidu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 None</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.zhihu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 2621</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.baidu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 None</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>

<p><code>HTTPAdapter(pool_connections=1)</code> 被映射到 <code>https://</code>, 他意思是在同一时间仅有一个连接池. 在调用 <code>s.get(&#39;https://www.baidu.com&#39;)</code>, 缓存的连接池是 <code>connectionpool(&#39;https://www.baidu.com&#39;)</code>. 现在 <code>s.get(&#39;https://www.zhihu.com&#39;)</code> 来了，这个session发现他不能使用缓存的连接，因为他不是相同的host(one connection pool corresponds to one host, remember?). 因此session不得不创建一个新的连接池. 因为 <code>pool_connections=1</code>, session不能在同一时间持有俩个连接池, 因此他丢弃了旧的连接池： <code>connectionpool(&#39;https://www.baidu.com&#39;)</code> 并且保存了新的：<code>connectionpool(&#39;https://www.zhihu.com&#39;)</code>. 下一次get同样如此Next <code>get</code> is the same. 这就是我们看见三个 <code>Starting new HTTPS connection</code> 日志行的原因</p>
<p>如果我们设置 <code>pool_connections</code> 为 2:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.mount(<span class="string">'https://'</span>, HTTPAdapter(pool_connections=2))</span><br><span class="line">s.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">s.get(<span class="string">'https://www.zhihu.com'</span>)</span><br><span class="line">s.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="string">""</span><span class="string">"output</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.baidu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 None</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.zhihu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 2623</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 None</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>很好，现在我们可以创建连接俩次了并且保持连接活跃</p>
<p>最后, <code>pool_maxsize</code>.</p>
<p>首先, 仅当你在多线程环境下使用session，你才应该关心 <code>pool_maxsize</code> , 例如，从多个线程使用同一个session发出并发请求.</p>
<p>实际上，<code>pool_maxsize</code> 是一个用来初始化urllib3’s <code>HTTPConnectionPool的参数</code>, 它才是真正含义上的连接池. <code>HTTPConnectionPool</code> 是一个容器，针对于特定的host保存连接的集合, 且 <code>pool_maxsize</code> 是这个集合的最大值. 如果你运行你的代码在同一个线程，它是不可能针对多个主机创建多个连接的，因为 requests library 是阻塞的, 因此HTTP请求总是一个接着一个发送.</p>
<p>如果使用多线程就会不一样.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def thread_get(url):</span><br><span class="line">    s.get(url)</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">s.mount(<span class="string">'https://'</span>, HTTPAdapter(pool_connections=1, pool_maxsize=2))</span><br><span class="line">t1 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com'</span>,))</span><br><span class="line">t2 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/36612174'</span>,))</span><br><span class="line">t1.start();t2.start()</span><br><span class="line">t1.join();t2.join()</span><br><span class="line">t3 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/39420364'</span>,))</span><br><span class="line">t4 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/21362402'</span>,))</span><br><span class="line">t3.start();t4.start()</span><br><span class="line"><span class="string">""</span><span class="string">"output</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.zhihu.com</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (2): www.zhihu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/36612174 HTTP/1.1<span class="string">" 200 21906</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 2606</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/21362402 HTTP/1.1<span class="string">" 200 57556</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/39420364 HTTP/1.1<span class="string">" 200 28739</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>看见了吗? 它为相同的host建立了俩个连接： <code>www.zhihu.com</code>, 就像我说的, 这个仅发生在多线程环境下. 在这个例子中，我们创建了一个连接池，使用了参数 <code>pool_maxsize=2</code>, 发现同一时间不会超过俩个连接，因此这是足够的，我们看到<code>t3</code> 和 <code>t4</code> 没有创建新的连接，他们重用了就的连接.</p>
<p>如果没有足够的大小呢?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.mount(<span class="string">'https://'</span>, HTTPAdapter(pool_connections=1, pool_maxsize=1))</span><br><span class="line">t1 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com'</span>,))</span><br><span class="line">t2 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/36612174'</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join();t2.join()</span><br><span class="line">t3 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/39420364'</span>,))</span><br><span class="line">t4 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/21362402'</span>,))</span><br><span class="line">t3.start();t4.start()</span><br><span class="line">t3.join();t4.join()</span><br><span class="line"><span class="string">""</span><span class="string">"output</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.zhihu.com</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (2): www.zhihu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/36612174 HTTP/1.1<span class="string">" 200 21906</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 2606</span></span><br><span class="line"><span class="string">WARNING:requests.packages.urllib3.connectionpool:Connection pool is full, discarding connection: www.zhihu.com</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (3): www.zhihu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/39420364 HTTP/1.1<span class="string">" 200 28739</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/21362402 HTTP/1.1<span class="string">" 200 57556</span></span><br><span class="line"><span class="string">WARNING:requests.packages.urllib3.connectionpool:Connection pool is full, discarding connection: www.zhihu.com</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>现在, <code>pool_maxsize=1</code>，会打印警告日志如下，就像下面的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection pool is full, discarding connection: www.zhihu.com</span><br></pre></td></tr></table></figure>

<p>可以注意到仅有一个连接被保存在连接池中, 为t3或者t4创建一个新的连接. 很明显这是不够的. 这就是为什么在 urllib3’s 文档中说明如下:</p>
<blockquote>
<p>如果你计划在连接池环境下使用一个连接池, 你应该设置连接池最大数量为一个比较高的值，例如和线程的数量相同.</p>
</blockquote>
<p>最后, <code>HTTPAdapter</code> 实例映射到不同的前缀是相互独立的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.mount(<span class="string">'https://'</span>, HTTPAdapter(pool_connections=1, pool_maxsize=2))</span><br><span class="line">s.mount(<span class="string">'https://baidu.com'</span>, HTTPAdapter(pool_connections=1, pool_maxsize=1))</span><br><span class="line">t1 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com'</span>,))</span><br><span class="line">t2 =Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/36612174'</span>,))</span><br><span class="line">t1.start();t2.start()</span><br><span class="line">t1.join();t2.join()</span><br><span class="line">t3 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/39420364'</span>,))</span><br><span class="line">t4 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/21362402'</span>,))</span><br><span class="line">t3.start();t4.start()</span><br><span class="line">t3.join();t4.join()</span><br><span class="line"><span class="string">""</span><span class="string">"output</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.zhihu.com</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (2): www.zhihu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/36612174 HTTP/1.1<span class="string">" 200 21906</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 2623</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/39420364 HTTP/1.1<span class="string">" 200 28739</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/21362402 HTTP/1.1<span class="string">" 200 57669</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>上面的代码很容易，不需要再次解释了.</p>
<p>就这样了，希望这篇文章帮助你更好的理解requests库. 顺便说一下，我创建了一个gist <a href="https://gist.github.com/laike9m/ead19c65a416c7022c00" target="_blank" rel="noopener">here</a> 这里包含这篇文章的测试代码. 随便下载并尝试吧</p>
<h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><ol>
<li><p>For https, requests uses urllib3’s <a href="http://urllib3.readthedocs.org/en/latest/pools.html#urllib3.connectionpool.HTTPSConnectionPool" target="_blank" rel="noopener">HTTPSConnectionPool</a>, but it’s pretty much the same as HTTPConnectionPool so I didn’t differeniate them in this article.</p>
</li>
<li><p><code>Session</code>‘s <code>mount</code> method ensures the longest prefix gets matched first. Its implementation is pretty interesting so I posted it here.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mount</span><span class="params">(self, prefix, adapter)</span>:</span></span><br><span class="line">    <span class="string">"""Registers a connection adapter to a prefix.</span></span><br><span class="line"><span class="string">    Adapters are sorted in descending order by key length."""</span></span><br><span class="line">    self.adapters[prefix] = adapter</span><br><span class="line">    keys_to_move = [k <span class="keyword">for</span> k <span class="keyword">in</span> self.adapters <span class="keyword">if</span> len(k) &lt; len(prefix)]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys_to_move:</span><br><span class="line">        self.adapters[key] = self.adapters.pop(key)</span><br></pre></td></tr></table></figure>

<p>Note that <code>self.adapters</code> is an <code>OrderedDict</code>.</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/05/03/LC/2019-05-03-Remove-Element/">LC/2019-05-03-Remove-Element</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/LC/">LC</a></span><div class="content"><p>RemoveElement</p>
<p>​</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/01/System-Design/9p/2019-04-01-Web%20System%20API%20Design%20&amp;%20TinyURL/">System-Design/9p/2019-04-01-Web System API Design &amp; TinyURL</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SystemDesign/">SystemDesign</a></span><div class="content"><h1 id="General"><a href="#General" class="headerlink" title="General"></a>General</h1><h2 id="Web-Framework"><a href="#Web-Framework" class="headerlink" title="Web Framework"></a>Web Framework</h2><ul>
<li><p>登錄, session, cookies</p>
</li>
<li><p>CSRF攻擊 - Cross-site Request Forgery 如果拿的link是建數據的post請求，現在也是server會給browser一個CSRF token，去防無效token。</p>
<ul>
<li>python - django，flask輕巧要裝一堆插件，把密碼md5哈希，現在是SHA256</li>
<li>java - spring</li>
<li>ruby - ruby on rail</li>
</ul>
</li>
<li><p>ORM </p>
</li>
<li><p>登入登出</p>
</li>
<li><p><strong>http server</strong> is between user and web framwork, 管理多進程。</p>
<ul>
<li>Uwsgi 多進程啟多個Django的進程，服務如100個用戶就自己刪了重啟之類</li>
<li>Apache</li>
<li>Unicorn</li>
<li>Gunicorn</li>
<li>Nginx 不同網站去不同站口避免打架</li>
</ul>
</li>
</ul>
<h1 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h1><blockquote>
<h5 id="单选题-www-net-cn-的根域名（不含后缀）是什么？"><a href="#单选题-www-net-cn-的根域名（不含后缀）是什么？" class="headerlink" title="[单选题]www.net.cn 的根域名（不含后缀）是什么？"></a>[单选题]<a href="http://www.net.cn" target="_blank" rel="noopener">www.net.cn</a> 的根域名（不含后缀）是什么？</h5><p>A.net72.88% 选择</p>
<p>B.www27.12% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是A</p>
<p><strong>正确答案:</strong>B</p>
<p><strong>解析:</strong></p>
<p><a href="http://www.net.cn" target="_blank" rel="noopener">www.net.cn</a> 是一个 .net.cn 为后缀的域名，而不是一个 .cn 为后缀的域名。意不意外，惊不惊喜！</p>
</blockquote>
<h2 id="Basics-amp-Flows"><a href="#Basics-amp-Flows" class="headerlink" title="Basics &amp; Flows"></a>Basics &amp; Flows</h2><p>網站開發：</p>
<p>跑通流程</p>
<p>申域名、綁ip地址、在AWS買server、在上面跑http server (Apache; Unicorn, Gunicorn; Uwsgi 都ok) 、用任一個框架 flask, django 搭起網站，搭個todo list就OK、message queue搭起來。</p>
<blockquote>
<ul>
<li><p>可以认为web server 是由http server和web application组成吗？感觉当我们访问了google.com的时候，是这样的流程：浏览器URL-&gt;DNS服务器(http request)-&gt;Http Server(可以认为是SpringMVC里的DispatcherServlet吗) -&gt; Web App(可以认为是SpringMVC里的Controller吗？就是找到对应哪个action进行处理这个请求)。不好意思对于这些概念和spring mvc都不是很理解，希望助教能指正</p>
<ul>
<li>HTTP Server 不是 Spring 里的任何东西。Web App 才是 Spring。HTTP Server 一般是在 Web APP 的前面会配置起来用作控制 Web App 多进程并发的一个软件，一般典型代表是 UWSGI, Unicorn 这种。你所知道的 Spring 的任何概念，都属于一个 Web App 里的一部分。</li>
</ul>
</li>
<li><p>我除了GET以外的操作（例如PUT和DELETE的操作）都使用POST Method是不是就可以了呢（操作类别通过url或parameter区分）？</p>
<ul>
<li>一般的Rest API设计规范是要求POST, DELETE, GET, PUT，分别对应增删查改，符合规范会让别人更容易理解你的接口。你说的方法虽然也可以，但是不符合Rest的规范。</li>
</ul>
</li>
<li><p>web application在哪里运行的呢？听说用docker来deploy web application，这个是执行application的地方吗？</p>
<ul>
<li>web application 可以在 docker 里执行。 docker 的概念可以理解为在 Operating System 上包装出来的一个独立的小 operating system。其实 web application 就是跑在操作系统上的，可以是 linux，可以是 windows。因为 web application 就是一个程序，一个进程。代码该在什么地方执行就在什么地方执行。</li>
</ul>
</li>
<li><p>请问，Async Server和Web Server在功能上的区别是什么？ 是否Web server一般用来接收用户的request和跑web application，而Async Server就是用来存储message queue的呢？</p>
<ul>
<li><p>在News Feed Push model的senario中，fanout本质上是一个写扩散的过程。<br>（1）Web Server主要是接受用户请求并dispatch到不同的wap app经controller直至具体某个处理特定businesslogic的service上。<br>（2）Async server的作用就是从这个人（明星）中frenship service中找到其相应的followers(粉丝)然后，对每一个follower用户对应的news_feed_table[id, owner_id, tweet_id, create]写入相关的记录，这样用户登录使用时就能看到news feeds。<br>如果存储的表(tweet_table, news_feed_table)都在都在同一个数据，那么这个写扩散的过程，其实就是在同一个数据库中创建相应的触发器(trigger)、存储过程(procedure)和定时执行作业，就能实现。<br>但是如果在不同的地理分布位置，而且follower数据量庞大，那么就要借助中间件(message queue)来完成, 利用中间件message queue是采用生产者与消费者的模式实现的publish/subscribe的技术，保证把每一个发布的（tweet）信息，准确返送到每一个subsrriptio端的consumer来完成消息的写扩散（fan out）过程。具体的messge queue的理解请阅读维基百科相关内容<a href="https://bit.ly/2kwnxNl" target="_blank" rel="noopener">https://bit.ly/2kwnxNl</a>, message queue具体实现场景，请阅《蚂蚁金服：消息队列事务型消息原理浅析》<a href="https://bit.ly/2lAJOKe" target="_blank" rel="noopener">https://bit.ly/2lAJOKe</a></p>
<p>显示我</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h2><blockquote>
<h5 id="单选题-以下API设计哪个是对的？"><a href="#单选题-以下API设计哪个是对的？" class="headerlink" title="[单选题]以下API设计哪个是对的？"></a>[单选题]以下API设计哪个是对的？</h5><p>API用于获取当前登录用户在题号1000这个题上的所有提交记录</p>
<p>A./api/users/<current_user_id>/submissions/?problem_id=100017.61% 选择</p>
<p>B./api/users/me/submissions/?problem_id=10006.82% 选择</p>
<p>C./api/submissions/?problem_id=1000&amp;user_id=<current_user_id>33.28% 选择</p>
<p>D./api/submissions/?problem_id=100032.01% 选择</p>
<p>E./api/problems/1000/submissions/10.28% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是D</p>
<p><strong>正确答案:</strong>D</p>
</blockquote>
<p>A、B、C不科學，別人可以查自己哦？</p>
<p>E不對, D才符合REST API的約束、規範，一級目錄要是自己要獲取的東西</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdh1w428fgj30p419sq94.jpg" alt="image-20200404003659176"></p>
<h2 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h2><blockquote>
<ul>
<li>post request 推荐 return 什么信息最好<ul>
<li>it depends。创建一个 instance 一般就 return 这个 instance 的json。</li>
</ul>
</li>
<li>get all accounts 呢？<ul>
<li>get /api/accounts/?filter=xxx&amp;sort_by=xxx</li>
</ul>
</li>
<li>请问加header 和 加parameter 的区别是什么<ul>
<li>一般验证信息，身份信息会放在 header 里。其他的普通参数放在 parameter 里。</li>
</ul>
</li>
<li>是否header里面的参数是加密的 而url parameter没有加密？<ul>
<li>是可以的，比如在Post/Put/Del的Rest Method中就是在message header中存放加密的Authentication信息（即token内容），在url的参数则是具体操作对象的id值等path variable。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="News-Feed-API"><a href="#News-Feed-API" class="headerlink" title="News Feed API"></a>News Feed API</h2><h3 id="Req-amp-Res"><a href="#Req-amp-Res" class="headerlink" title="Req &amp; Res"></a>Req &amp; Res</h3><blockquote>
<ul>
<li>JSON 和XML 是两种格式。HTTP URL 里的路径不对应文件夹。URL和文件 path 是不同的概念。文件path的是对应有 folder 才行，url 可以随意指定，不一定要有真实的 folder 或者文件与之对应。同一份数据是不需要存两份的，一般都是存在数据库的表单里，如果你需要 JSON 的格式，就组织成 JSON 的格式返回，如果需要 XML 就组织成 XML 的格式返回。</li>
</ul>
</blockquote>
<h3 id="Pagination"><a href="#Pagination" class="headerlink" title="Pagination"></a>Pagination</h3><blockquote>
<ul>
<li><h5 id="单选题-哪种分页方法更加适合-News-Feed？"><a href="#单选题-哪种分页方法更加适合-News-Feed？" class="headerlink" title="[单选题]哪种分页方法更加适合 News Feed？"></a>[单选题]哪种分页方法更加适合 News Feed？</h5><p>A.页码翻页（Page Number）14.95% 选择</p>
<p>B.光标翻页（Cursor）85.05% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong>B</p>
</li>
</ul>
</blockquote>
<p>要注意怎麼去避免空白頁的request</p>
<p>秀出100個的話就拿101個！</p>
<blockquote>
<ul>
<li><p>使用max_id的话，如果用户删除了之前的某一个item，这样不还是会出现第二页出现之前第一页的item吗</p>
<ul>
<li>不会有影响的。比如第一页的帖子是 <code>[10, 9, 8]</code> 第二页是 <code>[7, 6, 5]</code>，用户拿到第一页以后，同时得到的 next page max_id 是 7。即便此时用户删除了 10 这个帖子，依然不影响 通过 max_id = 7 拿到的是 7 6 5。如果用户删除了 7 这个帖子，那拿到的就是 <code>[6, 5, 4]</code> 也是没有问题的。</li>
</ul>
</li>
<li><p>能不能更具体地讲讲光标翻页的实现。举个例子，一共3页，客户端需要传什么数据给后台，首页，中间和末页。</p>
<ul>
<li><p>问：<strong>是不是不管push还是pull模型，如果翻页的话都得pull?</strong><br>翻页是用户主动操作的过程，所以肯定是由client 发给 server，肯定是一个pull的过程。</p>
<p>问：<strong>假设前100条中最早的timestamp是T，就分别请求follow的人在T之前的100条feed，然后再进行合并？</strong><br>答：对</p>
<p>问：<strong>如果恰好有几条feed的timestamp一样该如何处理？</strong><br>答：首先不会有帖子的timestamp一样，timestamp的精度很高的（微秒级别）</p>
<p>通常来说，翻页这个完全可以作为一道单独的系统设计面试题来问你。翻页并不是简单的1-100，101-200这样去翻页。因为当你在翻页的时候，你的news feed可能已经添加了新的 内容，这个时候你再去索引最新的101-200可能和你的1-100就有重叠了。</p>
<p>通常的做法是，拿第101个帖子的timestamp作为下一页的起始位置，也就是说，当用户在看到第一页的前100个帖子的时候，他还有第101个帖子的timestamp信息（隐藏在你看不到的地方），然后你请求下一页的时候，会带上这个timestamp的信息，server端会去数据库里请求 &gt;= timestamp 的前101个帖子，然后也同样把第101个帖子作为下一页的timestamp。这个方法比直接用第100个帖子的timestamp好的地方是，你如果读不到第101个帖子，说明没有下一页了，如果你刚才只有100个帖子的话，用第100个帖子的timestamp的坏处是，你会有一次<code>空翻</code>。</p>
<p>留给你一个思考题：怎么实现往上翻页（刷朋友圈，查看最新的帖子）</p>
<ul>
<li>可以利用和向下翻页类似的方法，用当前第一条feed的时间T去数据库取T之后的feeds。<br>如果是pull模型的话，就去所有follow的人的feed list去取然后merge<br>push的话，去直接去queue里面取时间大于T的就好了</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><h5 id="单选题-如果-Post-存储在-NoSQL-中，没有-Sequential-ID，还可以使用光标翻页法么？"><a href="#单选题-如果-Post-存储在-NoSQL-中，没有-Sequential-ID，还可以使用光标翻页法么？" class="headerlink" title="[单选题]如果 Post 存储在 NoSQL 中，没有 Sequential ID，还可以使用光标翻页法么？"></a>[单选题]如果 Post 存储在 NoSQL 中，没有 Sequential ID，还可以使用光标翻页法么？</h5><p>Sequential ID 是递增的，可以通过 max_id 和 min_id 来筛选。但是如果在 NoSQL 中，ID 是 UUID ，这个是完全无序的字符串，并不是后发的帖子 UUID 就会比先发的帖子 UUID 大。</p>
<p>A.用不了5.06% 选择</p>
<p>B.可以用，用 timestamp 之类的有序信息翻页即可94.94% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong>B</p>
<p><strong>解析:</strong></p>
<p>timestamp 的精度是微妙级别的，是足够的，一个人的朋友圈里有两个人在同一个 timestamp 发了帖子的概率几乎为0。如果你还是担心 timestamp 的精度不够的话，一个简单的办法是 + 一个随机后缀，如 timestamp 取出来到微妙是 <code>1554553786168125</code> 的话，后面填 5 位随机整数如<code>13234</code>，凑成 <code>155455378616812513234</code>。当然存储的时候类型上得是 bigint 了，因为很大。不可以用 float / double 存储，精度不够。</p>
</li>
</ul>
</blockquote>
<h3 id="Mentions"><a href="#Mentions" class="headerlink" title="Mentions"></a>Mentions</h3><p>讓前端拿到時候可以顯示成可以llink的樣式</p>
<blockquote>
<ul>
<li><p>不是说返回的是Json么？这里为什么是HTML？</p>
<ul>
<li><p>总体的数据是 JSON 的，这里的 html 是其中的某个数据的值。比如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"title"</span>: <span class="string">"hello"</span>,</span><br><span class="line">	 <span class="attr">"content"</span>: <span class="string">"&lt;html&gt;hello world&lt;/html&gt;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>mobile的格式是什么样子的？</p>
<ul>
<li><p>API 返回给 mobile 的格式通常就是 JSON 格式，直接只有具体的数据内容。如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"content"</span>: <span class="string">"Thanks to &lt;user username='someone'&gt;hello world&lt;/user&gt;"</span>,</span><br><span class="line">	 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="TinyURL"><a href="#TinyURL" class="headerlink" title="TinyURL"></a>TinyURL</h1><p>eg. bitly.com/, goo.gl/</p>
<h2 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a>Scenario</h2><p>就是創一個post請求，建一個短網址</p>
<p>給了一個301跳轉，讓browser去完成跳轉的動作。</p>
<ul>
<li>長跟短的URL要是一一對應嗎？</li>
</ul>
<blockquote>
<h5 id="单选投票题-Long-Url-和-Short-Url-是否需要一一对应？"><a href="#单选投票题-Long-Url-和-Short-Url-是否需要一一对应？" class="headerlink" title="[单选投票题]Long Url 和 Short Url 是否需要一一对应？"></a>[单选投票题]Long Url 和 Short Url 是否需要一一对应？</h5><p>您选择的答案是B</p>
<p>感谢您参与投票！</p>
<p>A.需要41.63% 选择</p>
<p>B.不需要58.37% 选择</p>
</blockquote>
<blockquote>
<h5 id="单选投票题-Short-Url-长时间不用是否需要释放？"><a href="#单选投票题-Short-Url-长时间不用是否需要释放？" class="headerlink" title="[单选投票题]Short Url 长时间不用是否需要释放？"></a>[单选投票题]Short Url 长时间不用是否需要释放？</h5><p>您选择的答案是B</p>
<p>感谢您参与投票！</p>
<p>A.需要58.08% 选择</p>
<p>B.不需要41.92% 选择</p>
</blockquote>
<p>這兩個是開放的問題</p>
<p>不同的設計有不同的體驗。各有好壞處。</p>
<p>沒釋放出去就存disk，又不占什麼空間，又便宜。</p>
<h2 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h2><p>是否是真需要很多的機器？</p>
<p>ave QPS = 日活跃*每个用户平均请求次数/一天多少秒</p>
<p>系統一般不是特別頻繁</p>
<p>QPS這問題跟Storage都還好。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>就陽春一個而已</p>
<h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><blockquote>
<h5 id="单选题-TinyUrl-用什么类型的数据库比较合适？"><a href="#单选题-TinyUrl-用什么类型的数据库比较合适？" class="headerlink" title="[单选题]TinyUrl 用什么类型的数据库比较合适？"></a>[单选题]TinyUrl 用什么类型的数据库比较合适？</h5><p>A.SQL / 关系型数据库10.37% 选择</p>
<p>B.NoSQL / 非关系型数据库17.76% 选择</p>
<p>C.都可以，取决于算法是什么71.88% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是B</p>
<p><strong>正确答案:</strong>C</p>
<p><strong>解析:</strong></p>
<p>如果你需要用 Auto-increment ID，就用关系型数据库，否则可以用非关系型数据库，操作更简单一些。</p>
</blockquote>
<blockquote>
<ul>
<li>为什么sql比nosql要写的代码少呢？<ul>
<li>因为很多的 web framework，调用 SQL 部分的接口什么的代码都帮你写得很丰富，很多事儿你也都不用管。很多 NoSQL 的调用，包括 Serialization 之类的事情程序员都需要额外的代码去做。所以会长一些。</li>
</ul>
</li>
<li>除了seq id，还有什么方法确保两个不同的longUrl 得到不同的shorturl呢<ul>
<li>还可以随机生成一个 shortUrl 然后用数据库来判断用过没有，用过就再生成一个。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Alg"><a href="#Alg" class="headerlink" title="Alg."></a>Alg.</h2><ul>
<li>HASH –&gt; 再好的也會有conflict; md5本身就有，更不用說基於它再取６位</li>
<li>隨機生成再去DB去重</li>
</ul>
<blockquote>
<h5 id="多选题-下面哪些“码”可能是随机生成-数据库去重的？"><a href="#多选题-下面哪些“码”可能是随机生成-数据库去重的？" class="headerlink" title="[多选题]下面哪些“码”可能是随机生成+数据库去重的？"></a>[多选题]下面哪些“码”可能是随机生成+数据库去重的？</h5><p>A.短信验证码20.86% 选择</p>
<p>B.邮箱激活码21.60% 选择</p>
<p>C.酒店订单确认码28.84% 选择</p>
<p>D.机票订单确认码28.70% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是ABCD</p>
<p><strong>正确答案:</strong>CD</p>
<p><strong>解析:</strong></p>
<p>验证码和激活码没有去重的需求。订单确认码才有去重的需求。</p>
</blockquote>
<p>驗證碼一下就過期了。訂單本身碼很長，所以有確認碼跟客服比較好溝通。</p>
<blockquote>
<ul>
<li><p>sequential id vs. non-sequential id 是怎么用的？ 为什么很重要？</p>
<ul>
<li>sequential id就是关系型数据库中每增加一行系统会自动给这一行数据分配一个自增id，这样可以保证每一行的id递增且不重复。如果id是随机生成的而不是有顺序的那就叫non sequenctial id，一般需要手动生成。</li>
</ul>
</li>
<li><p>随机生成函数是什么？可以具体讲讲么</p>
<ul>
<li><p>比如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;&#39;.join([for i in range(6) random.choice(&quot;ABCDEF&quot;)])</span><br></pre></td></tr></table></figure>

<p>这段python 代码就是一个 for 循环，循环6次，每次从一个字符串里随机挑一个字符出来。这样就随机生成了一个 6位的code。</p>
</li>
</ul>
</li>
<li><p>不是说Hash的冲突概率很小吗?</p>
<ul>
<li>Hash冲突小的前提是，获得的 hashcode 的长度要足够长，一般生产的类似 UUID 这样的 hash 值，好几十位字符串，这样才不会冲突。只有6位字符很容易冲突。</li>
</ul>
</li>
<li><p>算法二除了速度慢外，如要处理并发问题吗，如果需要，如何处理？加锁吗？谢谢</p>
<ul>
<li>不需要做任何代码的修改。不需要加锁。并发没有问题。首先就算并发，两个 process 调用了 Random 函数之后得到的也是不同的随机串，冲突的概率很小。第二，就算有冲突，数据库也会进行加锁保证不会出现2个重复的被插入。第三如果因为 Race Condition 的原因，刚好会向数据库里插入两次一样的 short_key 的话，那么可以设置 short_key 是 unique 的，然后其中一次 fail 掉，报错给用户，用户重试一次即可解决问题。</li>
</ul>
</li>
<li><p>感觉可以随机生成10个candidate 然后batch query。这样就可以最大限度避免DDB read。</p>
<ul>
<li>这样是不对的。相当于你为了解决一个1%的case，降低了 99% 的case的运行效率。</li>
</ul>
</li>
<li><p>database.filter(shortURL)不会很慢么？</p>
<ul>
<li>不会，shortUrl有index。</li>
</ul>
</li>
<li><p>进制转换的方法是如何把longUrl 转换成 shortUrl的呢？</p>
<ul>
<li>将 long url 插入 database, 拿到 auto-increment id (sequential id)</li>
<li>将 id 进制转换得到 shortUrl</li>
</ul>
</li>
<li><p>sequential ID数据类型是整型啊？</p>
<ul>
<li>是的，整数。要不然做不到 sequential。sequential id 又叫做 auto-increment id</li>
</ul>
</li>
<li><p>那如果有人用同样的longUrl要求做shortUrl, 是会每次返回不一样的shortUrl么？</p>
</li>
</ul>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/28/System-Design/9p/2019-03-28-Design%20Data%20Augmentation%20&amp;%20Consistent%20Hash/">System-Design/9p/2019-03-28-Design Data Augmentation &amp; Consistent Hash</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SystemDesign/">SystemDesign</a></span><div class="content"><h1 id="Design-Data-Aug-amp-Consistent-Hash"><a href="#Design-Data-Aug-amp-Consistent-Hash" class="headerlink" title="Design Data Aug. &amp; Consistent Hash"></a>Design Data Aug. &amp; Consistent Hash</h1><h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><ul>
<li>Hash</li>
<li>Consistent Hash</li>
<li>Load Balancer</li>
<li>Rate Limiter</li>
<li>Web Logger</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param key: A string you should hash</span></span><br><span class="line"><span class="string">    @param HASH_SIZE: An integer</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span><span class="params">(self, key, HASH_SIZE)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper_LTE</span><span class="params">(key, HASH_SIZE)</span>:</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(key)):</span><br><span class="line">                <span class="comment"># print(pow(33, len(key)-i))</span></span><br><span class="line">                res += ord(key[i]) * pow(<span class="number">33</span>,len(key)<span class="number">-1</span>-i)</span><br><span class="line">            <span class="comment"># print(res)</span></span><br><span class="line">            <span class="keyword">return</span> res%HASH_SIZE</span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(key, HASH_SIZE)</span>:</span></span><br><span class="line">            </span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(key)):</span><br><span class="line">                <span class="comment"># 同余定理：</span></span><br><span class="line">                <span class="comment"># (a * b ) % MOD = ((a % MOD) * (b % MOD)) % MOD</span></span><br><span class="line">                res = (res*<span class="number">33</span> + ord(key[i]))%HASH_SIZE</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># return res%HASH_SIZE  STILL LTE</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># return helper_LTE(key, HASH_SIZE)</span></span><br><span class="line">        <span class="keyword">return</span> helper(key, HASH_SIZE)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">一般的数据库进行horizontal shard的方法是指，把 id 对 数据库服务器总数 n 取模，然后来得到他在哪台机器上。这种方法的缺点是，当数据继续增加，我们需要增加数据库服务器，将 n 变为 n+1 时，几乎所有的数据都要移动，这就造成了不 consistent。为了减少这种 naive 的 hash方法(%n) 带来的缺陷，出现了一种新的hash算法：一致性哈希的算法——Consistent Hashing。这种算法有很多种实现方式，这里我们来实现一种简单的 Consistent Hashing。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">将 id 对 360 取模，假如一开始有3台机器，那么让3台机器分别负责0~119, 120~239, 240~359 的三个部分。那么模出来是多少，查一下在哪个区间，就去哪台机器。</span></span><br><span class="line"><span class="string">当机器从 n 台变为 n+1 台了以后，我们从n个区间中，找到最大的一个区间，然后一分为二，把一半给第n+1台机器。</span></span><br><span class="line"><span class="string">比如从3台变4台的时候，我们找到了第3个区间0~119是当前最大的一个区间，那么我们把0~119分为0~59和60~119两个部分。0~59仍然给第1台机器，60~119给第4台机器。</span></span><br><span class="line"><span class="string">然后接着从4台变5台，我们找到最大的区间是第3个区间120~239，一分为二之后，变为 120~179, 180~239。</span></span><br><span class="line"><span class="string">假设一开始所有的数据都在一台机器上，请问加到第 n 台机器的时候，区间的分布情况和对应的机器编号分别是多少？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example</span></span><br><span class="line"><span class="string">例1:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输入:</span></span><br><span class="line"><span class="string"> n = 1, </span></span><br><span class="line"><span class="string">输出:</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">  [0,359,1]</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">解释:</span></span><br><span class="line"><span class="string">表示 0~359 属于机器 1.</span></span><br><span class="line"><span class="string">例2:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输入:</span></span><br><span class="line"><span class="string"> n = 2,</span></span><br><span class="line"><span class="string">输出:</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">  [0,179,1],</span></span><br><span class="line"><span class="string">  [180,359,2]</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">解释:</span></span><br><span class="line"><span class="string">表示 0~179 属于机器 1.</span></span><br><span class="line"><span class="string">表示 180~359 属于机器 2.</span></span><br><span class="line"><span class="string">例3:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">输入:</span></span><br><span class="line"><span class="string">n = 3,</span></span><br><span class="line"><span class="string">输出:</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">  [0,89,1]</span></span><br><span class="line"><span class="string">  [90,179,3],</span></span><br><span class="line"><span class="string">  [180,359,2]</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">Clarification</span></span><br><span class="line"><span class="string">如果最大间隔是[x，y]，并且它属于机器id z，当你添加一个id为n的新机器时，你应该将[x，y，z]分成两个区间：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[x，（x + y）/ 2，z]和[（x + y）/ 2 + 1，y，n]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Notice</span></span><br><span class="line"><span class="string">你可以假设 n &lt;= 360. 同时我们约定，当最大区间出现多个时，我们拆分编号较小的那台机器。</span></span><br><span class="line"><span class="string">比如0~119， 120~239区间的大小都是120，但是前一台机器的编号是1，后一台机器的编号是2, 所以我们拆分0~119这个区间。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>



<p>sharding 也可叫 拆分、division</p>
<p>md5 16^32 用在登入密碼加密，有可能有衝突，現在已經已經不怎麼安全啦</p>
<p>SHA512</p>
<p>密碼加鹽</p>
<h2 id="How-to-Scale"><a href="#How-to-Scale" class="headerlink" title="How to Scale"></a>How to Scale</h2><p>就是要Scale Database 的問題，因為DB 要是被訪問多了，會掛。</p>
<p>假如user有1k, Server，DB都OK, 最大的問題是什麼？</p>
<p>它病死了！</p>
<blockquote>
<h5 id="单选题-除了-QPS-承受力的问题以外，还有什么问题是“最主要”需要考虑的？"><a href="#单选题-除了-QPS-承受力的问题以外，还有什么问题是“最主要”需要考虑的？" class="headerlink" title="[单选题]除了 QPS 承受力的问题以外，还有什么问题是“最主要”需要考虑的？"></a>[单选题]除了 QPS 承受力的问题以外，还有什么问题是“最主要”需要考虑的？</h5><p>如果只用一台数据库</p>
<p>A.硬盘大小7.42% 选择</p>
<p>B.CPU 的运算速度8.71% 选择</p>
<p>C.单点失效 Single Point Failure82.66% 选择</p>
<p>D.价格是否昂贵1.21% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是C</p>
<p><strong>正确答案:</strong>C</p>
<p><strong>解析:</strong></p>
<p>硬盘大小，CPU运算速度，价格当然也重要。但是问题最大的还是单点失效，即如果挂了没有其他机器可以马上替代的问题。</p>
</blockquote>
<p>網站不能用=&gt;數據全丟了=&gt;用戶不來啦</p>
<p>Server是無狀態的，是不存用戶的信息的。</p>
<p>如果想增加數據庫的話，我們該怎麼拆分數據？就是Sharding，or partition，此外還要做Replica數據複製。</p>
<p>希望能用機器去拆分掉進來的流量。</p>
<ul>
<li>Sharding<ul>
<li>分攤讀寫流量</li>
<li>不會一個掛就全掛</li>
</ul>
</li>
<li>Replica<ul>
<li>一式三份，兩台近，一台遠</li>
<li>分攤讀請求</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>一般导致数据库挂了的原因是什么？硬盘损坏么？<ul>
<li>也可能运算量太大卡主了</li>
</ul>
</li>
<li>那负责拆分的机器的qps是不是要很大<ul>
<li>因此通常是每台 WebServer 自己根据同样的算法来计算出该去哪一台数据库存取数据，而不是都跑到一个中心节点去。</li>
</ul>
</li>
<li>所以说数据拆分是因为 分担流量，不是因为太多数据一台电脑装不下是吗<ul>
<li>两个都是目的。大部分时候是为了分摊流量。也有因为装不下需要分摊的情况。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Sharding-in-SQL-vs-NoSQL"><a href="#Sharding-in-SQL-vs-NoSQL" class="headerlink" title="Sharding in SQL vs NoSQL"></a>Sharding in SQL vs NoSQL</h2><p>NoSQL多是自己就提供好了</p>
<h3 id="Vertical"><a href="#Vertical" class="headerlink" title="Vertical"></a>Vertical</h3><p>照table的不同類型，粗暴簡單</p>
<p>可以把user不常改的跟常改的分去到兩個不同的 Table，流量就分開了</p>
<h5 id="缺點：可能就是洗菜、切菜就是比較久，煮很快，所以不該都一個人"><a href="#缺點：可能就是洗菜、切菜就是比較久，煮很快，所以不該都一個人" class="headerlink" title="缺點：可能就是洗菜、切菜就是比較久，煮很快，所以不該都一個人"></a>缺點：可能就是洗菜、切菜就是比較久，煮很快，所以不該都一個人</h5><p>[单选题]Vertical Sharding 不能解决什么问题？</p>
<p>A.数据库 table 很多的情况6.64% 选择</p>
<p>B.一个 table 中有很多关联度不大的 columns8.77% 选择</p>
<p>C.一个 table 里存储的内容太大，且 columns 无法再做拆分84.58% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是C</p>
<p><strong>正确答案:</strong>C</p>
<p><strong>解析:</strong></p>
<p>Vertical Sharding 是按照 column / table 来进行的，如果一个表单（table）里存储的内容太多，且 column 数目又无法再拆分，就无法使用 Vertical Sharding 了</p>
<h3 id="Horizontal"><a href="#Horizontal" class="headerlink" title="Horizontal"></a>Horizontal</h3><ul>
<li>新的數據放新的好嗎？<ul>
<li>所有數據被訪問的機率是相等的這個假設是錯的！當然一般是新的被訪問得多。一年前寫的都比較少在過問了。</li>
</ul>
</li>
</ul>
<h5 id="单选题-新数据放新机器，老数据放老机器的问题是什么？"><a href="#单选题-新数据放新机器，老数据放老机器的问题是什么？" class="headerlink" title="[单选题]新数据放新机器，老数据放老机器的问题是什么？"></a>[单选题]新数据放新机器，老数据放老机器的问题是什么？</h5><p>A.数据访问不均匀45.88% 选择</p>
<p>B.数据存储不均匀12.10% 选择</p>
<p>C.取数据时无法确定数据存在哪儿42.02% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是B</p>
<p><strong>正确答案:</strong>A</p>
<p><strong>解析:</strong></p>
<p>根据数据的新旧程度来拆分的话，新数据的访问次数比旧数据的访问次数是要明显多的，会导致数据访问不均匀的问题。<br>这种方法并不会导致存储不均匀，最多只有最新的一台机器的数据相对少一些，其他的机器都还是均匀的。也不会导致不知道数据去哪台机器取，比如根据 id 来拆分，0~99在1号机器，1-199 在2号机器的话，根据 id 可以算出对应的机器是哪个。</p>
<h4 id="模三好嗎？"><a href="#模三好嗎？" class="headerlink" title="模三好嗎？"></a>模三好嗎？</h4><p>買新機器／有機器掛時就要大遷移了、</p>
<ul>
<li>慢，容易􏰀成数据的不一致性</li>
<li>迁移期间，服务器压力增大，容易挂</li>
</ul>
<blockquote>
<h5 id="单选题-理想状况下，3台机器变4台机器，多少数据需要迁移？"><a href="#单选题-理想状况下，3台机器变4台机器，多少数据需要迁移？" class="headerlink" title="[单选题]理想状况下，3台机器变4台机器，多少数据需要迁移？"></a>[单选题]理想状况下，3台机器变4台机器，多少数据需要迁移？</h5><p>A.33.3%15.00% 选择</p>
<p>B.25%65.56% 选择</p>
<p>C.50%2.30% 选择</p>
<p>D.75%17.14% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong>B</p>
<p><strong>解析:</strong></p>
<p>理想状况下，这台新机器存储 1/4 的数据，因此需要移动的数据也是 1/4。</p>
</blockquote>
<p>就是理想下只想移動25%，不要全都移動</p>
<blockquote>
<ul>
<li>对于登入数据，如果按新旧存放，是否还会遇到“C.取数据时无法确定数据存在哪儿”的问题？因为用户名不是sequential的，而用户登入时并不知道自己的id<ul>
<li>yes</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="Consistent-Hash"><a href="#Consistent-Hash" class="headerlink" title="Consistent Hash"></a>Consistent Hash</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">A general database method <span class="keyword">for</span> performing a horizontal shard is to take the id against the total number of database servers n and <span class="keyword">then</span> to find out <span class="built_in">which</span> machine it is on. The downside of this approach is that as the data continues to increase, we need to increase the database server. When n is changed to n+1, almost all of the data has to be moved, <span class="built_in">which</span> is not consistent. In order to reduce the defects caused by this naive<span class="string">'s hash method (%n), a new hash algorithm emerges: Consistent Hashing, Consistent Hashing. There are many ways to implement this algorithm. Here we implement a simple Consistent Hashing.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Take id to 360. If there are 3 machines at the beginning, then let 3 machines be responsible for the three parts of 0~119, 120~239, 240~359. Then, how much is the model, check which zone you are in, and which machine to go to.</span></span><br><span class="line"><span class="string">When the machine changes from n to n+1, we find the largest one from the n intervals, then divide it into two and give half to the n+1th machine.</span></span><br><span class="line"><span class="string">For example, when changing from 3 to 4, we find the third interval 0~119 is the current largest interval, then we divide 0~119 into 0~59 and 60~119. 0~59 is still given to the first machine, 60~119 to the fourth machine.</span></span><br><span class="line"><span class="string">Then change from 4 to 5, we find the largest interval is the third interval 120~239, after splitting into two, it becomes 120~179, 180~239.</span></span><br><span class="line"><span class="string">Suppose all the data is on one machine at the beginning. When adding to the nth machine, what is the distribution of the interval and the corresponding machine number?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example</span></span><br><span class="line"><span class="string">Example 1:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Input:</span></span><br><span class="line"><span class="string"> n = 1, </span></span><br><span class="line"><span class="string">Output:</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">  [0,359,1]</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">Explanation:</span></span><br><span class="line"><span class="string">represent 0~359 belongs to machine 1.</span></span><br><span class="line"><span class="string">Example 2:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Input:</span></span><br><span class="line"><span class="string"> n = 2,</span></span><br><span class="line"><span class="string">Output:</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">  [0,179,1],</span></span><br><span class="line"><span class="string">  [180,359,2]</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">Explanation:</span></span><br><span class="line"><span class="string">represent 0~179 belongs to machine 1.</span></span><br><span class="line"><span class="string">represent 180~359 belongs to machine 2.</span></span><br><span class="line"><span class="string">Example 3:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Input:</span></span><br><span class="line"><span class="string">n = 3,</span></span><br><span class="line"><span class="string">Output:</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">  [0,89,1]</span></span><br><span class="line"><span class="string">  [90,179,3],</span></span><br><span class="line"><span class="string">  [180,359,2]</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">Clarification</span></span><br><span class="line"><span class="string">If the maximal interval is [x, y], and it belongs to machine id z, when you add a new machine with id n, you should divide [x, y, z] into two intervals:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[x, (x + y) / 2, z] and [(x + y) / 2 + 1, y, n]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Notice</span></span><br><span class="line"><span class="string">You can assume n &lt;= 360. At the same time, we agree that when there are multiple occurrences in the maximum interval, we split the machine with the smaller number.</span></span><br><span class="line"><span class="string">For example, the size of 0~119, 120~239 is 120, but the number of the previous machine is 1, and the number of the next machine is 2, so we split the range of 0~119.</span></span><br></pre></td></tr></table></figure>





<p>指的是對於ｎ台或 n+1 台機器時會是一致的</p>
<p>一致性哈希表存在每個server上。</p>
<ul>
<li>如果在相鄰的兩個各自挪一些來<ul>
<li>缺陷：<ul>
<li>仍是會有一台特別load重</li>
<li>遷移時就只有兩個鄰居，他們兩個人特別負載重</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>360这个数值是经验值么？这个数字对于任何数量的机器都合适么？<ul>
<li>360 只是为了让理解一个圆有 360°，比较形象。这个数字当然不是实际的工程中使用的数字。实际使用的数字一般是 2^64 ==&gt; 宇宙爆炸的機率</li>
</ul>
</li>
<li>反正都要用一个表来记录key-&gt;db号码， 为什么还要hash 2^64呢？ 直接把key和机器号码存到表里不行吗？<ul>
<li>没有 Key-&gt;db号码的这张表。通过 key 得到 db 是靠 consistent hashing 这个算法计算出来的，而不是把每个 key 存在哪个 db 都存下来。</li>
</ul>
</li>
</ul>
</blockquote>
<p>讓不同的key的時候的機率是2^64幾乎是宇宙爆炸的機率。</p>
<blockquote>
<h5 id="单选题-机器-D-加入-Consistent-Hash-Ring-以后，应该问谁要数据？"><a href="#单选题-机器-D-加入-Consistent-Hash-Ring-以后，应该问谁要数据？" class="headerlink" title="[单选题]机器 D 加入 Consistent Hash Ring 以后，应该问谁要数据？"></a>[单选题]机器 D 加入 Consistent Hash Ring 以后，应该问谁要数据？</h5><p>A.机器 A78.58% 选择</p>
<p>B.机器 B6.53% 选择</p>
<p>C.机器 C14.89% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是C</p>
<p><strong>正确答案:</strong>A</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdcduksozaj30og0jatfy.jpg" alt="image-20200330234246254" style="zoom:67%;" />
</blockquote>
<p>Virtual node</p>
<p>理想新加入的機器的「分身」可以去均勻占到不同的前ｎ台機器的分身。如一台切成1000個，理想就是其他的10台，每台可以分到100個我的分身。</p>
<blockquote>
<h5 id="单选题-找比某个数大的最小值可以用什么数据结构？"><a href="#单选题-找比某个数大的最小值可以用什么数据结构？" class="headerlink" title="[单选题]找比某个数大的最小值可以用什么数据结构？"></a>[单选题]找比某个数大的最小值可以用什么数据结构？</h5><p>A.堆 Heap24.45% 选择</p>
<p>B.红黑树 Red-black Tree(Balanced Binary Search Tree)65.64% 选择</p>
<p>C.哈希表 HashMap2.45% 选择</p>
<p>D.链表 Linked List7.45% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong>B</p>
<p><strong>解析:</strong></p>
<p>Heap 只能找全局最大最小。</p>
</blockquote>
<p>要增刪查改還是用Binary Search Tree, 可快速找到比某數大的最小數。</p>
<p>從順時間碰到的node的真實機器作遷移</p>
<blockquote>
<ul>
<li>key如何设计才能保证hash算出来几乎均匀分布在0到2的64次方这么大的范围？<ul>
<li>选择一个好的哈希函数就行了，比如： MurmurHash, xxHash, MetroHash or SipHash1–3</li>
</ul>
</li>
<li>问题同上面的同学：怎么保持key均匀分布？<ul>
<li>选择一个好的哈希函数是可以保证这个性质的。<a href="https://en.wikipedia.org/wiki/Hash_function#Uniformity" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hash_function#Uniformity</a></li>
</ul>
</li>
<li>这个哈希算法是用来做数据库horizontal sharding的吗，它能用在分配服务器上吗？能用在vertical sharding上吗？<ul>
<li>是的，用来做 <strong>Horizontal Sharding</strong>。不能用在 Veritical Sharding 上。Vertical Sharding 是按照 column / table 进行 sharding 并不按照数据本身的值来进行 sharding。他可以用在分配数据服务器上，但是不能用在分配 web 服务器上。因为 web 服务器是 stateless 的，不需要固定的去同一个 web server，只需要随机分配即可。</li>
</ul>
</li>
<li>新增加机器时，增加的虚拟的点的位置是随机的么？<ul>
<li>本质上都是根据机器名字 hash 出来的，不能认为是随机的。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="Consistent-HashⅡ"><a href="#Consistent-HashⅡ" class="headerlink" title="Consistent HashⅡ"></a>Consistent HashⅡ</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">描述</span><br><span class="line">在 Consistent Hashing I 中我们介绍了一个比较简单的一致性哈希算法，这个简单的版本有两个缺陷：</span><br><span class="line"></span><br><span class="line">增加一台机器之后，数据全部从其中一台机器过来，这一台机器的读负载过大，对正常的服务会造成影响。</span><br><span class="line">当增加到3台机器的时候，每台服务器的负载量不均衡，为1:1:2。</span><br><span class="line">为了解决这个问题，引入了 micro-shards 的概念，一个更好的算法是这样：</span><br><span class="line"></span><br><span class="line">将 360° 的区间分得更细。从 0~359 变为一个 0 ~ n-1 的区间，将这个区间首尾相接，连成一个圆。</span><br><span class="line">当加入一台新的机器的时候，随机选择在圆周中撒 k 个点，代表这台机器的 k 个 micro-shards。</span><br><span class="line">每个数据在圆周上也对应一个点，这个点通过一个 <span class="built_in">hash</span> <span class="keyword">function</span> 来计算。</span><br><span class="line">一个数据该属于哪台机器负责管理，是按照该数据对应的圆周上的点在圆上顺时针碰到的第一个 micro-shard 点所属的机器来决定。</span><br><span class="line">n 和 k在真实的 NoSQL 数据库中一般是 2^64 和 1000。</span><br><span class="line"></span><br><span class="line">请实现这种引入了 micro-shard 的 consistent hashing 的方法。主要实现如下的三个函数：</span><br><span class="line"></span><br><span class="line">create(int n, int k)</span><br><span class="line">addMachine(int machine_id) // add a new machine, <span class="built_in">return</span> a list of shard ids.</span><br><span class="line">getMachineIdByHashCode(int hashcode) // <span class="built_in">return</span> machine id</span><br></pre></td></tr></table></figure>



<h2 id="Replica"><a href="#Replica" class="headerlink" title="Replica"></a>Replica</h2><blockquote>
<h5 id="多选题-下列关于-Backup-和-Replica-的区别描述正确的有？"><a href="#多选题-下列关于-Backup-和-Replica-的区别描述正确的有？" class="headerlink" title="[多选题]下列关于 Backup 和 Replica 的区别描述正确的有？"></a>[多选题]下列关于 Backup 和 Replica 的区别描述正确的有？</h5><p>A.Backup 一般是周期性的，Replica 是实时的31.83% 选择</p>
<p>B.Backup 一天做一次7.07% 选择</p>
<p>C.Replica 一般一式三份27.59% 选择</p>
<p>D.Backup 可以分摊读请求1.54% 选择</p>
<p>E.Replica 可以分摊读请求29.77% 选择</p>
<p>F.有了 Replica 之后就不需要 Backup 了2.21% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是ACE</p>
<p><strong>正确答案:</strong>ACE</p>
<p><strong>解析:</strong></p>
<p>Backup 一般一天做一次，但是这个完全是因人而异，不是强制的。<br>Backup 存储的是离线数据，无法分摊在线读请求。<br>虽然 Replica 很强大，但是 Backup 也是很有必要的，可以认为是一个双保险。且可以服务于一些离线数据计算，这样不会给在线数据库带来压力。</p>
</blockquote>
<p>雙重保險</p>
<p>不是每種DB都有replica，所以backup還是保險</p>
<p>更穩定，就是發展的先後問題。</p>
<blockquote>
<ul>
<li>replica和backup代价是一样的吗？比如说都需要一台机器？是不是说replica的机器可能性能好一点，而backup对机器性能没有要求<ul>
<li>有的。你说的方式就是很多 NoSQL 现在用的方式，选择一个 Replica 写进去，然后这个 Replica 负责同步给其他的 Replica。 Replica 之间的地位是等价的，没有 master-slave 的上下级之分。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="SQL-用-Master-vs-Slave"><a href="#SQL-用-Master-vs-Slave" class="headerlink" title="SQL - 用 Master vs Slave,"></a>SQL - 用 Master vs Slave,</h3><ul>
<li>也可手動作 Consistent Hash Ring</li>
</ul>
<h4 id="Write-Ahead-Log"><a href="#Write-Ahead-Log" class="headerlink" title="Write Ahead Log"></a>Write Ahead Log</h4><p>就只會一直追加</p>
<p>所以slave上讀會比較慢</p>
<ul>
<li><p>Master 掛了時要是Slave還沒拉過去，雖然Slave被升級成了Master，但data還是就不見了。</p>
</li>
<li><p>也要根據這個支持把 transaction 反向。</p>
</li>
</ul>
<blockquote>
<ul>
<li>How to do consistent hashing for a web server? For DB, the web server can compute the hashcode and then choose DB. Which component to do this for Web Server? DNS? NGIX?<ul>
<li>Web Server 是不需要做 Consistent Hashing 的。因为 Web Server 是 stateless 的，你不需要保证每个用户每次访问的都是同一个 Web Server，随机来一个 Server 服务他就可以了，就跟你去银行不一定每次都去一个窗口排队，哪个人少去哪个排队就可以了。只有 DB 才需要做 Consistent Hashing 因为你的钱如果存在工商银行你去建设银行是取不到钱的。 Web Server 只需要做 Load Balancing ，这个步骤是 NGINX 或者专门的 Load Balancing 的硬件 或者 AWS 的 Load Balanacing 服务负责做的。</li>
</ul>
</li>
<li>replica和backup代价是一样的吗？比如说都需要一台机器？是不是说replica的机器可能性能好一点，而backup对机器性能没有要求<ul>
<li>代价不一样。replica 要实时，而且要服务在线请求，要求是比较高的。backup 只是做一下存储备份，不服务用户，要求比较低。</li>
</ul>
</li>
<li>replica方法除了master slave，还有别的方法吗，比如说所有服务器都是master，都能接受写操作，隔一段时间同步一次<ul>
<li>有的。你说的方式就是很多 NoSQL 现在用的方式，选择一个 Replica 写进去，然后这个 Replica 负责同步给其他的 Replica。 Replica 之间的地位是等价的，没有 master-slave 的上下级之分。</li>
</ul>
</li>
<li>“下列关于 Backup 和 Replica 的区别描述正确的有？” 为什么replica一般一式三份？<ul>
<li>經驗值</li>
</ul>
</li>
<li>Replica在一致性哈希环上顺时针存三份我理解的是紧挨着的3个位置，对吗？这样读请求来的时候可以分摊给这3个机器吗？<ul>
<li>对的。读请求可以分摊给replica。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Ex-1-Sharding-User-Table"><a href="#Ex-1-Sharding-User-Table" class="headerlink" title="Ex.1 Sharding User Table"></a>Ex.1 Sharding User Table</h2><ul>
<li><p>某個數據庫如按哪個key, Column去sharding好？</p>
<p>User Table怎麼算sharding 好？</p>
<p>就是說要拿什麼去跑一次consistent hash去得到機器的編號，然後連上那台機器，然後去那台機器拿出數據呢？</p>
<ul>
<li><p>怎麼取數據就怎麼拆數據</p>
<p>就是看最常見是按什麼去查呢？就把這個拆開去作sharding吧。</p>
<p>舉例：user_id是最常被其他的表單用到的foreign_key，就用它作拆分</p>
<ul>
<li>但一般都是用username找用戶啊？<ul>
<li>就再建個表單作username =&gt; user_id映射，多查一個步驟就好。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Insert時怎辦？該去哪台數據庫作insert呢？</p>
<ul>
<li>同一台機器時可以設sequential id，就是有另張表紀錄這張表的sequential id到了哪了，然後會加鎖去保持連續性。</li>
<li>這時可以自己自建一個uuid作為用戶的user_id,  不同人不會撞啦！因為是uuid，宇宙爆炸的機率<ul>
<li>然後再拿去作consistent hashing</li>
</ul>
</li>
<li>擴機器時怎辦？uuid是字串，本來人少時是用整數呀，怎辦？<ul>
<li>建個表，在一個新的service裡（這個可以全局共享），就是要先去那個表查，那個表在查時會加鎖，再map到uuid。<ul>
<li>也就是說用加鎖保證數據的原子性。</li>
<li>創建用戶也不是大QPS，所以問題也不是特大。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="单选题-User-Table-最常见的需求是按照什么去查询？"><a href="#单选题-User-Table-最常见的需求是按照什么去查询？" class="headerlink" title="[单选题]User Table 最常见的需求是按照什么去查询？"></a>[单选题]User Table 最常见的需求是按照什么去查询？</h5><p>A.username21.85% 选择</p>
<p>B.id (user_id)76.69% 选择</p>
<p>C.phone number0.09% 选择</p>
<p>D.email1.37% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是A</p>
<p><strong>正确答案:</strong>B</p>
<p><strong>解析:</strong></p>
<p>user_id 会作为其他 Table 的 Foreign key 存在，所以是最频繁的查询需求。</p>
</blockquote>
<blockquote>
<ul>
<li>这个新的表单存储username, userid, 这个不需要sharding对吧？ 因为读取比较少？<ul>
<li>如果读取比较少的情况下，不 sharding 也没问题。不过一般这类 Key-value 的查询都会放在 NoSQL 数据库里，默认就会 sharding。</li>
</ul>
</li>
<li>好像可以用当前时间加其他的限制条件来创建ID，这样可以让ID有其他的信息，这样好么？<ul>
<li>这样做也是可以的，相当于denormalization，但是有一定风险，要注意保持id的随机性，否则可能会让id的生成变得predictable。</li>
</ul>
</li>
<li>如果table QPS需求大的话，而且已经采用了自增id，是不是就不用自增id， 创建一个新table， 用uuid来做key， 然后把原有数据移植到新的table？ 然后更新其他 引用它的table的foreign key？<ul>
<li>更新 foreign key 是一个很大的工程（引用太多了。而且随时可能更改）。所以最后一点说的是，创立一个单独的 UserIdService 来负责产生这个全局自增的 user_id。更新 foreign key 这个并不现实。</li>
</ul>
</li>
<li>可以通过hash把原来的id改成uuid吗<ul>
<li>uuid是有标准的生成方式的，不能仅仅通过求Hash的方式来获得uuid: <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Versions" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Universally_unique_identifier#Versions</a></li>
</ul>
</li>
<li>这个UserIdservice是不是一种分布式锁啊？<ul>
<li>原理有些类似，但是这个还算不上一个general-purpose的分布式锁，只是在系统中设计了一个单点来保证生成ID的顺序和唯一性。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Session-Table-Sharding"><a href="#Session-Table-Sharding" class="headerlink" title="Session Table Sharding"></a>Session Table Sharding</h2><blockquote>
<h5 id="单选题-Session-Table-通常按照哪一项去查询？"><a href="#单选题-Session-Table-通常按照哪一项去查询？" class="headerlink" title="[单选题]Session Table 通常按照哪一项去查询？"></a>[单选题]Session Table 通常按照哪一项去查询？</h5><p>A.session key (session token)84.15% 选择</p>
<p>B.user_id14.54% 选择</p>
<p>C.expire_at1.31% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是A</p>
<p><strong>正确答案:</strong>A</p>
</blockquote>
<blockquote>
<ul>
<li>为什么哪一项最常用就要根据哪一项去sharding呢，能详细解释一下吗<ul>
<li>不是哪一项常用就按照哪一项去 sharding，是按照哪一项查询就按照哪一项 sharding。假如一个数据有 col1, col2 两项，按照 col1 sharding 的意思就是，如果两条数据的 col1 相同，就会被分配在同一台机器上。所以当你按照 col1 查询的时候，才能保证在同一台机器上找到这两条数据。如果你查询是按照 col1 来查询，存的时候却按照 col2 来sharding 的话，那么就没法保证 col1 相同的都在同一台机器上，这样 sharding 的意义就没有了，sharding 就是要让你能分摊查询请求到不同的机器，如果你的一次查询需要去所有机器汇总结果的话，这个 sharding 就是失败的 sharding。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="News-Feed-Timeline-Shardings"><a href="#News-Feed-Timeline-Shardings" class="headerlink" title="News Feed / Timeline Shardings"></a>News Feed / Timeline Shardings</h2><blockquote>
<ul>
<li><em>TimeLine table 即 Post Table 刚才课上说到了是以User ID做为sharding key。 我有一个问题：如果我想查 Post 详情的话， 那是不是每次请求都要带上 User ID 才能定位到具体某台机器上。但是基本获取Post 详情的请求都只会带 Post ID而不是 Post ID 和 User ID啊。 求解答~</em><ul>
<li><em>这种情况下，通常的做法是 post_id 里，前缀就带上 user_id。这样可以通过 post_id 得到 user_id。此时 post_id 通常是一个字符串，可以自定义格式。</em></li>
</ul>
</li>
<li><em>news feed一般是会专门存一个table吗？比如我要看我的news feed，是拿我的user id去news feed table里面找，而不是拿我的所有关注user的id去post table里面找然后汇总？那么这个news feed table里面的信息总归是通过去post table里面查找汇总好了以后存在news feed table里的吧？可不可以介绍一下： 1. 这个table的schema。 2. 去post table查找和汇总发生在什么时候？</em><ul>
<li><em>news feed 一般就是一个专门的 table。</em><br><em>news feed table 的 schema 在 PPT 里有，你看一下。视频里也有讲到的。</em><br><em>去 post table 里查找和汇总可能不会发生，因为 news feed table 可以通过 denormalize 的方法把 post 的内容复制一份存在 news feed table 里来加速这个查询过程。</em></li>
</ul>
</li>
</ul>
</blockquote>
<p>Ref:</p>
<ol>
<li><a href="https://afghl.github.io/2016/07/04/consistent-hashing.html" target="_blank" rel="noopener">https://afghl.github.io/2016/07/04/consistent-hashing.html</a></li>
<li><a href="http://blog.codinglabs.org/articles/consistent-hashing.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/consistent-hashing.html</a></li>
</ol>
<h2 id="leetcode可能怎麼sharding"><a href="#leetcode可能怎麼sharding" class="headerlink" title="leetcode可能怎麼sharding?"></a>leetcode可能怎麼sharding?</h2><p>submission, user, timestamp, problem, status</p>
<blockquote>
<h5 id="单选题-LintCode-Submission-Table-按照什么进行-Sharding？"><a href="#单选题-LintCode-Submission-Table-按照什么进行-Sharding？" class="headerlink" title="[单选题]LintCode Submission Table 按照什么进行 Sharding？"></a>[单选题]LintCode Submission Table 按照什么进行 Sharding？</h5><p>A.user_id13.52% 选择</p>
<p>B.submission_id19.07% 选择</p>
<p>C.problem_id4.17% 选择</p>
<p>D.status0.28% 选择</p>
<p>E.用两个表单，分别按照 user_id 和 problem_id 来 sharding62.96% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是E</p>
<p><strong>正确答案:</strong>E</p>
</blockquote>
<p>需求１我們要查詢某個題的所有提交紀錄</p>
<p>Where problem_id = 999;</p>
<p>需求２我們要查詢某個人的所有提交紀錄</p>
<p>Where user_id = 999;</p>
<p>如果按user_id作sharding時，那當被查詢需求１時，就要去每台機器都拿過來，這樣效率就低。</p>
<p>NoSQL一般可Sharding, 也就比較不支持multi-index。麻煩。</p>
<p>用於篩選的info可以存兩份。</p>
<blockquote>
<ul>
<li>可以把code存在一个单独的table里面然后让两个表都去reference一个code id。当然也可以把code冗余地存在两个表中。前一种方法省空间，但是需要读两次数据库，后一种方法浪费一点空间但是只需要读一次数据库。</li>
</ul>
</blockquote>
<h2 id="Rate-Limiter"><a href="#Rate-Limiter" class="headerlink" title="Rate Limiter"></a>Rate Limiter</h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdgxpdr0mpj31ci0lae0x.jpg" alt="image-20200403221207316"></p>
<p>主要滿足大多人的滿意度、別有惡劣的影響</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdgxvl4bxej31f00kmq6n.jpg" alt="image-20200403221757444"></p>
<blockquote>
<ul>
<li>key,你这个event+feature+ts，无法区分是谁，哪个用户来的req啊？你如何block恶意的点击呢？<ul>
<li>这里举的只是一个简单的例子，实际中feature里面除了ip也可以包含user id之类的信息，你可以根据自己的需要去扩展。</li>
</ul>
</li>
<li>memcahed是一个字典还是一个自定义的类？<ul>
<li>memcached是一个内存型key-value数据库，你可以把它当作字典用。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdgxy3he6jj31100js4k6.jpg" alt="image-20200403222029916"></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/41/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/41/">41</a><span class="page-number current">42</span><a class="page-number" href="/page/43/">43</a><span class="space">&hellip;</span><a class="page-number" href="/page/51/">51</a><a class="extend next" rel="next" href="/page/43/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Joe Huang</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>