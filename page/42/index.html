<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Joe Huang"><meta name="copyright" content="Joe Huang"><title>Awaken Desparado</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Joe Huang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">253</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">36</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Awaken Desparado</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Awaken Desparado</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/25/FFmpeg/2019-06-25-ffmpeg-cmds/">ffmpeg_cmds!</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ffmpeg/">ffmpeg</a></span><div class="content"><h2 id="rm-black-sides"><a href="#rm-black-sides" class="headerlink" title="rm black sides"></a>rm black sides</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">╰─○ ffplay -i vn_hflip.mp4 -t 5 -vf cropdetect</span><br><span class="line">╰─○ ffplay -i vn_hflip.mp4 -t 5 -vf crop=1280:528:0:96</span><br></pre></td></tr></table></figure>

<h2 id="save-to-json"><a href="#save-to-json" class="headerlink" title="save to json"></a>save to json</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -hide_banner -print_format json -show_streams -i vn_hflip.mp4 &gt; vn_json_streams.log</span><br></pre></td></tr></table></figure>

<h2 id="check-error"><a href="#check-error" class="headerlink" title="check error"></a>check error</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_frames vn_hflip.mp4 &gt; vn_show_frames.log</span><br></pre></td></tr></table></figure>

<h2 id="video-to-pics"><a href="#video-to-pics" class="headerlink" title="video to pics"></a>video to pics</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i vn_hflip.mp4 -r 40 -f image2         -t 1 my%d.jpg        <span class="comment">## 跟下一行比會多了幾張重覆的，因為比來的video就25fps而已</span></span><br><span class="line"><span class="string">""</span><span class="string">"2938"</span><span class="string">""</span>  ffmpeg -i vn_hflip.mp4 -r 25 -f image2 -t 1 my25_%d.jpg <span class="comment">## 跟上一行几乎一样，就是正常的25 rate</span></span><br><span class="line">ffmpeg -i vn_hflip.mp4 -vcodec mjpeg -ss 0:0:2 -t 0:0:1 0m%04d.jpg  <span class="comment">## 跟上面比主要就是从第二秒开始</span></span><br><span class="line"></span><br><span class="line">2937  ffmpeg -i vn_hflip.mp4 -r 40 -f image2 -t 1 my25_%d.jpg</span><br><span class="line">★★★ -r, -ss, -t  本来的video要变成的rate，开始、抓多久</span><br><span class="line"></span><br><span class="line">ffmpeg -i vn_hflip.mp4 -ss 00:00:14.435 -vframes 1 out.png</span><br><span class="line">★★★ -vframes 抓几张</span><br></pre></td></tr></table></figure>

<h2 id="pics-to-video"><a href="#pics-to-video" class="headerlink" title="pics to video"></a>pics to video</h2><p>把多个图像文件使用h264编码封装成avi文件，如有my0.jpg, my1.jpg … my99.jpg</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i my%d.jpg  -vcodec h264 my.avi</span><br></pre></td></tr></table></figure>



<p>-r 选项的用法：</p>
<p>预设是</p>
<p>以25FPS读入所有图片，所以len(Images[])会是输出的video的duration. </p>
<p>作出25FPS的video, 所以如果 -r加在 output前面，会进行插帧、删帧。</p>
<p>如果-r加在 input前面，就是每秒读进来几张图片</p>
<p>如果　ffmpeg -r 10 -i z-%5d.jpeg -vcodec h264 -r 60 out10in60out.mp4</p>
<p>那么因为每秒读进来10张而已，硬做成60fps的video，也是没用，因为中间只是内插成了60fps</p>
<h2 id="video-to-gif"><a href="#video-to-gif" class="headerlink" title="video to gif"></a>video to gif</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i vn_hflip.mp4 -ss 0 -r 1 -vframes 6 vn.gif</span><br><span class="line">ffmpeg -i vn_hflip.mp4 -ss 0 -vf fps=1 -vframes 6 vn_fps.gif <span class="comment"># 这个似乎比上面的好一些</span></span><br></pre></td></tr></table></figure>




<p>##EXTRACTION !!!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 2999  ffmpeg -i ../vn_hflip.mp4 -ss 00:00:00 -t 10 -vf fps=1 fps1_%d.png</span><br><span class="line">(joe_py36) ┌─[joe@JoeMBP2] - [~/Movies/exp/tmp] - [3003]</span><br><span class="line">└─[$] <span class="built_in">history</span> | grep r1                                                                                                                                                                           [22:06:04]</span><br><span class="line"> 2975  ffmpeg -i ../vn_hflip.mp4 -r 1 r1_%d.png</span><br><span class="line"> 2977  ffmpeg -i ../vn_hflip.mp4 -r 1 -vframes 6 r1_vframes_%d.png</span><br></pre></td></tr></table></figure>







<h2 id="add-logo"><a href="#add-logo" class="headerlink" title="add logo"></a>add logo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i vn_hflip.mp4 -i ~/Pictures/Sackboy_0.jpeg -filter_complex overlay=W-w:H-h vn_logo.avi</span><br><span class="line">    如右下角: ffmpeg -i God.rm -i logo.png -filter_complex overlay=W-w:H-h my.avi</span><br><span class="line">    如居中:  ffmpeg -i God.rm -i logo.png -filter_complex overlay=W/2-w/2:H/2-h/2 my.avi</span><br></pre></td></tr></table></figure>



</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/07/Web/2019-06-07-Requests'%20secret:%20pool_connections%20and%20pool_maxsize/">Web/2019-06-07-Requests' secret: pool_connections and pool_maxsize</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/">Web</a></span><div class="content"><p>from: <a href="https://www.cnblogs.com/pengyusong/p/5802929.html" target="_blank" rel="noopener">https://www.cnblogs.com/pengyusong/p/5802929.html</a></p>
<p>and <a href="https://laike9m.com/blog/requests-secret-pool_connections-and-pool_maxsize,89/" target="_blank" rel="noopener">https://laike9m.com/blog/requests-secret-pool_connections-and-pool_maxsize,89/</a></p>
<h1 id="Requests’-secret-pool-connections-and-pool-maxsize"><a href="#Requests’-secret-pool-connections-and-pool-maxsize" class="headerlink" title="Requests’ secret: pool_connections and pool_maxsize"></a><strong>Requests’ secret: pool_connections and pool_maxsize</strong></h1><p><a href="http://docs.python-requests.org/en/latest/" target="_blank" rel="noopener">Requests</a> 是一个python开发者众所周知的第三方库。因其简单的API和高性能，大多数人倾向于使用requests而不是urllib2作为访问http的标准库。然而很多使用requests库的人可能不知道内部原因，今天我就来解释以下俩个概念: <code>pool_connections</code> 和<code>pool_maxsize</code>.</p>
<p>从 <code>Session 开始</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">'https://www.google.com'</span>)</span><br></pre></td></tr></table></figure>

<p>这很简单，你可能知道requests’ <code>Session</code> 持有cookie. 但你知道 <code>Session</code> 有一个 <a href="http://docs.python-requests.org/en/latest/api/#requests.Session.mount" target="_blank" rel="noopener"><code>mount</code></a> 方法吗?</p>
<blockquote>
<p><code>mount(prefix, adapter)</code><br>Registers a connection adapter to a prefix.<br>Adapters are sorted in descending order by key length.</p>
</blockquote>
<p>不知道？很好，实际上你已经使用了这个方法当你初始化一个session对象时:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span><span class="params">(SessionRedirectMixin)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Default connection adapters.</span></span><br><span class="line">        self.adapters = OrderedDict()</span><br><span class="line">        self.mount(<span class="string">'https://'</span>, HTTPAdapter())</span><br><span class="line">        self.mount(<span class="string">'http://'</span>, HTTPAdapter())</span><br></pre></td></tr></table></figure>

<p>现在，到了有趣的部分。如果你阅读过 Ian Cordasco’s 文章 <a href="http://www.coglib.com/~icordasc/blog/2014/12/retries-in-requests.html" target="_blank" rel="noopener">Retries in Requests</a>, 你应该知道 <code>HTTPAdapter</code> 可以提供重试功能. 但一个 <code>HTTPAdapter</code> 真实是什么? Quoted from <a href="http://docs.python-requests.org/en/latest/api/#requests.adapters.HTTPAdapter" target="_blank" rel="noopener">doc</a>:</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">requests</span>.<span class="title">adapters</span>.<span class="title">HTTPAdapter</span><span class="params">(pool_connections=<span class="number">10</span>, pool_maxsize=<span class="number">10</span>, max_retries=<span class="number">0</span>, pool_block=False)</span></span></span><br></pre></td></tr></table></figure>

<p>The built-in HTTP Adapter for urllib3.</p>
<p>Provides a general-case interface for Requests sessions to contact HTTP and HTTPS urls by implementing the Transport Adapter interface. This class will usually be created by the Session class under the covers.</p>
<p>Parameters:</p>
<ul>
<li><code>pool_connections</code> – The number of urllib3 connection pools to cache.</li>
<li><code>pool_maxsize</code> – The maximum number of connections to save in the pool.</li>
<li><code>max_retries(int)</code> – The maximum number of retries each connection should attempt. Note, this applies only to failed DNS lookups, socket connections and connection timeouts, never to requests where data has made it to the server. By default, Requests does not retry failed connections. If you need granular control over the conditions under which we retry a request, import urllib3’s Retry class and pass that instead.</li>
<li><code>pool_block</code> – Whether the connection pool should block for connections. Usage:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="keyword">import</span> requests</span><br><span class="line">&gt;&gt; s = requests.Session()</span><br><span class="line">&gt;&gt; a = requests.adapters.HTTPAdapter(max_retries=<span class="number">3</span>)</span><br><span class="line">&gt;&gt; s.mount(<span class="string">'http://'</span>, a)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果上面的文档使你迷惑，这里是我的解释: HTTP Adapter 所做的就是：根据不同的目标url，对每个不同的请求提供不同的配置，还记得上面的代码吗？</p>
<p>　　　　what HTTP Adapter does is simply <strong>providing different configurations for different requests according to target url</strong>. Remember the code above?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.mount(<span class="string">'https://'</span>, HTTPAdapter())</span><br><span class="line">self.mount(<span class="string">'http://'</span>, HTTPAdapter())</span><br></pre></td></tr></table></figure>

<p>它创建了俩个 <code>HTTPAdapter</code> 对象使用默认的参数：<code>pool_connections=10, pool_maxsize=10, max_retries=0, pool_block=False</code>, 并且挂载到 <code>https://</code> 和 <code>http:// 相对路径</code>, 意思是第一个配置在你访问 <code>http://xxx 会使用到， 第二个会在你访问 ``https://xxx</code>. 尽管上面俩个配置是相同的，请求http和https仍然是隔离的。我们会在下面看到说明。</p>
<p>就像我说的，这篇文章的目的主要是解释 <code>pool_connections</code> and <code>pool_maxsize</code>.</p>
<p>首先，让我们看看 <code>pool_connections</code>. 昨天我在stackoverflow提出了一个问题：<a href="http://stackoverflow.com/questions/34837026/whats-the-meaning-of-pool-connections-in-requests-adapters-httpadapter" target="_blank" rel="noopener">question</a> ，因为我不确定我是否理解正确，这个问题的回答消除了我的不确定性。HTTP，众所周知，是基于TCP协议，一个HTTP连接也是一个TCP连接，它是由一个五元组唯一标识:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;protocol&gt;, &lt;src addr&gt;, &lt;src port&gt;, &lt;dest addr&gt;, &lt;dest port&gt;)</span><br></pre></td></tr></table></figure>

<p>就是说，你针对 <code>www.example.com 建立了一个HTTP/TCP连接</code>, 假设服务器支持 <code>Keep-Alive</code>, 下一次你发送请求到 <code>www.example.com/a</code> or <code>www.example.com/b</code>, 你可以使用相同的连接，因为五元组没有改变. 实际上, <a href="http://docs.python-requests.org/en/latest/user/advanced/#keep-alive" target="_blank" rel="noopener">requests’ Session 自动会帮你处理</a> 并且重用连接，只要它能.</p>
<p>这个问题是，什么决定了你是否可以重用老的连接？是的，就是 <code>pool_connections</code>!</p>
<blockquote>
<p>pool_connections – The number of urllib3 connection pools to cache.</p>
</blockquote>
<p>我知道，我知道，我也不想引入很多术语, 这是最后一个，我发誓. 简单的理解它， 一个host对应的一个连接池：<strong>one connection pool corresponds to one host</strong>, 嗯，就是这个意思.</p>
<p>这是一个例子，无关的行已被忽略:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.mount(<span class="string">'https://'</span>, HTTPAdapter(pool_connections=1))</span><br><span class="line">s.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">s.get(<span class="string">'https://www.zhihu.com'</span>)</span><br><span class="line">s.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">"output</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.baidu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 None</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.zhihu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 2621</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.baidu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 None</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>

<p><code>HTTPAdapter(pool_connections=1)</code> 被映射到 <code>https://</code>, 他意思是在同一时间仅有一个连接池. 在调用 <code>s.get(&#39;https://www.baidu.com&#39;)</code>, 缓存的连接池是 <code>connectionpool(&#39;https://www.baidu.com&#39;)</code>. 现在 <code>s.get(&#39;https://www.zhihu.com&#39;)</code> 来了，这个session发现他不能使用缓存的连接，因为他不是相同的host(one connection pool corresponds to one host, remember?). 因此session不得不创建一个新的连接池. 因为 <code>pool_connections=1</code>, session不能在同一时间持有俩个连接池, 因此他丢弃了旧的连接池： <code>connectionpool(&#39;https://www.baidu.com&#39;)</code> 并且保存了新的：<code>connectionpool(&#39;https://www.zhihu.com&#39;)</code>. 下一次get同样如此Next <code>get</code> is the same. 这就是我们看见三个 <code>Starting new HTTPS connection</code> 日志行的原因</p>
<p>如果我们设置 <code>pool_connections</code> 为 2:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.mount(<span class="string">'https://'</span>, HTTPAdapter(pool_connections=2))</span><br><span class="line">s.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">s.get(<span class="string">'https://www.zhihu.com'</span>)</span><br><span class="line">s.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="string">""</span><span class="string">"output</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.baidu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 None</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.zhihu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 2623</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 None</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>很好，现在我们可以创建连接俩次了并且保持连接活跃</p>
<p>最后, <code>pool_maxsize</code>.</p>
<p>首先, 仅当你在多线程环境下使用session，你才应该关心 <code>pool_maxsize</code> , 例如，从多个线程使用同一个session发出并发请求.</p>
<p>实际上，<code>pool_maxsize</code> 是一个用来初始化urllib3’s <code>HTTPConnectionPool的参数</code>, 它才是真正含义上的连接池. <code>HTTPConnectionPool</code> 是一个容器，针对于特定的host保存连接的集合, 且 <code>pool_maxsize</code> 是这个集合的最大值. 如果你运行你的代码在同一个线程，它是不可能针对多个主机创建多个连接的，因为 requests library 是阻塞的, 因此HTTP请求总是一个接着一个发送.</p>
<p>如果使用多线程就会不一样.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def thread_get(url):</span><br><span class="line">    s.get(url)</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">s.mount(<span class="string">'https://'</span>, HTTPAdapter(pool_connections=1, pool_maxsize=2))</span><br><span class="line">t1 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com'</span>,))</span><br><span class="line">t2 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/36612174'</span>,))</span><br><span class="line">t1.start();t2.start()</span><br><span class="line">t1.join();t2.join()</span><br><span class="line">t3 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/39420364'</span>,))</span><br><span class="line">t4 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/21362402'</span>,))</span><br><span class="line">t3.start();t4.start()</span><br><span class="line"><span class="string">""</span><span class="string">"output</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.zhihu.com</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (2): www.zhihu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/36612174 HTTP/1.1<span class="string">" 200 21906</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 2606</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/21362402 HTTP/1.1<span class="string">" 200 57556</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/39420364 HTTP/1.1<span class="string">" 200 28739</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>看见了吗? 它为相同的host建立了俩个连接： <code>www.zhihu.com</code>, 就像我说的, 这个仅发生在多线程环境下. 在这个例子中，我们创建了一个连接池，使用了参数 <code>pool_maxsize=2</code>, 发现同一时间不会超过俩个连接，因此这是足够的，我们看到<code>t3</code> 和 <code>t4</code> 没有创建新的连接，他们重用了就的连接.</p>
<p>如果没有足够的大小呢?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.mount(<span class="string">'https://'</span>, HTTPAdapter(pool_connections=1, pool_maxsize=1))</span><br><span class="line">t1 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com'</span>,))</span><br><span class="line">t2 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/36612174'</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join();t2.join()</span><br><span class="line">t3 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/39420364'</span>,))</span><br><span class="line">t4 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/21362402'</span>,))</span><br><span class="line">t3.start();t4.start()</span><br><span class="line">t3.join();t4.join()</span><br><span class="line"><span class="string">""</span><span class="string">"output</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.zhihu.com</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (2): www.zhihu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/36612174 HTTP/1.1<span class="string">" 200 21906</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 2606</span></span><br><span class="line"><span class="string">WARNING:requests.packages.urllib3.connectionpool:Connection pool is full, discarding connection: www.zhihu.com</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (3): www.zhihu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/39420364 HTTP/1.1<span class="string">" 200 28739</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/21362402 HTTP/1.1<span class="string">" 200 57556</span></span><br><span class="line"><span class="string">WARNING:requests.packages.urllib3.connectionpool:Connection pool is full, discarding connection: www.zhihu.com</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>现在, <code>pool_maxsize=1</code>，会打印警告日志如下，就像下面的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection pool is full, discarding connection: www.zhihu.com</span><br></pre></td></tr></table></figure>

<p>可以注意到仅有一个连接被保存在连接池中, 为t3或者t4创建一个新的连接. 很明显这是不够的. 这就是为什么在 urllib3’s 文档中说明如下:</p>
<blockquote>
<p>如果你计划在连接池环境下使用一个连接池, 你应该设置连接池最大数量为一个比较高的值，例如和线程的数量相同.</p>
</blockquote>
<p>最后, <code>HTTPAdapter</code> 实例映射到不同的前缀是相互独立的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.mount(<span class="string">'https://'</span>, HTTPAdapter(pool_connections=1, pool_maxsize=2))</span><br><span class="line">s.mount(<span class="string">'https://baidu.com'</span>, HTTPAdapter(pool_connections=1, pool_maxsize=1))</span><br><span class="line">t1 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com'</span>,))</span><br><span class="line">t2 =Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/36612174'</span>,))</span><br><span class="line">t1.start();t2.start()</span><br><span class="line">t1.join();t2.join()</span><br><span class="line">t3 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/39420364'</span>,))</span><br><span class="line">t4 = Thread(target=thread_get, args=(<span class="string">'https://www.zhihu.com/question/21362402'</span>,))</span><br><span class="line">t3.start();t4.start()</span><br><span class="line">t3.join();t4.join()</span><br><span class="line"><span class="string">""</span><span class="string">"output</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (1): www.zhihu.com</span></span><br><span class="line"><span class="string">INFO:requests.packages.urllib3.connectionpool:Starting new HTTPS connection (2): www.zhihu.com</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/36612174 HTTP/1.1<span class="string">" 200 21906</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET / HTTP/1.1<span class="string">" 200 2623</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/39420364 HTTP/1.1<span class="string">" 200 28739</span></span><br><span class="line"><span class="string">DEBUG:requests.packages.urllib3.connectionpool:"</span>GET /question/21362402 HTTP/1.1<span class="string">" 200 57669</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>上面的代码很容易，不需要再次解释了.</p>
<p>就这样了，希望这篇文章帮助你更好的理解requests库. 顺便说一下，我创建了一个gist <a href="https://gist.github.com/laike9m/ead19c65a416c7022c00" target="_blank" rel="noopener">here</a> 这里包含这篇文章的测试代码. 随便下载并尝试吧</p>
<h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><ol>
<li><p>For https, requests uses urllib3’s <a href="http://urllib3.readthedocs.org/en/latest/pools.html#urllib3.connectionpool.HTTPSConnectionPool" target="_blank" rel="noopener">HTTPSConnectionPool</a>, but it’s pretty much the same as HTTPConnectionPool so I didn’t differeniate them in this article.</p>
</li>
<li><p><code>Session</code>‘s <code>mount</code> method ensures the longest prefix gets matched first. Its implementation is pretty interesting so I posted it here.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mount</span><span class="params">(self, prefix, adapter)</span>:</span></span><br><span class="line">    <span class="string">"""Registers a connection adapter to a prefix.</span></span><br><span class="line"><span class="string">    Adapters are sorted in descending order by key length."""</span></span><br><span class="line">    self.adapters[prefix] = adapter</span><br><span class="line">    keys_to_move = [k <span class="keyword">for</span> k <span class="keyword">in</span> self.adapters <span class="keyword">if</span> len(k) &lt; len(prefix)]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys_to_move:</span><br><span class="line">        self.adapters[key] = self.adapters.pop(key)</span><br></pre></td></tr></table></figure>

<p>Note that <code>self.adapters</code> is an <code>OrderedDict</code>.</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/05/03/LC/2019-05-03-Remove-Element/">LC/2019-05-03-Remove-Element</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/LC/">LC</a></span><div class="content"><p>RemoveElement</p>
<p>​</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/09/jupyter-demo/2020-04-09-SNPS%20stock%20prediction/">jupyter-demo/2020-04-09-SNPS stock prediction</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Jupy-Demo/">Jupy-Demo</a></span><div class="content"><iframe>src="https://nbviewer.jupyter.org/github/Joecth/Joecth.github.io/blob/hexo-melody/source/_posts/jupyter-demo/stock_pred_w_RNN/rnn_stock.ipynb" width="100%" height="1000">
</iframe>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/05/System-Design/9p/2019-04-05-Location%20Based%20Service%20Design%20&amp;%20Uber/">System-Design/9p/2019-04-05-Location Based Service Design &amp; Uber</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SystemDesign/">SystemDesign</a></span><div class="content"><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdj89p8x7zj31140fqdpo.jpg" alt="image-20200405214845930"></p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdj8bi4vkpj31180gw105.jpg" alt="image-20200405215030180"></p>
<p>為了減少磁盤磁頭挪動找的次數，二叉的話樹會太高。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdj8czu4cmj30tu0dyjxn.jpg" alt="image-20200405215156714"></p>
<p>唯一：如user_name, email, phone_number</p>
<p>聯合：關手到兩個col的需求要建聯合索合</p>
<p>條件：去篩掉不付錢的，他們的index太大了，我不想查到他們</p>
<p>★聯合索引不能解決分別查 A 的範圍和 B 的範圍然後再求交集這件事情，它是照第一鍵排序後，當第一鍵有相等值的話再照第二鍵去排。然後將查到的id再去原表裡查，也是座標排序法–x不等的照x排序，x相等的按照y排序。</p>
<h1 id="LBS"><a href="#LBS" class="headerlink" title="LBS"></a>LBS</h1><p>Location Based Service</p>
<h2 id="Uber-技術棧"><a href="#Uber-技術棧" class="headerlink" title="Uber 技術棧"></a>Uber 技術棧</h2><p>派單 vs 搶單</p>
<h3 id="派單模式"><a href="#派單模式" class="headerlink" title="派單模式"></a>派單模式</h3><ul>
<li>ringpop ，一種去中心化的架構</li>
<li>Channel, 高效 RPC</li>
<li>Google S2</li>
<li>Riak</li>
</ul>
<h3 id="T-Channel"><a href="#T-Channel" class="headerlink" title="T Channel"></a>T Channel</h3><p>一種RPC(遠程函數調用)協議。怎麼把不同進程間內存作序列化傳輸及反序列化解析。</p>
<p>RPC 服務器之間的，HTTPS話還要對資訊作加密，防用戶端的hacker之類。</p>
<p>如果流量不大的話用 http 也ok, http 比較現成，比較好寫，如果要寫thrift還要定義結構，不如json方便。http相對rpc要慢一些，其實主要是設計為客戶端跟服務器之間的通信，而客戶端問題多，搗亂的人多，需要驗證，要提供放cookie裡的驗證，一下就好幾k到好幾10k，而服務器之間其實可能就只要幾百個字節。</p>
<p>RPC還多了壓縮，讓效率高、延遲低。server2server就放LAN, 也不用加密。不用擔心不合理的傳來的數據。防驗證該是firewall該做的。</p>
<blockquote>
<h5 id="多选题-现有的比较成熟的、广泛使用的RPC协议有哪些？"><a href="#多选题-现有的比较成熟的、广泛使用的RPC协议有哪些？" class="headerlink" title="[多选题]现有的比较成熟的、广泛使用的RPC协议有哪些？"></a>[多选题]现有的比较成熟的、广泛使用的RPC协议有哪些？</h5><p>A.HTTP27.04% 选择</p>
<p>B.Thrift38.66% 选择</p>
<p>C.ProtoBuf34.30% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是AB</p>
<p><strong>正确答案:</strong>ABC</p>
<p><strong>解析:</strong></p>
<p>Thrift 是 Facebook 的，ProtoBuf 是 Google 的。<br>Http 也可以认为是一个 RPC。</p>
</blockquote>
<blockquote>
<h5 id="单选题-生活中运用地最广泛的RPC协议是？"><a href="#单选题-生活中运用地最广泛的RPC协议是？" class="headerlink" title="[单选题]生活中运用地最广泛的RPC协议是？"></a>[单选题]生活中运用地最广泛的RPC协议是？</h5><p>A.HTTP97.39% 选择</p>
<p>B.Thrift1.21% 选择</p>
<p>C.ProtoBuf1.40% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是A</p>
<p><strong>正确答案:</strong>A</p>
<p><strong>解析:</strong></p>
<p>HTTP 是 client （如 Browser) 与 server 通信的协议。是非常典型的 RPC。</p>
</blockquote>
<blockquote>
<ul>
<li>RPC跟REST API有什么不一样<ul>
<li>rest api一般指的是定义好的http 接口，rpc是一种通信协议</li>
</ul>
</li>
<li>Thrift, ProtoBuf和HTTP协议差别在哪里呢？<ul>
<li>差别可多了，比如最主要的差别是 thrift 和protobuf 的通信量相对 http 都很小，速度也就快很多。其他的差别，建议您可以去 Google 一下 thrift 和 protobuf，或者写一下 thrift 的调用代码和http 的调用代码来体会。</li>
</ul>
</li>
<li>RPC跟RESTful API 有什么不同？<ul>
<li>RPC 是一类协议的统称，Restful API 是一种编码规范。<br>Restful API 也是一种 RPC。我们说过 RPC 的时候通常说的意思是“远程调用”，我们说 Restful API 的时候通常指的是 “GET <a href="https://xxx/api/users/&quot;" target="_blank" rel="noopener">https://xxx/api/users/&quot;</a> 之类的 Web API 设计。Web API 当然也是一种“远程调用”</li>
</ul>
</li>
<li>请问 用Flask写的API和用grpc写的API有什么区别？两者对比有什么好处呢<ul>
<li><strong>Flask 之类的 Web Framework 写的 API就是一个 HTTP API。相比于 GRPC 或者 Thrift 之类写的 API 而言，最主要的区别是 HTTP 的 Request 整个数据传输一般比较大，因为要包含 HTTP Header, Cookie 之类的很多东西，其实很多时候用不上。所以 GRPC 之类的会高效不少</strong>。</li>
</ul>
</li>
<li>client make a request to server 是都要用HTTP协议？<ul>
<li>不一定的，也有用其他协议的。只是大部分都用 http，简单方便成熟。</li>
</ul>
</li>
<li>server to server之间的通信的内容什么？不同伺服器上的数据？<ul>
<li>server to server 当然也是有通信的需求的。<strong>比如在Uber设计中，GeoService 里的 server 就存储了地理位置信息，并提供了访问地理位置信息的接口。这个 GeoService 可以服务于 Uber 打车，还可以服务于 Uber 外卖。不同的其他的 server 都可以调用 GeoService 来存取数据，这就是服务器间通信。</strong></li>
</ul>
</li>
<li>RESTful API 是基于http protocol的？<ul>
<li>是的。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Google-S2-amp-Riak"><a href="#Google-S2-amp-Riak" class="headerlink" title="Google S2 &amp; Riak"></a>Google S2 &amp; Riak</h3><h2 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a>Scenario</h2><blockquote>
<h5 id="多选题-对于一个打车软件来说，最核心的两个功能是什么？"><a href="#多选题-对于一个打车软件来说，最核心的两个功能是什么？" class="headerlink" title="[多选题]对于一个打车软件来说，最核心的两个功能是什么？"></a>[多选题]对于一个打车软件来说，最核心的两个功能是什么？</h5><p>A.支付功能10.34% 选择</p>
<p>B.汇报位置34.47% 选择</p>
<p>C.匹配乘客和车辆45.34% 选择</p>
<p>D.评分系统0.31% 选择</p>
<p>E.一键报警0.31% 选择</p>
<p>F.路线导航9.22% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是BC</p>
<p><strong>正确答案:</strong>BC</p>
<p><strong>解析:</strong></p>
<p>支付并不是最重要的，完全可以做一个免费的打车软件，但让司机汇报自己的位置和为乘客匹配一个合适的司机是构成一个打车软件的基本功能。</p>
</blockquote>
<ul>
<li>該可以時不時更新司機位置</li>
<li>為乘客匹配司機</li>
<li>司機同意就繼續完成派單</li>
<li>直接司機告訴服務器自己在哪</li>
</ul>
<p>會發現他一天會有幾單，會橫跨幾個城市，全市</p>
<ul>
<li>有集會時會有大量單，所以透過偷偷蒐集用戶地點，我們可以提前調度司機往那邊跑。</li>
<li>但這理論上是蒐集隱私的行為哈</li>
</ul>
<h2 id="Service-Geo-amp-Dispatch"><a href="#Service-Geo-amp-Dispatch" class="headerlink" title="Service - Geo &amp; Dispatch"></a>Service - Geo &amp; Dispatch</h2><blockquote>
<h5 id="单选题-图中漏了什么？"><a href="#单选题-图中漏了什么？" class="headerlink" title="[单选题]图中漏了什么？"></a>[单选题]图中漏了什么？</h5><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdkglvyl64j30ky0c8ju9.jpg" alt="图片"></p>
<p>A.司机和乘客的双向联系23.16% 选择</p>
<p>B.司机获取到打车订单信息45.00% 选择</p>
<p>C.司机当前接单与否的状态31.84% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是C</p>
<p><strong>正确答案:</strong>B</p>
</blockquote>
<blockquote>
<ul>
<li>Dispatch service 里面包含逻辑处理 + 数据存储。能否解释一下数据储存？这里的数据储存存的是什么数据？是否是司机的地理位置数据？<ul>
<li>地理位置数据可以存在 GeoService 里。Dispatch Service 里存的是派单（Dispatch）信息的数据，比如我把哪个司机分配给了哪个乘客，这个在我们的课程中是存在 Trip Table 里。即用户点击打车就创建了一个 Trip，当分配了一个司机以后，就往里填进去被分配的司机。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Storage-Trip-amp-Location"><a href="#Storage-Trip-amp-Location" class="headerlink" title="Storage - Trip &amp; Location"></a>Storage - Trip &amp; Location</h2><blockquote>
<h5 id="单选题-Trip-Table-的读写情况如何？"><a href="#单选题-Trip-Table-的读写情况如何？" class="headerlink" title="[单选题]Trip Table 的读写情况如何？"></a>[单选题]Trip Table 的读写情况如何？</h5><p>A.读多写少25.16% 选择</p>
<p>B.读少写多36.25% 选择</p>
<p>C.读写一样多38.58% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTQxNzAwNjYyNTQzIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjEwODgiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAwYTUxMiA1MTIgMCAxIDAgMCAxMDI0QTUxMiA1MTIgMCAwIDAgNTEyIDB6IG0xNjUuOTUyIDYzNy43NmwxNS4wNCAxNC45NzZhMjguNDE2IDI4LjQxNiAwIDEgMS00MC4yNTYgNDAuMjU2bC0xNC45NzYtMTUuMDRMNTA5LjUwNCA1NDkuNzYgMzcxLjIgNjg4YTI4LjQxNiAyOC40MTYgMCAxIDEtNDAuMjU2LTQwLjI1NmwxMzguMzA0LTEzOC4yNC0xMjMuMi0xMjMuMi0xNS4xMDQtMTUuMTA0YTI4LjU0NCAyOC41NDQgMCAwIDEgMC00MC4yNTYgMjguNTQ0IDI4LjU0NCAwIDAgMSA0MC4yNTYgMGwxNS4wNCAxNS4xMDRMNTA5LjQ0IDQ2OS4yNDhsMTQzLjIzMi0xNDMuMjk2YTI4LjQxNiAyOC40MTYgMCAxIDEgNDAuMjU2IDQwLjI1Nkw1NDkuNzYgNTA5LjUwNGwxMjguMTkyIDEyOC4yNTZ6IiBmaWxsPSIjRjY1RTVFIiBwLWlkPSIxMDg5Ij48L3BhdGg+PC9zdmc+" alt="img">答错了，您选择的答案是C</p>
<p><strong>正确答案:</strong>A</p>
<p><strong>解析:</strong></p>
<p>只有产生用户请求时才会产生写操作，查询操作比较多，因为每隔四秒司机都会需要查询是否有与之匹配的订单</p>
</blockquote>
<blockquote>
<h5 id="单选题-Location-Table-的读写情况如何？"><a href="#单选题-Location-Table-的读写情况如何？" class="headerlink" title="[单选题]Location Table 的读写情况如何？"></a>[单选题]Location Table 的读写情况如何？</h5><p>A.读多写少8.05% 选择</p>
<p>B.读少写多71.88% 选择</p>
<p>C.读写一样多20.08% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是B</p>
<p><strong>正确答案:</strong>B</p>
<p><strong>解析:</strong></p>
<p>每隔四秒司机的位置都需要被更新，属于写操作；读取操作只有在查找乘客附近的司机时才会发生。</p>
</blockquote>
<blockquote>
<ul>
<li>对这个流程有些疑惑，为什么不等到driver同意pick up之后再往trip里写一个新的record，这样不是可以避免driver反复查询吗<ul>
<li>有很多原因。首先，对那么没有成单的打车请求，也有记录数据和分析数据的需求，不仅仅是记录那些匹配上的单子。其次，当一个打车请求产生一个，我们需要提供给打车的人一个查询主体去让他查询有没有匹配上，因此势必是要创建一个 Record 的。至于这个 Record 是一个 Trip 的 Record 还是一个 PendingRequest 的 Record，这个就看你自己愿意怎么设计了。我是觉得统一都是 Trip ，用 status 来标记不同时期的状态是比较好的做法。</li>
</ul>
</li>
<li>如果app上要显示location的话是要读的吧，所以是不是应该是读写一样多呢<ul>
<li>是的。<br>这是属于另外一个功能点的要实现的service-trip routing service。<br>其实这个系统中的Dispatch Service和Geo Web Server还可以分化出来一个专门复杂计算匹配功能的Matching Service 出来。</li>
</ul>
</li>
<li>请问driver要怎么从trip table查询他有没有被assigned到某个trip? 是对driver_id做 index，让我们可以直接search吗？<ul>
<li>是的，对 driver_id 有 index 就行了。</li>
</ul>
</li>
<li>数据库定义 外键会不会影响性能呢？<ul>
<li>定义外键就必须给该列建立索引，这样可以加快查询时的速度，但是相应地在数据更新的时候会花费一些时间来维护索引。</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="LBS-難點"><a href="#LBS-難點" class="headerlink" title="LBS 難點"></a>LBS 難點</h1><ul>
<li>數據庫不好查圓，改求正方形</li>
</ul>
<blockquote>
<p>课中练习</p>
<p>[单选题]分别对 latitude 和 longitude 建index是否可行？</p>
<p>你的选择:B</p>
<p>A:可行</p>
<p><strong>B:不可行</strong></p>
</blockquote>
<p>那建複合索引ok嗎？就是二元組排序</p>
<p>[单选题]复合索引是否能解决 查询效率低下的问题呢？</p>
<p>A:可以</p>
<p><strong>B:不可以</strong> 仍是不行</p>
<p>要找兩個key都在某個範圍內的range query仍是無法做的，只能找到同lat下的log的範圍。</p>
<p><strong><em>所以，將二維映射到一維做</em></strong></p>
<h2 id="2D-Range-Query"><a href="#2D-Range-Query" class="headerlink" title="2D Range Query"></a>2D Range Query</h2><p>映射到一維的range query，相當於對二維作range query</p>
<ul>
<li>Google S2 –  Hilbert Curve, 一維上近的，二維上的也近；反之否。</li>
<li>Geohash – Peano Curve<ul>
<li>0-9, a-z 去掉 a, i, l, o 為 base32剛好2^5, 因為長相容易看錯，發明算法的人決定去掉這四個char的</li>
<li>find longest-common-prefix</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>所以说Hilbert mapping如果两个点二维空间接近， 一维上不一定接近对吧（比如说最中间的四个点）<ul>
<li>是的。但是反过来是对的，一维越接近，二维就越接近。</li>
</ul>
</li>
<li>Google S2怎么解决障碍物的问题？比如河流，单行线等。<ul>
<li>Google S2不能解决障碍物的问题，障碍物的问题是交给地图解决的。在或取到附近的司机之后，可以过一遍地图，查一下路径，如果不可达或者要绕远路的话可以排除掉。</li>
</ul>
</li>
<li>为什么不直接按地域分，然后在这个地域里直接用for loop算出每个坐标和用户的距离？这个是O(n) 是不是因为 SQL查询是O(logn)所以更快？<ul>
<li>这样就要对每个用户都算一遍距离，n个用户就要对所有坐标算n次，开销很大。而用Geohash就只需要做一个range query就行了，range query一般有索引支持，做起来很快。</li>
</ul>
</li>
<li>对两个column都是range query的情况，如果用复合索引的话，虽然对第二个column是无序的，但是因为第一个的range已经选出来，这时如果delta比较小（range范围小），对于第二个column也只用遍历第一个选出来的部分，相较于加索引的log（n）会差别很大么？<ul>
<li>你的这个假设 delta 比较小是不合理的，我们大部分的需求都是 delta 比较大的。如果你说数据小的话，那什么办法都可以，不加索引也可以。数据小是无敌的。</li>
</ul>
</li>
<li>GoogleS2算法会将那些2D近，1D远的点漏掉对吧？所以它是不是精准度差？<ul>
<li>Google S2会比Geohash精准一点，因为Geohash存在一些很大的突变点，比如两个相隔很近的点刚好分到两个不同的格子的话就会使它们的前缀完全不一样。但是Google S2用的是一种突变没有那么严重的Pieano Curve，因此精准度会高一点。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h2><p>把地球表面分成一個個大格子，並用各個char代表，多次畫分成32份下去，無限逼近所在的位置。</p>
<p>公共長綴愈長，兩點愈來愈接近</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdl1zh1cgbj30sg0f2ta2.jpg" alt="image-20200407114112281" style="zoom: 33%;" />

<blockquote>
<ul>
<li>geohash算法中，如果两个点在分界两边，但其实离得很近，算法会分成两个不同的字母数字么？造成的误差怎么处理呢？<ul>
<li>会很大。一般不处理。因为人会走动，走两步，这个误差就没有了。系统设计不需要保证 100% 正确性。后面的讲解中也会提到。</li>
</ul>
</li>
<li>如何处理处在分界线两边很靠近的两点的情况？比如美国的两点很接近，但分属9和d?<ul>
<li>这个是GeoHash的一个缺陷，即使两个点相隔很近，其字符串的前缀也有可能完全不一样。不过在实际应用中可以有一些方法来弥补，比如在数据库中找距离x点在一定范围内的所有点的时候，除了搜索跟ｘ在一个小格子内的点之外，还可以搜索出于ｘ所在的格子相零的八个格子内的点，然后再汇总结果，这样就不会漏掉答案了。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>為何是4x8? 而不是5x10、3x6這類的1:2?<ul>
<li>因為GeoHash是一個二分法，實數可以無限往下二分除，得到很長的０１串</li>
<li>base32 去遞歸地劃地圖 <img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdl29586ydj30c808wjt0.jpg" alt="image-20200407115146360" style="zoom: 33%;" /></li>
<li>靠得近有時候geohash還是差得大，但人剛好處於這個大分界上的機率很小，可能下一秒就不在這個分界線上了</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>Geohash为什么不直接比较二进制数，而是比较hash以后的string呢？<ul>
<li>为了最终得出来的表示是整数位，base必须选取2的次方，因此可以将geohash存成2进制、4进制、8进制….等等。这里之所以选32进制是因为这样比较compact，而且最终生成出来的字符串可以被放在url里面，比如<a href="http://api.com/get_nearby_taxi/9q9hu3hhsjxx" target="_blank" rel="noopener">http://api.com/get_nearby_taxi/9q9hu3hhsjxx</a></li>
</ul>
</li>
<li>Geohash为什么不直接比较二进制数，而是比较hash以后的string呢？<ul>
<li>因为 GeoHash 如果存成二进制的话，肉眼不可读，不利于放在 url 里传播，也不利于别人复制粘贴。有方便“人”使用的考虑，如果只是给计算机看，二进制当然是可以的。</li>
</ul>
</li>
<li>geo hash 为什么要比较string？ 不直接比较二进制数？<ul>
<li>GeoHash 用字符串有如下一些好处：<ol>
<li>可读性高，可以直接让人阅读和复制，类似登陆验证码你不能给人一个二进制让人输入吧</li>
<li>可以放在 url 里，方便 url 的传播。</li>
</ol>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Range-Query-in-GeoHash-in-DB"><a href="#Range-Query-in-GeoHash-in-DB" class="headerlink" title="Range Query in GeoHash in DB"></a>Range Query in GeoHash in DB</h3><p>視需求要在多少距離內去map找 longest-common-prefix</p>
<p>e.g. 找附近20km的車</p>
<blockquote>
<ul>
<li><p>这里cassandra的row key是什么呢？</p>
<ul>
<li>在 GeoHash 的例子中，row_key 可以是前 4 位的 GeoHash，后面的内容里有提到如何 sharding 的问题。</li>
</ul>
</li>
<li><p>这种找共同prefix的问题是不是通过Trie来实现更高效啊。Redis那种方法其实就是通过hashtable的方式实现trie. 那SQL和Cassandra为什么不通过trie来实现呢，节省空间吗？</p>
<ul>
<li><p>Trie 和 Hash 的效率是一样的，查找一次时间复杂度都是 O(L)，L 是字符串长度（你需要去九章算法强化班补习一下这部分的内容哦）Trie 唯一优势是空间稍微省一些。像 SQL 和 Cassandra 这种数据库的结构是不支持 Trie 的。Trie 是算法和数据结构领域的东西，而不是数据库领域的东西。没有任何数据结构原生的支持 Trie，但是所有 key-value db 都可以认为是一个 hash table on disk。</p>
<p>TODO: <em>多比較此概念, <a href="https://leetcode.com/problems/longest-common-prefix/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-common-prefix/solution/</a></em></p>
</li>
</ul>
</li>
<li><p><strong><em>Redis的情况是要建立32^6+32^5+32^4个key吗？按讲义，9qhhvt,9q9hv,9q9h都是key</em></strong></p>
<ul>
<li>是的，理论上最多会有那么多个key，不过考虑到有很多无人区（海洋，荒山，沙漠啥的），而且公司业务一般不会完全覆盖整个地球，所以实际的数量其实不会达到那么多。如果真的一台机器放不下的话还可以sharding。</li>
</ul>
</li>
<li><p>cassandra的value没有null明白了，那么可不可以有“”(空字符串)呢?另外，cassandra是不是可以不设置columnkey从而只有rowkey和value呢？谢谢。</p>
<ul>
<li>不可以不设置 column key ，否则无法排序<code>&lt;row key, column key&gt;</code> 这个二元组。也无法对 column key 进行 range query。你的需求适合直接放在 RocksDb 这种只有 key-value 的结构里，不适合放在 row key column key value 的这种结构。</li>
</ul>
</li>
<li><p>相当于一个driver的位置要放到三个key的set里面？然后会根据driver位置的变化，会动态地增删这三个set？</p>
<ul>
<li>是的，如果位置分三级的话就是要动态增删三个色它</li>
</ul>
</li>
<li><p>cassandra 的 rowkey 和 column key 的差别是什么啊？ 可以简单说一下吗？</p>
<ul>
<li>Cassandra 中的 row key 就是 hash key 也叫做 partition key，是每次查询必须带上的（第二第三节课里有讲哦~），主要作用是当确定这个数据存在什么地方，你可以认为有一个函数叫做 <code>find_db_instance_by_row_key(row_key)</code> 能够根据 row_key 确定使用哪个 db instance，从而实现分布式存储。<br>很多 NoSQL 数据库没有 column key，比如 Redis。 Cassandra 有 Column key 的作用是，在一台数据库的机器上，所有数据是按照 row_key+column key 排好序的。所以当你确定了 row_key 是啥以后，就可以对 column key 进行范围查询，比如你可以查询 user_id（rowkey） 发的所有帖子里，在 昨天到今天这个范围内发的帖子（帖子的发表时间作为 column key），而 Redis 因为没有 column key 是做不到的。另外在后面的 Big Table 中，会详细介绍这类数据库的实现原理（BigTable 也是一个有 column key 的 db）</li>
</ul>
</li>
<li><p>cassandra把geohash放在column key，那row key该存什么，可以全都存在同一个row key下吗？例如null？</p>
<ul>
<li>Row key 存 geohash 的前 4 位。</li>
</ul>
</li>
<li><p>cassandra的row key是什么</p>
<ul>
<li>前 4 位 GeoHash</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="雙方角度思考業務跟儲存需求"><a href="#雙方角度思考業務跟儲存需求" class="headerlink" title="雙方角度思考業務跟儲存需求"></a>雙方角度思考業務跟儲存需求</h3><blockquote>
<ul>
<li>为什么不需要对driver按离rider距离远近排序？<ul>
<li>要排也行，可以在match的时候将最近的区域内的司机按距离排个序，然后选最近的。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><p>用戶無遷移成本，所以用戶黏性太差，分分鐘用戶就換別的用。</p>
<blockquote>
<h5 id="单选题-司机的-Location-信息应该按照什么进行-Sharding？"><a href="#单选题-司机的-Location-信息应该按照什么进行-Sharding？" class="headerlink" title="[单选题]司机的 Location 信息应该按照什么进行 Sharding？"></a>[单选题]司机的 Location 信息应该按照什么进行 Sharding？</h5><p>A.按照 User Id6.23% 选择</p>
<p>B.整个 GeoHash10.18% 选择</p>
<p>C.GeoHash的前4位72.04% 选择</p>
<p>D.GeoHash的前6位11.56% 选择</p>
<p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTM0MTgxMjgxODM5IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjM3NjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzIiIGhlaWdodD0iMzIiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxOC4xMiA1MTYuMTZtLTQ5MCAwYTQ5MCA0OTAgMCAxIDAgOTgwIDAgNDkwIDQ5MCAwIDEgMC05ODAgMFoiIGZpbGw9IiM1NkI0MzIiIHAtaWQ9IjM3NjMiPjwvcGF0aD48cGF0aCBkPSJNMzkzLjIxMzYxOSA2NjQuMzM1NDk1bTI4LjI4NDI3MS0yOC4yODQyNzFsMjk2Ljk4NDg0OS0yOTYuOTg0ODQ4cTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBsMCAwcTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDJsLTI5Ni45ODQ4NDggMjk2Ljk4NDg0OHEtMjguMjg0MjcxIDI4LjI4NDI3MS01Ni41Njg1NDMgMGwwIDBxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDJaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY0Ij48L3BhdGg+PHBhdGggZD0iTTI4OS40Njk4NCA0NTIuODQ3ODgzbTI4LjI4NDI3MSAyOC4yODQyNzFsMTU1LjU2MzQ5MiAxNTUuNTYzNDkycTI4LjI4NDI3MSAyOC4yODQyNzEgMCA1Ni41Njg1NDNsMCAwcS0yOC4yODQyNzEgMjguMjg0MjcxLTU2LjU2ODU0MyAwbC0xNTUuNTYzNDkxLTE1NS41NjM0OTJxLTI4LjI4NDI3MS0yOC4yODQyNzEgMC01Ni41Njg1NDNsMCAwcTI4LjI4NDI3MS0yOC4yODQyNzEgNTYuNTY4NTQyIDBaIiBmaWxsPSIjRkZGRkZGIiBwLWlkPSIzNzY1Ij48L3BhdGg+PC9zdmc+" alt="img">答对了，您选择的答案是C</p>
<p><strong>正确答案:</strong>C</p>
<p><strong>解析:</strong></p>
<p>按照 User Id 是显然不对的，因为乘客的 UserId 和他附近的司机的 UserId 可能会被 sharding 到不同的地方。<br>按照 GeoHash 进行 Sharding 的话，只需要按照前 4 位进行 sharding 即可。因为乘客的查询可能是按照前4，5，6位 GeoHash 进行查询，如果是按照前 6 位进行 sharding 的话，那么 BBBB22 和 BBBB33 就会被拆分开，而我们查询的时候其实希望如果用户在 BBBB22 的话，他能够查到位置在 BBBB33 的司机。</p>
</blockquote>
<p>城市不多，每個城市也是幾10個點圍出來的，可以在code裡直接寫死。</p>
<blockquote>
<ul>
<li>redis内部有自己的sharding机制么？需要自己手动写sharding算法还是只需要给sharding的column就可以？<ul>
<li>早期的版本没有。最近新出的版本里有 auto-sharding 的机制了，但是不是 consistent hashing 的算法，用的是另外一个，有兴趣的话，可以去网上搜一下相关的内容。</li>
</ul>
</li>
<li>但是有的城市uber的用户比较多，比较频发，有的城市用户比较少，怎么样能sharding的均匀呢？<ul>
<li>Uber 的做法是为用户多的城市多配置机器。用户少的城市少配置机器。</li>
</ul>
</li>
<li>按照city sharding，如果这个城市里有很多driver，该如何判断哪一个driver离这个乘客比较近？<ul>
<li>按照 city sharding 以后还是需要根据 geohash 去 filter 的。sharding 只是宏观上数据怎么拆分，geohash 是微观上具体每一条数据存储时的信息。我们根据 <strong>geohash</strong> 可以做范围查询来 filter 离乘客比较近的 driver。</li>
</ul>
</li>
<li>找到乘客周围的2-3 个城市怎么就能避免乘客算a city driver 算b city 但是其实两个人离得很近的问题？<ul>
<li>他俩隔得很近，那么说明 a city 和 b city 隔得很近。因此找到乘客周围 2-3 个城市的意思就是，既让乘客属于 a city ，也让他属于 b city，总共查2-3次。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Riak"><a href="#Riak" class="headerlink" title="Riak"></a>Riak</h3><p>Redis 有 Master slave的機制，M掛了S可以頂上去。</p>
<p>但其實可以用穩定性更強的DB, 更好處理掛掉後恢復的問題。</p>
<p>Uber也是從Redis換成了Riak。</p>
<blockquote>
<ul>
<li>master挂了的话，slave可以进行写操作吗<ul>
<li>不行，必须起一个新的master。</li>
</ul>
</li>
<li>之前课程不是说涉及transaction要用SQL吗？ 为何这边都是用NoSQL？<ul>
<li>这里并不需要用到 transaction，所以用 NoSQL 没有问题。且有一些 NoSQL 也支持 Transaction 了。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdj8kcgjkzj30kc0m8gn8.jpg" alt="image-20200405215453781" style="zoom: 25%;" />



<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdj8kg0owrj30kc0ws779.jpg" alt="image-20200405215851312" style="zoom:67%;" />

<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200407165538615.png" alt="image-20200407165538615" style="zoom:67%;" />

<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdlb1n83q9j30oc0j8tby.jpg" alt="image-20200407165557659" style="zoom:67%;" />

<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdlb2i72zyj30ow0msn15.jpg" alt="image-20200407165647857" style="zoom:67%;" />

<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdlb36wqt9j30pa0t00yp.jpg" alt="image-20200407165727152" style="zoom:67%;" /></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/41/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/41/">41</a><span class="page-number current">42</span><a class="page-number" href="/page/43/">43</a><span class="space">&hellip;</span><a class="page-number" href="/page/51/">51</a><a class="extend next" rel="next" href="/page/43/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Joe Huang</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>