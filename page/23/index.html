<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Joe Huang"><meta name="copyright" content="Joe Huang"><title>Awaken Desparado</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-180692466-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Joe Huang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">406</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">26</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">73</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Awaken Desparado</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Awaken Desparado</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/07/System-Design/2020-02-07-System%20Design%20xcode%20-%20Design%20FB%20Messenger/">System-Design/2020-02-07-System Design xcode - Design FB Messenger</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SystemDesign/">SystemDesign</a></span><div class="content"><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghn80sqe3xj30pg0dadie.jpg" alt="image-20200811220346038"></p>
<h3 id="Long-Polling-V-S-WebSocket"><a href="#Long-Polling-V-S-WebSocket" class="headerlink" title="Long-Polling V.S. WebSocket"></a>Long-Polling V.S. WebSocket</h3><p>去查要發給的user1是跟哪台server連結著的</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghn81z78ipj30na0eitan.jpg" alt="image-20200811220456942" style="zoom:33%;" />



<h3 id="Storage-R-amp-W-heavy-and-Sequential"><a href="#Storage-R-amp-W-heavy-and-Sequential" class="headerlink" title="Storage R &amp; W heavy, and Sequential"></a>Storage R &amp; W heavy, and Sequential</h3><p>Both Write</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/06/System-Design/2020-02-05-System%20Design%20-%20Push%20vs%20Pull/">System-Design/2020-02-05-System Design - Push vs Pull</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/System/">System</a></span><div class="content"><h1 id="Long-Polling-vs-WebSockets-vs-Server-Sent-Events"><a href="#Long-Polling-vs-WebSockets-vs-Server-Sent-Events" class="headerlink" title="Long-Polling vs WebSockets vs Server-Sent Events"></a>Long-Polling vs WebSockets vs Server-Sent Events</h1><h2 id="push-vs-pull"><a href="#push-vs-pull" class="headerlink" title="push vs pull"></a>push vs pull</h2><p>一般經常用到的service architecture 有 queuing, REST, RPC(Remote Procedure Call) 是服務之間怎麼交流</p>
<p>![image-20200206230736407](/Users/joe/Library/Application Support/typora-user-images/image-20200206230736407.png)</p>
<p>S 不一定要知道 C 的 ip, 上網看用戶的就是 C。 </p>
<p>![image-20200206231014572](/Users/joe/Library/Application Support/typora-user-images/image-20200206231014572.png)</p>
<p>定點對應服務</p>
<p>基本http請求就是 push請求</p>
<h3 id="Long-Polling"><a href="#Long-Polling" class="headerlink" title="Long-Polling"></a>Long-Polling</h3><p>什麼是HTTP </p>
<ul>
<li>用戶開connection 並向server請求data</li>
<li>server 算response</li>
<li>server送回response</li>
</ul>
<h4 id="Ajax-Polling-對應的也是-PUSH"><a href="#Ajax-Polling-對應的也是-PUSH" class="headerlink" title="Ajax Polling 對應的也是 PUSH"></a>Ajax Polling 對應的也是 PUSH</h4><p>每隔一段時間發一個請求去問好了沒，每0.5秒發一次</p>
<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200206231603559.png" alt="image-20200206231603559" style="zoom:50%;" />

<p>老有人來煩server。</p>
<p>中間也有個latency</p>
<h4 id="HTTP-Long-Polling-對應的也是-PUSH"><a href="#HTTP-Long-Polling-對應的也是-PUSH" class="headerlink" title="HTTP Long Polling - 對應的也是 PUSH"></a>HTTP Long Polling - 對應的也是 PUSH</h4><p>不是馬上response回來，connection一直hold，等在那邊直到好了被通知再發一個真正的請求過去</p>
<p>之前的請求只是要知道「什麼時候好」</p>
<p>有個timeout　</p>
<h3 id="WebSockets-PULL"><a href="#WebSockets-PULL" class="headerlink" title="WebSockets - PULL"></a>WebSockets - PULL</h3><h4 id="Full-duplex"><a href="#Full-duplex" class="headerlink" title="Full-duplex"></a>Full-duplex</h4><p>bidirectional</p>
<p>![image-20200725122407012](/Users/joe/Library/Application Support/typora-user-images/image-20200725122407012.png)</p>
<p><strong>C、S兩邊都可以發請求，同時的</strong>。half-duplex 是只有一邊發。</p>
<p>小負擔、幾乎實時、S不需要C的請求，也可以發過去。</p>
<img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4dopv4ij30w40ggag2.jpg" alt="image-20200206232250565" style="zoom:50%;" />

<p>Server可以PUSH, 發請求，即時拿到。</p>
<p>一般C對S發的Socket是收到response後就關掉了</p>
<p>是「不斷的」所以S可以找到C。</p>
<h4 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h4><p>用的是長連結</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4dvvbxfj310e0fqgu4.jpg" alt="image-20200206232544827"></p>
<p>S 可以即時PUSH!</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/06/System-Design/2020-02-05-System%20Design%20-%20NoSQL/">System-Design/2020-02-05-System Design - NoSQL</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/System/">System</a></span><div class="content"><p>SQL - ORM, basics</p>
<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>Not Only SQL</p>
<p>本身有幾個派別如kv, document</p>
<h4 id="4種型式的存儲方式"><a href="#4種型式的存儲方式" class="headerlink" title="4種型式的存儲方式"></a>4種型式的存儲方式</h4><ol>
<li><p>kv    - Redis, Memcached</p>
</li>
<li><p>document store - <strong>MongoDB</strong></p>
</li>
<li><p>wide column store - <strong>Cassandra</strong>, Bigtable, <strong>DynamoDB</strong></p>
</li>
<li><p>graph database - Neo4j</p>
</li>
</ol>
<h4 id="Normalize-–-JOIN-在SQL-ORM用的，往往一個機器"><a href="#Normalize-–-JOIN-在SQL-ORM用的，往往一個機器" class="headerlink" title="Normalize – JOIN　在SQL ORM用的，往往一個機器"></a>Normalize – JOIN　在SQL ORM用的，往往一個機器</h4><p>RDBMS避免冗餘</p>
<h4 id="Denormalize-–-大量重複要寫到多份，寫就麻煩，但讀有利"><a href="#Denormalize-–-大量重複要寫到多份，寫就麻煩，但讀有利" class="headerlink" title="Denormalize – 大量重複要寫到多份，寫就麻煩，但讀有利　"></a>Denormalize – 大量重複要寫到多份，寫就麻煩，但讀有利　</h4><p>多餘的重複寫到多個tables去，就是避免join, </p>
<p>在nosql 裡大量用的 ，nosql往往為了多機器作分布</p>
<p>數據中心要同步數據怎麼辦？跨<code>data-center Denormalize</code>就兩邊都寫</p>
<p>寫時要保證<strong><em>各國的數據中心都寫進去了</em></strong>，</p>
<p>要知道是 <code>read-heavy</code> or <code>write-heavy</code> 大多是讀的多，</p>
<p>如youtube讀的人遠大於寫的人</p>
<h5 id="缺點：不利於寫、冗缺、如果系統write-heavy就很不利，如logging-system、message-que"><a href="#缺點：不利於寫、冗缺、如果系統write-heavy就很不利，如logging-system、message-que" class="headerlink" title="缺點：不利於寫、冗缺、如果系統write-heavy就很不利，如logging system、message que"></a>缺點：不利於寫、冗缺、如果系統write-heavy就很不利，如logging system、message que</h5><p>什麼系統是寫多的? logging系統如卡夫卡</p>
<ul>
<li><p>要做join的話是在<strong>applicatin layer也是middle layer?!</strong>的　＝＝＞　<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h38ag80odjj20dg0ey3yj.jpg" alt="image-20200206221633536" style="zoom: 25%;" /></p>
</li>
<li><p>不支持ACID - <em>ACID</em> (<em>atomicity, consistency, isolation, durability</em>) is a set of properties of database transactions intended to guarantee validity ，那麼多機器不能保證事務</p>
</li>
<li><p>nosql不好鎖，多個當然不好鎖，慢慢才最終一致, 跨機器不容易鎖呀，所以是eventually consistency</p>
<ul>
<li>例如：linkedin發了文章，不是需要馬上好友都看到，可以有latency的，我的follower之後才收到沒差</li>
</ul>
<p>叫作 <strong><em>eventually consistency</em></strong>，可能就不是毫秒級的，是秒級的，也不會到慢到一分鐘之類</p>
<ul>
<li><h4 id="為何是Eventually-Consistency"><a href="#為何是Eventually-Consistency" class="headerlink" title="為何是Eventually Consistency?"></a>為何是Eventually Consistency?</h4><ul>
<li><h4 id="Quorum-就是假如有三個人，2-1，少數服從多數，儘管第三台還沒寫到，它在第二台被寫後，也會要因為大家投票變了，要服從是變第2版"><a href="#Quorum-就是假如有三個人，2-1，少數服從多數，儘管第三台還沒寫到，它在第二台被寫後，也會要因為大家投票變了，要服從是變第2版" class="headerlink" title="Quorum - 就是假如有三個人，2:1，少數服從多數，儘管第三台還沒寫到，它在第二台被寫後，也會要因為大家投票變了，要服從是變第2版"></a>Quorum - 就是假如有三個人，2:1，少數服從多數，儘管第三台還沒寫到，它在第二台被寫後，也會要因為大家投票變了，要服從是變第2版</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggrfjal4ukj30ym0hw0xh.jpg" alt="image-20200715100536958"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ACID-in-SQL-atomicity-consistency-isolation-durability"><a href="#ACID-in-SQL-atomicity-consistency-isolation-durability" class="headerlink" title="ACID in SQL - (atomicity, consistency, isolation, durability)"></a>ACID in SQL - (<em>atomicity, consistency, isolation, durability</em>)</h1><p>一台機器時，SQL就可保證事務，銀行Transaction 銀行的經典例子 - </p>
<p>一個事務裡：原子性。</p>
<p>銀行在意事務，所以ORM比較好。如果在一個地方取，中間</p>
<p>帳號是個變量a, 本來有1000元，一邊要存5000元，另個人從我的帳戶也取1000元。如果沒有事務保護</p>
<p>數據就亂了</p>
<p>DBMS裡在　為保證transation可靠，所以要有ACID,事務中只能有一個會成功</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h38agfne6oj212a0iqjs9.jpg" alt="image-20200206222645993" style="zoom:50%;" />



<h1 id="CAP-General-for-both-SQL-amp-NoSQL"><a href="#CAP-General-for-both-SQL-amp-NoSQL" class="headerlink" title="CAP, General for both SQL &amp; NoSQL"></a>CAP, General for both SQL &amp; NoSQL</h1><ul>
<li><p><strong>CAP Theorem</strong></p>
</li>
<li><p>在<a href="https://zh.wikipedia.org/wiki/理論計算機科學" target="_blank" rel="noopener">理論計算機科學</a>中，<strong>CAP定理</strong>（CAP theorem），又被稱作<strong>布魯爾定理</strong>（Brewer’s theorem），它指出對於一個<a href="https://zh.wikipedia.org/wiki/分布式计算" target="_blank" rel="noopener">分布式計算系統</a>來說，不可能同時滿足以下三點：<a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-Lynch-1" target="_blank" rel="noopener">[1]</a><a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-2" target="_blank" rel="noopener">[2]</a></p>
<ul>
<li>一致性（<strong>C</strong>onsistency） （等同於所有節點訪問同一份最新的數據副本）</li>
<li><a href="https://zh.wikipedia.org/wiki/可用性" target="_blank" rel="noopener">可用性</a>（<strong>A</strong>vailability）（每次請求都能獲取到非錯的響應——但是不保證獲取的數據為最新數據）</li>
<li><a href="https://zh.wikipedia.org/w/index.php?title=网络分区&action=edit&redlink=1" target="_blank" rel="noopener">分區容錯性</a>（<strong>P</strong>artition tolerance）（以實際效果而言，分區相當於對通信的時限要求。系統如果不能在時限內達成數據一致性，就意味著發生了分區的情況，必須就當前操作在C和A之間做出選擇<a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-3" target="_blank" rel="noopener">[3]</a>。）</li>
</ul>
<p>根據定理，分布式系統只能滿足三項中的兩項而不可能滿足全部三項<a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-4" target="_blank" rel="noopener">[4]</a>。理解CAP理論的最簡單方式是想像兩個節點分處分區兩側。允許至少一個節點更新狀態會導致數據不一致，即喪失了C性質。如果為了保證數據一致性，將分區一側的節點設置為不可用，那麼又喪失了A性質。除非兩個節點可以互相通信，才能既保證C又保證A，這又會導致喪失P性質。</p>
<p><strong>BASE</strong> is often used to describe the properties of NoSQL databases. In comparison with the <a href="https://github.com/donnemartin/system-design-primer#cap-theorem" target="_blank" rel="noopener">CAP Theorem</a>, BASE chooses availability over consistency.</p>
<ul>
<li><strong>Basically available</strong> - the system guarantees availability.</li>
<li><strong>Soft state</strong> - the state of the system may change over time, even without input.</li>
<li><strong>Eventual consistency</strong> - the system will become consistent over a period of time, given that the system doesn’t receive input during that period.</li>
</ul>
</li>
</ul>
<h1 id="NoSQL-Cont"><a href="#NoSQL-Cont" class="headerlink" title="NoSQL Cont."></a>NoSQL Cont.</h1><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p>ORM object relational mapping, mysql oracle都是可以被java裡搞定起來</p>
<p>DDL 時就是schema都是差不多的　－　Data Definition Language，DDL</p>
<h4 id="NoSQL就有分流派了-主要就是四大流派"><a href="#NoSQL就有分流派了-主要就是四大流派" class="headerlink" title="NoSQL就有分流派了 主要就是四大流派"></a>NoSQL就有分流派了 主要就是四大流派</h4><p>Key-Value資料庫、Wide Col、圖學資料庫和Document.</p>
<h4 id="Source-s-and-further-reading-key-value-store"><a href="#Source-s-and-further-reading-key-value-store" class="headerlink" title="Source(s) and further reading: key-value store"></a>Source(s) and further reading: key-value store</h4><ul>
<li><p><a href="https://en.wikipedia.org/wiki/Key-value_database" target="_blank" rel="noopener">Key-value database</a></p>
</li>
<li><p><a href="http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or" target="_blank" rel="noopener">Disadvantages of key-value stores</a></p>
</li>
<li><p><a href="http://qnimate.com/overview-of-redis-architecture/" target="_blank" rel="noopener">Redis architecture</a>　比較是緩存服務; 2.2 後有支援 transaction, lock for <code>Booking System</code></p>
</li>
<li><p><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/" target="_blank" rel="noopener">Memcached architecture</a>　比較是緩存服務</p>
</li>
</ul>
<h4 id="Document-Store-MongoDB"><a href="#Document-Store-MongoDB" class="headerlink" title="Document Store - MongoDB"></a>Document Store - MongoDB</h4><h5 id="最重要的就是Schemaless-–-就是沒有schema"><a href="#最重要的就是Schemaless-–-就是沒有schema" class="headerlink" title="最重要的就是Schemaless – 就是沒有schema,"></a>最重要的就是Schemaless – 就是沒有schema,</h5><h4 id="Document-store，"><a href="#Document-store，" class="headerlink" title="Document store，"></a>Document store，</h4><h5 id="Schemaless"><a href="#Schemaless" class="headerlink" title="Schemaless"></a>Schemaless</h5><p>如JSON就是kv, 就是<code>schemaless</code></p>
<blockquote>
<p>Abstraction: key-value store with documents stored as values</p>
</blockquote>
<p>A document store is centered around documents (XML, JSON, binary, etc), where a document stores all information for a given object. Document stores provide APIs or a query language to query based on the internal structure of the document itself. <em>Note, many key-value stores include features for working with a value’s metadata, blurring the lines between these two storage types.</em></p>
<p>Based on the underlying impleme</p>
<h5 id="Source-s-and-further-reading-document-store"><a href="#Source-s-and-further-reading-document-store" class="headerlink" title="Source(s) and further reading: document store"></a>Source(s) and further reading: document store</h5><ul>
<li><p><a href="https://en.wikipedia.org/wiki/Document-oriented_database" target="_blank" rel="noopener">Document-oriented database</a></p>
</li>
<li><p><a href="https://www.mongodb.com/mongodb-architecture" target="_blank" rel="noopener">MongoDB architecture</a></p>
</li>
<li><p><a href="https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/" target="_blank" rel="noopener">CouchDB architecture</a></p>
</li>
<li><p><a href="https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up" target="_blank" rel="noopener">Elasticsearch architecture</a></p>
</li>
</ul>
<h4 id="Wide-column-store"><a href="#Wide-column-store" class="headerlink" title="Wide column store"></a>Wide column store</h4><p><a href="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cnj0ioj30g506f0t2.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cnj0ioj30g506f0t2.jpg" alt="img"></a><br><strong><em><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html" target="_blank" rel="noopener">Source: SQL &amp; NoSQL, a brief history</a></em></strong></p>
<blockquote>
<p>Abstraction: nested map <code>ColumnFamily&gt;</code></p>
</blockquote>
<p><strong>Google introduced <a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf" target="_blank" rel="noopener">Bigtable</a></strong> as the first wide column store, which influenced the open-source <strong><a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture" target="_blank" rel="noopener">HBase</a> (by Hadoop)</strong> often-used in the Hadoop ecosystem, and <a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html" target="_blank" rel="noopener">Cassandra</a> from Facebook. Stores such as BigTable, HBase, and Cassandra maintain keys in lexicographic order, allowing efficient retrieval of selective key ranges.</p>
<h4 id="Graph-DB-–-for-social-Network"><a href="#Graph-DB-–-for-social-Network" class="headerlink" title="Graph DB – for social Network"></a>Graph DB – for social Network</h4><h5 id="Graph-database"><a href="#Graph-database" class="headerlink" title="Graph database"></a>Graph database</h5><p><a href="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cpicsqj30h40c4gps.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cpicsqj30h40c4gps.jpg" alt="img"></a><br><em><a href="https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png" target="_blank" rel="noopener">Source: Graph database</a></em></p>
<blockquote>
<p>Abstraction: graph</p>
</blockquote>
<p>In a graph database, each node is a record and each arc is a relationship between two nodes. Graph databases are optimized to represent complex relationships with many foreign keys or many-to-many relationships.</p>
<p>Graphs databases offer high performance for data models with complex relationships, such as a social network. They are relatively new and are not yet widely-used; it might be more difficult to find development tools and resources. Many graphs can only be accessed with <a href="https://github.com/donnemartin/system-design-primer#representational-state-transfer-rest" target="_blank" rel="noopener">REST APIs</a>.</p>
<h5 id="Source-s-and-further-reading-graph"><a href="#Source-s-and-further-reading-graph" class="headerlink" title="Source(s) and further reading: graph"></a>Source(s) and further reading: graph</h5><ul>
<li><a href="https://en.wikipedia.org/wiki/Graph_database" target="_blank" rel="noopener">Graph database</a></li>
<li><strong><a href="https://neo4j.com/" target="_blank" rel="noopener">Neo4j</a></strong></li>
<li><a href="https://blog.twitter.com/2010/introducing-flockdb" target="_blank" rel="noopener">FlockDB</a></li>
</ul>
<h2 id="SQL-vs-NoSQL-何時用"><a href="#SQL-vs-NoSQL-何時用" class="headerlink" title="SQL vs NoSQL 何時用?"></a>SQL vs NoSQL 何時用?</h2><p>如<code>mysql</code> vs <code>cassandra (mongoDB)</code> 之間的區別之類的？</p>
<p>Reasons for <strong>SQL</strong>:</p>
<ul>
<li>Structured data</li>
<li>Strict schema</li>
<li><strong>Relational data</strong></li>
<li>Need for complex <strong>joins</strong> 如<code>用戶</code>跟<code>group</code></li>
<li><code>Transactions</code>　事務</li>
<li>Clear patterns for scaling</li>
<li>More established: developers, community, code, tools, etc</li>
<li>Lookups by <strong><em>index</em></strong> are very fast</li>
</ul>
<p>Reasons for <strong>NoSQL</strong>:</p>
<ul>
<li>Semi-structured data　　</li>
<li><strong><em>Dynamic or flexible schema</em></strong></li>
<li>Non-relational data</li>
<li>No need for complex joins</li>
<li><strong><em>Store many TB (or PB) of data</em></strong>　</li>
<li><strong><em>Very data intensive workload</em></strong> </li>
<li><code>Very high throughput for IOPS (Input/Output Operations Per Second</code></li>
</ul>
<h5 id="Sample-data-well-suited-for-NoSQL"><a href="#Sample-data-well-suited-for-NoSQL" class="headerlink" title="Sample data well-suited for NoSQL:"></a>Sample data well-suited for NoSQL:</h5><ul>
<li><p>Rapid ingest of clickstream and <strong><em>log data</em></strong> <strong>之前說的頻繁寫的!!</strong></p>
</li>
<li><p>Leaderboard or scoring data <strong><em>就 eventually consistency 就好的</em></strong></p>
</li>
<li><p>Temporary data, such as a <code>shopping cart</code>  有cache就可以搞定</p>
</li>
<li><p>Frequently accessed (‘hot’) tables</p>
</li>
<li><p>Metadata/lookup tables</p>
</li>
</ul>
<h5 id="Source-s-and-further-reading-SQL-or-NoSQL"><a href="#Source-s-and-further-reading-SQL-or-NoSQL" class="headerlink" title="Source(s) and further reading: SQL or NoSQL"></a>Source(s) and further reading: SQL or NoSQL</h5><ul>
<li><a href="https://www.youtube.com/watch?v=w95murBkYmU" target="_blank" rel="noopener">Scaling up to your first 10 million users</a></li>
<li><a href="https://www.sitepoint.com/sql-vs-nosql-differences/" target="_blank" rel="noopener">SQL vs NoSQL differences</a></li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h38afqt977j210u0iitam.jpg" alt="image-20200206225707917"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h38aftxl8tj210u0fqabr.jpg" alt="image-20200206225824207"></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4crkjxdj311005wdge.jpg" alt="image-20200206225934479"></p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h38afy3hw8j211808mt9h.jpg" alt="image-20200206230007842" style="zoom:50%;" />

<p>量不大時　SQL 就夠了；如ACID、data不會變的或結構的</p>
<p>量大時才會用 NoSQL 學校一般用不到那麼大流量啊 量大時一般沒結構，的確<code>NoSQL</code>也是比較靈活</p>
<p>雲上一般要多個機器，硬體也都比較便宜</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd5cj2dgicj30u00wv1g9.jpg" alt="image-20200324213805414" style="zoom: 33%;" /></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/06/System-Design/2020-02-05-System%20Design%20-%20Cache/">System-Design/2020-02-05-System Design - Cache</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/System/">System</a></span><div class="content"><h3 id="https-kknews-cc-zh-tw-code-8vljmng-html"><a href="#https-kknews-cc-zh-tw-code-8vljmng-html" class="headerlink" title="https://kknews.cc/zh-tw/code/8vljmng.html"></a><a href="https://kknews.cc/zh-tw/code/8vljmng.html" target="_blank" rel="noopener">https://kknews.cc/zh-tw/code/8vljmng.html</a></h3><p><a href="https://www.zhihu.com/question/319817091" target="_blank" rel="noopener">https://www.zhihu.com/question/319817091</a></p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>對比<strong>disk</strong> and <strong>memory</strong>, 內存貴，跟disk比，它寫跟讀快很多</p>
<h4 id="local-disk-V-S-memory"><a href="#local-disk-V-S-memory" class="headerlink" title="local disk V.S. memory"></a>local disk V.S. memory</h4><p>能不能把一部份的數據放到memory讓它快?</p>
<p>讀不到才去worker 找，</p>
<p>Cache kv對，很快，repeated Query可這樣做，當一個fn被多次調用，就是要加 Cache</p>
<img src="https://camo.githubusercontent.com/7acedde6aa7853baf2eb4a53f88e2595ebe43756/687474703a2f2f692e696d6775722e636f6d2f51367a32344c612e706e67" alt="img" style="zoom:48%;" />

<p>方法算法被多次叫怎辦？就是說要加Cache。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnblny6qkj312c0g8qch.jpg" alt="image-20200711204719225"></p>
<p>緩存的應用很多。</p>
<p>DB會受益；同個URL來，他不的</p>
<p>本地的缓存就自己本地拿了，不会再去 server端。</p>
<h4 id="Cacheing-service-Memcache-Redis"><a href="#Cacheing-service-Memcache-Redis" class="headerlink" title="Cacheing service : Memcache, Redis"></a>Cacheing service : Memcache, Redis</h4><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rkssomcj310c0kgaj0.jpg" alt="image-20200206192031055" style="zoom:50%;" />

<h3 id="Cache-aside"><a href="#Cache-aside" class="headerlink" title="Cache aside"></a>Cache aside</h3><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggrhq7cinxj30zk0ign31.jpg" alt="image-20200715112132396" style="zoom: 50%;" />

<p>照理redis不需要知道業務邏輯，應該都是client控制的，所以redis跟db應該沒分前後</p>
<p>並發時噁心</p>
<p>機率非常低，還可以設上個ttl，讓他自動expire，減小髒的機率，髒指的就是cache、db不同</p>
<p>這個是最常用的</p>
<h3 id="Cache-Aside-也會有的併發的問題，但概率很低，也可以設ttl解"><a href="#Cache-Aside-也會有的併發的問題，但概率很低，也可以設ttl解" class="headerlink" title="Cache Aside 也會有的併發的問題，但概率很低，也可以設ttl解"></a>Cache Aside 也會有的併發的問題，但概率很低，也可以設ttl解</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rkxfaonj30uc0hk44g.jpg" alt="image-20200206192751483"></p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>分布式cache</p>
<p>redis是個緩存服務，如果用redis他有很多模式，最好的就是如果有三台機器，希望每台都分擔些</p>
<p>traffic用一致性哈希　不同key知道要去哪台找，每個node 就是 1/n</p>
<p>雲計算就是堆機器。</p>
<h5 id="缺點："><a href="#缺點：" class="headerlink" title="缺點："></a>缺點：</h5><p>要是一個機器掛了，有時有個備份。要是一台機器突然沒了，要是用consistent哈希，會重新算每個從 1/5變1/4。cache miss就是去　DB拿。要是突然一台掛了，瞬間會對，一致性哈希有個hash ring。目標就是當一個走了後，盡量讓原來的機器，每個機器要從1/4 –&gt; 1/3　差為1/12。每台要增加這麼多的數據量。讓遷坤大挪移緩和點。</p>
<p>一致性哈希是說讓遷移。讓</p>
<p>distributed hash　就是取模</p>
<p>CDN　content distributed network，也是緩存，更像file system。縣到市市到省</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rl19ugwj30ze0k0wp2.jpg" alt="image-20200206194335424" style="zoom:50%;" />

<p>　</p>
<h3 id="Read-Write-Through"><a href="#Read-Write-Through" class="headerlink" title="Read/Write Through"></a>Read/Write Through</h3><p>使用者寫到cache, cache自己會負責跟db更新，不用你來管，對應用來說簡單多。</p>
<p>嚴格上跟memorycached、redis不一樣，這種cache是知道業務邏輯是知道schema、數據的。</p>
<h5 id="Cache-就是個Service了"><a href="#Cache-就是個Service了" class="headerlink" title="Cache　就是個Service了"></a>Cache　<strong>就是個Service了</strong></h5><p>調cache的人就舒服了什麼都不用管，服務本身在做cache</p>
<p>它會同步寫到db，必須DB完成後才能返回給３，會慢一點寫慢一點，讀仍是快</p>
<p>把client做的邏輯給cache做</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rl5r877j30ea0k8go4.jpg" alt="img" style="zoom:67%;" />

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggzlagwgjvj30yi0e8qai.jpg" alt="image-20200722112920219"></p>
<h5 id="Disadvantage-s-write-through"><a href="#Disadvantage-s-write-through" class="headerlink" title="Disadvantage(s): write through"></a>Disadvantage(s): write through</h5><ul>
<li><p>When a new node is created due to failure or scaling, the new node will not cache entries until the entry is updated in the database. <strong>Cache-aside in conjunction with write through can mitigate this issue.</strong>　來個新node要去db找來寫代價大</p>
</li>
<li><p>Most data written might never be read, which can be minimized with a TTL.　給個死掉的時間</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rl9vcz3j30s60k0dty.jpg" alt="image-20200206195432938" style="zoom:50%;" />





</li>
</ul>
<h3 id="Write-behind-↓-下面"><a href="#Write-behind-↓-下面" class="headerlink" title="Write-behind　↓　下面"></a>Write-behind　↓　下面</h3><p>cache不是馬上去更新db，當大量高併發寫時，撐不住，所以先buffer一下個10秒</p>
<p>k:v1, v2, v3，直接就一次v3就好了 </p>
<p>DB可batch更新　時間到或queue到其值</p>
<p>萬一buffer時掛了怎辦？linux RO</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cmhb4sj30lu0k8aao.jpg" alt="img"></p>
<h5 id="Refresh-ahead…-↓"><a href="#Refresh-ahead…-↓" class="headerlink" title="Refresh ahead… ↓"></a>Refresh ahead… ↓</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>简单的说就是在缓存数据过期前，能自动的刷新缓存数据。举个例子来说，某条数据在缓存中，过期时间是60秒。我们给他设置一个参数，比如是0.8，60x0.8=48秒，那么在前48秒访问该数据，就照正常的取法，直接返回缓存中的数据。当在48-60秒这个区间取数据时，缓存先将之前缓存的结果返回给外部应用程序，然后异步的再从数据库去更新缓存中的值，以尽可能的保证缓存的值是最新的。如果取数据的的时候超过了60秒，就安装read-through的方式。<br> Refresh-ahead是对未来数据的访问情形的估算，我们猜测这个数据在过期后，仍然可能被频繁的访问，那么这种设计的策略获得的优势会更明显。<br> 但是，如果有大量的数据是用refresh-ahead策略，但是这个数据被重新缓存后，又一次都没有被访问过，那这个策略就是很失算的了。<br> 那么，有人可能会问，既然如此，我把过期的时间延长不就好了，之前60秒过期，改成6000秒过期，这样就不会用Refresh-ahead策略来刷新数据了。<br> 然而，事实是缓存的数据越久，出现脏数据的可能性也就越大，更重要的是，如果你的估算也是失误的，大量的超期缓存数据没有被实际访问，那么你就浪费了很多的内存，做了无用的事情，这也是应该避免的。</p>
<p>作者：周小春<br>链接：<a href="https://www.jianshu.com/p/6321d4f823c1" target="_blank" rel="noopener">https://www.jianshu.com/p/6321d4f823c1</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/05/System-Design/2019-02-04-System%20Design%20-%20LB/">System-Design/2019-02-04-System Design - LB</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/System/">System</a></span><div class="content"><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>怎麼random選一個server，LB要保證</p>
<p>NGINX 異步</p>
<h2 id="SNAKE"><a href="#SNAKE" class="headerlink" title="SNAKE"></a>SNAKE</h2><ul>
<li>Scenario: case/interface</li>
<li>Necessary: constrain/hypothesis</li>
<li>Application: service/algo</li>
<li>Kilobit: data</li>
<li>Evolve</li>
</ul>
<p>使用redis 緩存的地方</p>
<ul>
<li>獎品，數量少，更新頻率低，最佳的全量緩存對象</li>
<li>優惠券，一次性導入，優惠券編碼緩存為set類型</li>
<li>中獎紀錄，讀寫差不多，可以緩存部分統計數據</li>
<li>黑名單</li>
</ul>
<h2 id="Loading-Balancing"><a href="#Loading-Balancing" class="headerlink" title="Loading Balancing"></a>Loading Balancing</h2><h3 id="Load-Balancer"><a href="#Load-Balancer" class="headerlink" title="Load Balancer"></a>Load Balancer</h3><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rkbx8ooj319y0acwkc.jpg" alt="image-20200205225415969" style="zoom:50%;" />

<ol>
<li><p>Smart Clients</p>
<p>如果host recover了，就要能夠識別</p>
<p>系統大了，LB可能是單獨的機器</p>
<p>等著，占著一個線程，回來才release，上面的那條線是同步的假定，異步的效能會比較好</p>
<ul>
<li>nginx async</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>Hardware LB</p>
</li>
<li><p>Software LB</p>
<ul>
<li><strong>HAProxy</strong> 是個比較popular 的software, 加了機器要自己再改配置</li>
<li>Service Discovery 改配置文件</li>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnaa27ds3j314e0la474.jpg" alt="image-20200711200135289"></li>
<li>9000會forward到其他的三個機上去</li>
</ul>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblx1909c6j31c20i2h6v.jpg" alt="image-20200205225556197" style="zoom:50%;" />

<p>​    </p>
<h3 id="設計-Serverside-Load-Balancer-選server"><a href="#設計-Serverside-Load-Balancer-選server" class="headerlink" title="設計 Serverside Load Balancer 選server"></a>設計 Serverside Load Balancer 選server</h3><p>LB 不是個單獨的機器，只是在運行時在代碼裡的一個 client，如下↓</p>
<p>![image-20200711200432006](/Users/joe/Library/Application Support/typora-user-images/image-20200711200432006.png)</p>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblyao5twoj314a0jk7jx.jpg" alt="image-20200205233939163" style="zoom:50%;" />



<h4 id="Clien-Side-LB"><a href="#Clien-Side-LB" class="headerlink" title="Clien-Side LB"></a>Clien-Side LB</h4><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblyb6gizej314y0lik65.jpg" alt="image-20200205234009523" style="zoom:50%;" />

<p>Load balancing 可以用一致性哈希的機制　key是一樣永遠會去一樣的機器</p>
<p>希望對某一個key去固定的server取緩存</p>
<h5 id="Smart-Consistent-Hash-選-Server"><a href="#Smart-Consistent-Hash-選-Server" class="headerlink" title="Smart Consistent Hash 選 Server"></a>Smart Consistent Hash 選 Server</h5><p>這個是Sticky</p>
<p>也有上面三點可以根據去選</p>
<ol>
<li>Availability</li>
<li>Performance 看誰閒</li>
<li>地理，怎麼判斷route到哪個國家？</li>
</ol>
<h4 id="Spring-Cloud-Ribbon-Library"><a href="#Spring-Cloud-Ribbon-Library" class="headerlink" title="Spring Cloud - Ribbon Library"></a>Spring Cloud - Ribbon Library</h4><p>來了新的ABC Service，LB會知道，因為有Service Registration，LB會考慮第11個進來</p>
<p>Smart LB, 到底該發給哪個Server? 需要SMART!</p>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblyg6va34j30z20pqgw1.jpg" alt="image-20200205234458185" style="zoom:50%;" />

<h5 id="１-AvailabilityFilteringRule"><a href="#１-AvailabilityFilteringRule" class="headerlink" title="１ AvailabilityFilteringRule"></a>１ AvailabilityFilteringRule</h5><p>​        10秒、100, 1000秒再試 exponential</p>
<h5 id="２-WeightedResponseTimeRule"><a href="#２-WeightedResponseTimeRule" class="headerlink" title="２ WeightedResponseTimeRule"></a>２ WeightedResponseTimeRule</h5><p>​        要等愈長，權重給它愈小，我相對應該要發給response快的。</p>
<p>​    <strong>但不知道是DB慢還是API自己慢</strong>，還可講更底層的 TLS(Transpor Layer Security)、握手等機制都是routing的因素，所以smart LB都要考慮</p>
<h2 id="System-Design-Primer-GitHub"><a href="#System-Design-Primer-GitHub" class="headerlink" title="System Design Primer - GitHub"></a>System Design Primer - GitHub</h2><p><a href="https://github.com/kevingo/system-design-primer-zh-tw#how-to-approach-a-system-design-interview-question" target="_blank" rel="noopener">https://github.com/kevingo/system-design-primer-zh-tw#how-to-approach-a-system-design-interview-question</a>　</p>
<p>而</p>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblyxvhf3ij30sb0ixwfc.jpg" alt="img" style="zoom:48%;" />

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnaryy7bhj312o0icqgf.jpg" alt="image-20200711201841909"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnatffvd9j30xo09wae1.jpg" alt="image-20200711202012221"></p>
<h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL:"></a>SSL:</h4><p> 怕 man in the middle 監聽；但 SSL 到門口就可以停下來了，內部自己人不需要用SSL, SSL需要去裝Certification X.509 的認證，需要被 CA給授權，是頒發下來的</p>
<h4 id="Session-persistent"><a href="#Session-persistent" class="headerlink" title="Session persistent:"></a>Session persistent:</h4><p> 可以根據cookie、一致性哈希去路由到某個固定的機器去維持一個session，每次都發到一個固定的 Worker上，這樣永遠在跟這個Worker打交道，session的數據放在memory，機器會直接記得你放的東西，就是Session Data，</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnaw03p78j30ze0c6aga.jpg" alt="image-20200711202240110"></p>
<ul>
<li><p>Sticky session / cookies 指的就是之前提到的 constant hash</p>
</li>
<li><p>傳輸層安全性協定（英語：Transport Layer Security，縮寫：TLS）及其前身安全通訊協定（英語：Secure Sockets Layer，縮寫：SSL）是一種安全協定，目的是為網際網路通訊提供安全及資料完整性保障。</p>
</li>
<li><p>TLS與SSL協定可加密客戶端與伺服器端的網路通訊，它們利用憑證來建立身分鏈，以確保客戶端所通訊的對象是經過驗證的合法伺服器。而進行HTTPS監聽的方法則是在客戶端與伺服器端之間建立一個中間代理人，類似中間人攻擊（man-in-the-middle）的手法，這些可執行HTTPS監聽的安全產品會先攔截流量、檢查流量內容，再重建連結。</p>
</li>
<li><p>内部自己用RPC</p>
</li>
<li><p>Load balancers can be implemented with hardware (expensive) or with software such as HAProxy.</p>
<p>Additional benefits include:</p>
<ul>
<li>SSL termination</li>
</ul>
</li>
</ul>
<pre><code>\- Decrypt incoming requests and encrypt server responses so backend servers do not have to perform these potentially expensive operations

- Removes the need to install [X.509 certificates](https://en.wikipedia.org/wiki/X.509) on each server</code></pre><ul>
<li><strong>Session persistence</strong> - Issue cookies and route a specific client’s requests to same instance if the web apps do not keep track of sessions === 如購物車時</li>
</ul>
<h4 id="Faile-Over"><a href="#Faile-Over" class="headerlink" title="Faile Over"></a>Faile Over</h4><ul>
<li><ul>
<li><h3 id="Fail-over"><a href="#Fail-over" class="headerlink" title="Fail-over"></a>Fail-over</h3><h4 id="Active-passive-failover-有替補的當主要的掛了時馬上補上去"><a href="#Active-passive-failover-有替補的當主要的掛了時馬上補上去" class="headerlink" title="Active-passive failover 有替補的當主要的掛了時馬上補上去"></a>Active-passive failover 有替補的當主要的掛了時馬上補上去</h4><p>不停發 心動，如果沒有了，就趕緊找候補代替他</p>
<p>With active-passive fail-over, heartbeats are sent between the active and the passive server on standby. If the heartbeat is interrupted, the passive server takes over the active’s IP address and resumes service.</p>
<p>The length of downtime is determined by whether the passive server is already running in ‘hot’ standby or whether it needs to start up from ‘cold’ standby. Only the active server handles traffic.</p>
<p>Active-passive failover can also be referred to as master-slave failover.</p>
<h4 id="Active-active"><a href="#Active-active" class="headerlink" title="Active-active"></a>Active-active</h4><p>In active-active, both servers are managing traffic, spreading the load between them.</p>
<p>If the servers are public-facing, the DNS would need to know about the public IPs of both servers. If the servers are internal-facing, application logic would need to know about both servers.</p>
<p>Active-active failover can also be referred to as master-master failover.</p>
</li>
</ul>
</li>
</ul>
<h3 id="LB-Traffics"><a href="#LB-Traffics" class="headerlink" title="LB Traffics"></a>LB Traffics</h3><ul>
<li><h3 id="Layer-4-load-balancing"><a href="#Layer-4-load-balancing" class="headerlink" title="Layer 4 load balancing"></a>Layer 4 load balancing</h3><p>第四層看不了 Session，只有下面粗字的能看</p>
<p>Layer 4 load balancers look at info at the <a href="https://github.com/kevingo/system-design-primer-zh-tw#communication" target="_blank" rel="noopener">transport layer</a> to decide how to distribute requests. Generally, this involves the <strong>source, destination IP addresses, and ports</strong> in the header, but not the contents of the packet. Layer 4 load balancers forward network packets to and from the upstream server, performing <a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" target="_blank" rel="noopener">Network Address Translation (NAT)</a>.</p>
<h5 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h5><ul>
<li><p><strong>NAT</strong> - Network Address Translation (NAT) </p>
<p>就是 public IP 要 map進去內部的IP</p>
<p>對外會把ip映射成一個對外的ip</p>
<p>當在配置一個data center 時，內外ip的mapping</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnb6o69t6j30ww0a60x6.jpg" alt="image-20200711203254172"></p>
</li>
</ul>
</li>
</ul>
<h3 id="Layer-7-load-balancing"><a href="#Layer-7-load-balancing" class="headerlink" title="Layer 7 load balancing"></a>Layer 7 load balancing</h3><p>  能做的事比 L4更多，愈下面愈快，RPC就是快</p>
<p>  Layer 7 load balancers look at the <a href="https://github.com/kevingo/system-design-primer-zh-tw#communication" target="_blank" rel="noopener">application layer</a> to decide how to distribute requests. This can involve contents of the <strong>header, message, and cookies</strong>. Layer 7 load balancers terminates network traffic, reads the message, makes a load-balancing decision, then opens a connection to the selected server. <strong>For example, a layer 7 load balancer can direct video traffic to servers that host videos while directing more sensitive user billing traffic to security-hardened servers.</strong><br>  比較好的網關，對於REST過來的URL, 會根據 URLroute 到不同的服務</p>
<p>  E.g.: </p>
<pre><code>- xxx.com/account/XXXX -&gt; billing/account service
- xxx.com/video/YYY -&gt; video_service</code></pre><ul>
<li><strong>spring cloud zuul</strong>裡就有得配置　将path ==&gt; serviceId </li>
</ul>
  <img src="https://camo.githubusercontent.com/1d761d5688d28ce1fb12a0f1c8191bca96eece4c/687474703a2f2f692e696d6775722e636f6d2f354b656f6351732e6a7067" alt="img"  />

<p>  At the cost of flexibility, <strong><em>layer 4 load balancing requires less time and computing resources than Layer 7</em></strong>, although the performance impact can be minimal on modern commodity hardware.</p>
<p>  ​        愈底下愈快啊　如Application Server用IPC　肯定比http快</p>
<h3 id="Horizontal-scaling-加機器，而不是加单一台的性能"><a href="#Horizontal-scaling-加機器，而不是加单一台的性能" class="headerlink" title="Horizontal scaling     加機器，而不是加单一台的性能"></a>Horizontal scaling     加機器，而不是加单一台的性能</h3><p>Load balancers can also help with horizontal scaling, improving performance and availability. Scaling out using commodity machines is more cost efficient and results in higher availability than scaling up a single server on more expensive hardware, called <strong>Vertical Scaling　==&gt;　加CPU、RAM</strong>. It is also easier to hire for talent working on commodity hardware than it is for specialized enterprise systems.</p>
<h4 id="Disadvantage-s-horizontal-scaling"><a href="#Disadvantage-s-horizontal-scaling" class="headerlink" title="Disadvantage(s): horizontal scaling"></a>Disadvantage(s): horizontal scaling</h4><ul>
<li><p>Scaling horizontally introduces complexity and involves cloning servers</p>
<ul>
<li><p>Servers should be <strong>stateless</strong>: they should not contain any user-related data like sessions or profile pictures　<strong>不管去哪台web server機器都應該要是一樣的　不該有session這樣的東西</strong></p>
<p><strong><em>↑ Server 是Stateless, ↓ Session是Stateful</em></strong></p>
</li>
<li><p><strong>Sessions</strong> can be stored in a centralized data store such as a <a href="https://github.com/kevingo/system-design-primer-zh-tw#database" target="_blank" rel="noopener">database</a> (SQL, NoSQL) or a persistent <a href="https://github.com/kevingo/system-design-primer-zh-tw#cache" target="_blank" rel="noopener">cache</a> (Redis, Memcached). <strong>Session 就是 Stateful</strong></p>
</li>
</ul>
</li>
<li><p>Downstream servers such as caches and databases need to handle more simultaneous connections as upstream servers scale out</p>
</li>
</ul>
<p>​        </p>
<h3 id="Disadvantage-s-load-balancer"><a href="#Disadvantage-s-load-balancer" class="headerlink" title="Disadvantage(s): load balancer"></a>Disadvantage(s): load balancer</h3><ul>
<li><p>The load balancer can become a performance bottleneck if it does not have enough resources or if it is not configured properly.　掛了就沒</p>
</li>
<li><p>Introducing a load balancer to help eliminate single points of failure results in increased complexity. 系統複雜了，也是會有問題</p>
</li>
</ul>
<ul>
<li><p>A single load balancer is a single point of failure, configuring multiple load balancers further increases complexity.</p>
</li>
<li><h3 id="Source-s-and-further-reading"><a href="#Source-s-and-further-reading" class="headerlink" title="Source(s) and further reading"></a>Source(s) and further reading</h3><ul>
<li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="noopener">NGINX architecture</a></li>
<li><a href="http://www.haproxy.org/download/1.2/doc/architecture.txt" target="_blank" rel="noopener">HAProxy architecture guide</a></li>
<li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones" target="_blank" rel="noopener">Scalability</a></li>
<li><a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)" target="_blank" rel="noopener">Wikipedia</a></li>
<li><a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" target="_blank" rel="noopener">Layer 4 load balancing</a></li>
<li><a href="https://www.nginx.com/resources/glossary/layer-7-load-balancing/" target="_blank" rel="noopener">Layer 7 load balancing</a></li>
<li><a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html" target="_blank" rel="noopener">ELB listener config</a>　　這個是亞馬遜自己開發的</li>
</ul>
</li>
</ul>
<h5 id="LB-某種意義上就是-reversed-proxy-Web-Server-了"><a href="#LB-某種意義上就是-reversed-proxy-Web-Server-了" class="headerlink" title="LB 某種意義上就是 reversed proxy (Web Server)了"></a>LB 某種意義上就是 reversed proxy (Web Server)了</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnbfav77vj31200nunc2.jpg" alt="image-20200711204112504"></p>
<p>ref : </p>
<p><a href="https://www.youtube.com/watch?v=RlkA1NRoYJ8&amp;list=PLbhaS_83B97vSWVslD63vjIi5OTYmSVrk&amp;index=80" target="_blank" rel="noopener">https://www.youtube.com/watch?v=RlkA1NRoYJ8&amp;list=PLbhaS_83B97vSWVslD63vjIi5OTYmSVrk&amp;index=80</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/22/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/82/">82</a><a class="extend next" rel="next" href="/page/24/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2024 By Joe Huang</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>