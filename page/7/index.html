<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Joe Huang"><meta name="copyright" content="Joe Huang"><title>Awaken Desparado</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Joe Huang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">298</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">25</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">45</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Awaken Desparado</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Awaken Desparado</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/07/System-Design/2020-02-07-System%20Design%20xcode%20-%20CDN/">System-Design/2020-02-07-System Design xcode - CDN</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/System/">System</a></span><div class="content"><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>CDN　content distributed network，也是緩存，更像file system。縣到市市到省</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghxfthrialj30rs0ff3zy.jpg" alt="img" style="zoom:67%;" />





<ul>
<li><p>一般是租用全球的，會把同個file replicate 到各個server，fewer hops</p>
</li>
<li><p>如果miss了會一層層往上要，最後到orig server</p>
</li>
</ul>
<blockquote>
<p>A content delivery network (CDN) is a globally distributed network of proxy servers, serving content from locations closer to the user. Generally, static files such as HTML/CSS/JS, photos, and videos are served from CDN, although some CDNs such as Amazon’s CloudFront support dynamic content. The site’s DNS resolution will tell clients which server to contact.</p>
<p>Serving content from CDNs can significantly improve performance in two ways:</p>
<ul>
<li>Users receive content from data centers close to them</li>
<li>Your servers do not have to serve requests that the CDN fulfills</li>
</ul>
</blockquote>
<p>愈近愈快，網路傳輸很常是很大的bottleneck，netflix有個經典問題，話題帶到如算法優化時，跟disk的io、network的io不值一提哈。</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghxg0wj7fkj30y40gsnab.jpg" alt="image-20200820181620952" style="zoom:50%;" />



<p>一般而言readability比runtime更重要！因為在實際工作中，網路、disk的latency遠超過算法的runtime。</p>
<p>Q-select就剩個幾個nano seconds，在系統設計面前不值得一提…。</p>
<h2 id="補充："><a href="#補充：" class="headerlink" title="補充："></a>補充：</h2><h3 id="秒殺"><a href="#秒殺" class="headerlink" title="秒殺"></a>秒殺</h3><p>系統忙不過來，所以商品介紹可以放靜態file在cdn好處理高併發</p>
<h3 id="Youtube-Netflix"><a href="#Youtube-Netflix" class="headerlink" title="Youtube/Netflix"></a>Youtube/Netflix</h3><p>分佈在世界各地、按geolocation，把比較hot的放在cdn，用戶可以放在local cdn去取，會更好</p>
<h2 id="Push-CDNs"><a href="#Push-CDNs" class="headerlink" title="Push CDNs"></a>Push CDNs</h2><blockquote>
<p>Push CDNs receive new content whenever changes occur on your server. You take full responsibility for providing content, uploading directly to the CDN and rewriting URLs to point to the CDN. You can configure when content expires and when it is updated. Content is uploaded only when it is new or changed, <strong>minimizing traffic, but maximizing storage</strong>.</p>
<p>Sites with a small amount of traffic or sites with content that isn’t often updated work well with push CDNs. Content is placed on the CDNs once, instead of being re-pulled at regular intervals.</p>
</blockquote>
<p>如果file 內容更新了，得要去告訴cdn server更新，或是就設expire，如cache miss時的情況，如沒找到或expire時沒找到</p>
<p>更新會主動 Push Client，而不是不斷去拿；<strong>但一般是Pull比較多</strong>。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghxg1ie3myj30vi0jyn5m.jpg" alt="image-20200820181656677"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghxg03u9ggj30vu0k2alt.jpg" alt="image-20200820181534739"></p>
<h2 id="PULL-CDNs"><a href="#PULL-CDNs" class="headerlink" title="PULL CDNs"></a>PULL CDNs</h2><blockquote>
<p>Pull CDNs grab new content from your server when the first user requests the content. You leave the content on your server and rewrite URLs to point to the CDN. This results in a slower request until the content is cached on the CDN.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Time_to_live" target="_blank" rel="noopener">time-to-live (TTL)</a> determines how long content is cached. Pull CDNs minimize storage space on the CDN, but can create redundant traffic if files expire and are pulled before they have actually changed.</p>
<p>Sites with heavy traffic work well with pull CDNs, as traffic is spread out more evenly with only recently-requested content remaining on the CDN.</p>
</blockquote>
<ul>
<li>不斷地pull要是它沒有expire就白pull了。</li>
</ul>
<h2 id="Disadvantage-s-CDN"><a href="#Disadvantage-s-CDN" class="headerlink" title="Disadvantage(s): CDN"></a>Disadvantage(s): CDN</h2><p>一般不會那麼複雜</p>
<p>一般就是第三方全球性的，自己小公司做不到。</p>
<ul>
<li>CDN <strong>costs</strong> could be significant depending on traffic, although this should be weighed with additional costs you would incur not using a CDN.  – 租別人要花錢；有時不一定要用，貴呀</li>
<li>Content might be stale if it is updated before the TTL expires it.  – 我們一般操作會給file設TTLE，有可能TTL還沒有過期，但我更新了源頭的file了，但本地的CDN還沒有expire它，這時去讀到的CDN就是個stale的，不是最新的版本，因為我還沒讓它過期，我以為它是最新的，但它實際不是最新的。</li>
<li>CDNs require changing URLs for static content to point to the CDN.  – 我拿CDN時每個file都會有個unique的URL，我要是新的話，我得去改URL，後綴什麼的，畢竟就是不同的FILE了呀。一般可能加個參數如timestamp或版本什麼的，browser會以為是不同的URL，讓cache失效，如在URL後面加  <strong>?v=1&amp;t=2</strong> 這類的，其實就是說URL我必須要改到，去point到新的CDN的file。</li>
<li>dropbox就要跟file相關啦!</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/07/System-Design/2020-02-07-System%20Design%20xcode%20-%20Design%20FB%20Messenger/">System-Design/2020-02-07-System Design xcode - Design FB Messenger</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SystemDesign/">SystemDesign</a></span><div class="content"><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghn80sqe3xj30pg0dadie.jpg" alt="image-20200811220346038"></p>
<h3 id="Long-Polling-V-S-WebSocket"><a href="#Long-Polling-V-S-WebSocket" class="headerlink" title="Long-Polling V.S. WebSocket"></a>Long-Polling V.S. WebSocket</h3><p>去查要發給的user1是跟哪台server連結著的</p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ghn81z78ipj30na0eitan.jpg" alt="image-20200811220456942" style="zoom:33%;" />



<h3 id="Storage-R-amp-W-heavy-and-Sequential"><a href="#Storage-R-amp-W-heavy-and-Sequential" class="headerlink" title="Storage R &amp; W heavy, and Sequential"></a>Storage R &amp; W heavy, and Sequential</h3><p>Both Write</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/06/System-Design/2020-02-05-System%20Design%20-%20Push%20vs%20Pull/">System-Design/2020-02-05-System Design - Push vs Pull</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/System/">System</a></span><div class="content"><h1 id="Long-Polling-vs-WebSockets-vs-Server-Sent-Events"><a href="#Long-Polling-vs-WebSockets-vs-Server-Sent-Events" class="headerlink" title="Long-Polling vs WebSockets vs Server-Sent Events"></a>Long-Polling vs WebSockets vs Server-Sent Events</h1><h2 id="push-vs-pull"><a href="#push-vs-pull" class="headerlink" title="push vs pull"></a>push vs pull</h2><p>一般經常用到的service architecture 有 queuing, REST, RPC(Remote Procedure Call) 是服務之間怎麼交流</p>
<p>![image-20200206230736407](/Users/joe/Library/Application Support/typora-user-images/image-20200206230736407.png)</p>
<p>S 不一定要知道 C 的 ip, 上網看用戶的就是 C。 </p>
<p>![image-20200206231014572](/Users/joe/Library/Application Support/typora-user-images/image-20200206231014572.png)</p>
<p>定點對應服務</p>
<p>基本http請求就是 push請求</p>
<h3 id="Long-Polling"><a href="#Long-Polling" class="headerlink" title="Long-Polling"></a>Long-Polling</h3><p>什麼是HTTP </p>
<ul>
<li>用戶開connection 並向server請求data</li>
<li>server 算response</li>
<li>server送回response</li>
</ul>
<h4 id="Ajax-Polling-對應的也是-PUSH"><a href="#Ajax-Polling-對應的也是-PUSH" class="headerlink" title="Ajax Polling 對應的也是 PUSH"></a>Ajax Polling 對應的也是 PUSH</h4><p>每隔一段時間發一個請求去問好了沒，每0.5秒發一次</p>
<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200206231603559.png" alt="image-20200206231603559" style="zoom:50%;" />

<p>老有人來煩server。</p>
<p>中間也有個latency</p>
<h4 id="HTTP-Long-Polling-對應的也是-PUSH"><a href="#HTTP-Long-Polling-對應的也是-PUSH" class="headerlink" title="HTTP Long Polling - 對應的也是 PUSH"></a>HTTP Long Polling - 對應的也是 PUSH</h4><p>不是馬上response回來，connection一直hold，等在那邊直到好了被通知再發一個真正的請求過去</p>
<p>之前的請求只是要知道「什麼時候好」</p>
<p>有個timeout　</p>
<h3 id="WebSockets-PULL"><a href="#WebSockets-PULL" class="headerlink" title="WebSockets - PULL"></a>WebSockets - PULL</h3><h4 id="Full-duplex"><a href="#Full-duplex" class="headerlink" title="Full-duplex"></a>Full-duplex</h4><p>bidirectional</p>
<p>![image-20200725122407012](/Users/joe/Library/Application Support/typora-user-images/image-20200725122407012.png)</p>
<p><strong>C、S兩邊都可以發請求，同時的</strong>。half-duplex 是只有一邊發。</p>
<p>小負擔、幾乎實時、S不需要C的請求，也可以發過去。</p>
<img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4dopv4ij30w40ggag2.jpg" alt="image-20200206232250565" style="zoom:50%;" />

<p>Server可以PUSH, 發請求，即時拿到。</p>
<p>一般C對S發的Socket是收到response後就關掉了</p>
<p>是「不斷的」所以S可以找到C。</p>
<h4 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h4><p>用的是長連結</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4dvvbxfj310e0fqgu4.jpg" alt="image-20200206232544827"></p>
<p>S 可以即時PUSH!</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/06/System-Design/2020-02-05-System%20Design%20-%20NoSQL/">System-Design/2020-02-05-System Design - NoSQL</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/System/">System</a></span><div class="content"><p>SQL - ORM, basics</p>
<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>Not Only SQL</p>
<p>本身有幾個派別如kv, document</p>
<h4 id="4種型式的存儲方式"><a href="#4種型式的存儲方式" class="headerlink" title="4種型式的存儲方式"></a>4種型式的存儲方式</h4><ol>
<li>kv</li>
<li>document store</li>
<li>wide column store</li>
<li>graph database</li>
</ol>
<h4 id="Normalize-–-JOIN-在SQL-ORM用的，往往一個機器"><a href="#Normalize-–-JOIN-在SQL-ORM用的，往往一個機器" class="headerlink" title="Normalize – JOIN　在SQL ORM用的，往往一個機器"></a>Normalize – JOIN　在SQL ORM用的，往往一個機器</h4><p>RDBMS避免冗餘</p>
<h4 id="Denormalize-–-大量重複要寫到多份，寫就麻煩，但讀有利"><a href="#Denormalize-–-大量重複要寫到多份，寫就麻煩，但讀有利" class="headerlink" title="Denormalize – 大量重複要寫到多份，寫就麻煩，但讀有利　"></a>Denormalize – 大量重複要寫到多份，寫就麻煩，但讀有利　</h4><p>多餘的重複寫到多個tables去，就是避免join, </p>
<p>在nosql 裡大量用的 ，nosql往往為了多機器作分布</p>
<p>數據中心要同步數據怎麼辦？跨data-center Denormalize就兩邊都寫</p>
<p>寫時要保證<strong><em>各國的數據中心都寫進去了</em></strong>，</p>
<p>要知道是 read-heavy or write-heavy 大多是讀的多，</p>
<p>如youtube讀的人遠大於寫的人</p>
<h5 id="缺點：不利於寫、冗缺、如果系統write-heavy就很不利，如logging-system、message-que"><a href="#缺點：不利於寫、冗缺、如果系統write-heavy就很不利，如logging-system、message-que" class="headerlink" title="缺點：不利於寫、冗缺、如果系統write-heavy就很不利，如logging system、message que"></a>缺點：不利於寫、冗缺、如果系統write-heavy就很不利，如logging system、message que</h5><p>什麼系統是寫多的? logging系統如卡夫卡</p>
<ul>
<li><p>要做join的話是在<strong>applicatin layer也是middle layer?!</strong>的　＝＝＞　<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200206221633536.png" alt="image-20200206221633536" style="zoom: 25%;" /></p>
</li>
<li><p>不支持ACID - <em>ACID</em> (<em>atomicity, consistency, isolation, durability</em>) is a set of properties of database transactions intended to guarantee validity ，那麼多機器不能保證事務</p>
</li>
<li><p>nosql不好鎖，多個當然不好鎖，慢慢才最終一致, 跨機器不容易鎖呀，所以是eventually consistency</p>
<ul>
<li>例如：linkedin發了文章，不是需要馬上好友都看到，可以有latency的，我的follower之後才收到沒差</li>
</ul>
<p>叫作 <strong><em>eventually consistency</em></strong>，可能就不是毫秒級的，是秒級的，也不會到慢到一分鐘之類</p>
<ul>
<li><h4 id="為何是Eventually-Consistency"><a href="#為何是Eventually-Consistency" class="headerlink" title="為何是Eventually Consistency?"></a>為何是Eventually Consistency?</h4><ul>
<li><h4 id="Quorum-就是假如有三個人，2-1，少數服從多數，儘管第三台還沒寫到，它在第二台被寫後，也會要因為大家投票變了，要服從是變第2版"><a href="#Quorum-就是假如有三個人，2-1，少數服從多數，儘管第三台還沒寫到，它在第二台被寫後，也會要因為大家投票變了，要服從是變第2版" class="headerlink" title="Quorum - 就是假如有三個人，2:1，少數服從多數，儘管第三台還沒寫到，它在第二台被寫後，也會要因為大家投票變了，要服從是變第2版"></a>Quorum - 就是假如有三個人，2:1，少數服從多數，儘管第三台還沒寫到，它在第二台被寫後，也會要因為大家投票變了，要服從是變第2版</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggrfjal4ukj30ym0hw0xh.jpg" alt="image-20200715100536958"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ACID-in-SQL-atomicity-consistency-isolation-durability"><a href="#ACID-in-SQL-atomicity-consistency-isolation-durability" class="headerlink" title="ACID in SQL - (atomicity, consistency, isolation, durability)"></a>ACID in SQL - (<em>atomicity, consistency, isolation, durability</em>)</h1><p>一台機器時，SQL就可保證事務，銀行Transaction 銀行的經典例子 - </p>
<p>一個事務裡：原子性。</p>
<p>銀行在意事務，所以ORM比較好。如果在一個地方取，中間</p>
<p>帳號是個變量a, 本來有1000元，一邊要存5000元，另個人從我的帳戶也取1000元。如果沒有事務保護</p>
<p>數據就亂了</p>
<p>DBMS裡在　為保證transation可靠，所以要有ACID,事務中只能有一個會成功</p>
<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200206222645993.png" alt="image-20200206222645993" style="zoom:50%;" />



<h1 id="NoSQL-Cont"><a href="#NoSQL-Cont" class="headerlink" title="NoSQL Cont."></a>NoSQL Cont.</h1><ul>
<li><p><strong>CAP Theorem</strong></p>
</li>
<li><p>在<a href="https://zh.wikipedia.org/wiki/理論計算機科學" target="_blank" rel="noopener">理論計算機科學</a>中，<strong>CAP定理</strong>（CAP theorem），又被稱作<strong>布魯爾定理</strong>（Brewer’s theorem），它指出對於一個<a href="https://zh.wikipedia.org/wiki/分布式计算" target="_blank" rel="noopener">分布式計算系統</a>來說，不可能同時滿足以下三點：<a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-Lynch-1" target="_blank" rel="noopener">[1]</a><a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-2" target="_blank" rel="noopener">[2]</a></p>
<ul>
<li>一致性（<strong>C</strong>onsistency） （等同於所有節點訪問同一份最新的數據副本）</li>
<li><a href="https://zh.wikipedia.org/wiki/可用性" target="_blank" rel="noopener">可用性</a>（<strong>A</strong>vailability）（每次請求都能獲取到非錯的響應——但是不保證獲取的數據為最新數據）</li>
<li><a href="https://zh.wikipedia.org/w/index.php?title=网络分区&action=edit&redlink=1" target="_blank" rel="noopener">分區容錯性</a>（<strong>P</strong>artition tolerance）（以實際效果而言，分區相當於對通信的時限要求。系統如果不能在時限內達成數據一致性，就意味著發生了分區的情況，必須就當前操作在C和A之間做出選擇<a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-3" target="_blank" rel="noopener">[3]</a>。）</li>
</ul>
<p>根據定理，分布式系統只能滿足三項中的兩項而不可能滿足全部三項<a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-4" target="_blank" rel="noopener">[4]</a>。理解CAP理論的最簡單方式是想像兩個節點分處分區兩側。允許至少一個節點更新狀態會導致數據不一致，即喪失了C性質。如果為了保證數據一致性，將分區一側的節點設置為不可用，那麼又喪失了A性質。除非兩個節點可以互相通信，才能既保證C又保證A，這又會導致喪失P性質。</p>
<p><strong>BASE</strong> is often used to describe the properties of NoSQL databases. In comparison with the <a href="https://github.com/donnemartin/system-design-primer#cap-theorem" target="_blank" rel="noopener">CAP Theorem</a>, BASE chooses availability over consistency.</p>
<ul>
<li><strong>Basically available</strong> - the system guarantees availability.</li>
<li><strong>Soft state</strong> - the state of the system may change over time, even without input.</li>
<li><strong>Eventual consistency</strong> - the system will become consistent over a period of time, given that the system doesn’t receive input during that period.</li>
</ul>
</li>
</ul>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p>ORM object relational mapping, mysql oracle都是可以被java裡搞定起來</p>
<p>DDL 時就是schema都是差不多的　－　Data Definition Language，DDL</p>
<h4 id="NoSQL就有分流派了-主要就是四大流派"><a href="#NoSQL就有分流派了-主要就是四大流派" class="headerlink" title="NoSQL就有分流派了 主要就是四大流派"></a>NoSQL就有分流派了 主要就是四大流派</h4><p>Key-Value資料庫、記憶體資料庫、圖學資料庫和文件資料庫.</p>
<h4 id="Source-s-and-further-reading-key-value-store"><a href="#Source-s-and-further-reading-key-value-store" class="headerlink" title="Source(s) and further reading: key-value store"></a>Source(s) and further reading: key-value store</h4><ul>
<li><p><a href="https://en.wikipedia.org/wiki/Key-value_database" target="_blank" rel="noopener">Key-value database</a></p>
<p>如cassandra</p>
</li>
<li><p><a href="http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or" target="_blank" rel="noopener">Disadvantages of key-value stores</a></p>
</li>
<li><p><a href="http://qnimate.com/overview-of-redis-architecture/" target="_blank" rel="noopener">Redis architecture</a>　比較是緩存服務</p>
</li>
<li><p><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/" target="_blank" rel="noopener">Memcached architecture</a>　比較是緩存服務</p>
</li>
</ul>
<h4 id="Document-Store-MongoDB"><a href="#Document-Store-MongoDB" class="headerlink" title="Document Store - MongoDB"></a>Document Store - MongoDB</h4><h5 id="最重要的就是Schemaless-–-就是沒有schema"><a href="#最重要的就是Schemaless-–-就是沒有schema" class="headerlink" title="最重要的就是Schemaless – 就是沒有schema,"></a>最重要的就是Schemaless – 就是沒有schema,</h5><h4 id="Document-store，"><a href="#Document-store，" class="headerlink" title="Document store，"></a>Document store，</h4><h5 id="Schemaless"><a href="#Schemaless" class="headerlink" title="Schemaless"></a>Schemaless</h5><p>如JSON就是kv, 就是schemaless</p>
<blockquote>
<p>Abstraction: key-value store with documents stored as values</p>
</blockquote>
<p>A document store is centered around documents (XML, JSON, binary, etc), where a document stores all information for a given object. Document stores provide APIs or a query language to query based on the internal structure of the document itself. <em>Note, many key-value stores include features for working with a value’s metadata, blurring the lines between these two storage types.</em></p>
<p>Based on the underlying impleme</p>
<h5 id="Source-s-and-further-reading-document-store"><a href="#Source-s-and-further-reading-document-store" class="headerlink" title="Source(s) and further reading: document store"></a>Source(s) and further reading: document store</h5><ul>
<li><a href="https://en.wikipedia.org/wiki/Document-oriented_database" target="_blank" rel="noopener">Document-oriented database</a></li>
<li><a href="https://www.mongodb.com/mongodb-architecture" target="_blank" rel="noopener">MongoDB architecture</a></li>
<li><a href="https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/" target="_blank" rel="noopener">CouchDB architecture</a></li>
<li><a href="https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up" target="_blank" rel="noopener">Elasticsearch architecture</a></li>
</ul>
<h4 id="Wide-column-store"><a href="#Wide-column-store" class="headerlink" title="Wide column store"></a>Wide column store</h4><p><a href="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cnj0ioj30g506f0t2.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cnj0ioj30g506f0t2.jpg" alt="img"></a><br><strong><em><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html" target="_blank" rel="noopener">Source: SQL &amp; NoSQL, a brief history</a></em></strong></p>
<blockquote>
<p>Abstraction: nested map <code>ColumnFamily&gt;</code></p>
</blockquote>
<p><strong>Google introduced <a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf" target="_blank" rel="noopener">Bigtable</a></strong> as the first wide column store, which influenced the open-source <strong><a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture" target="_blank" rel="noopener">HBase</a> (by Hadoop)</strong> often-used in the Hadoop ecosystem, and <a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html" target="_blank" rel="noopener">Cassandra</a> from Facebook. Stores such as BigTable, HBase, and Cassandra maintain keys in lexicographic order, allowing efficient retrieval of selective key ranges.</p>
<h4 id="Graph-DB-–-for-social-Network"><a href="#Graph-DB-–-for-social-Network" class="headerlink" title="Graph DB – for social Network"></a>Graph DB – for social Network</h4><h5 id="Graph-database"><a href="#Graph-database" class="headerlink" title="Graph database"></a>Graph database</h5><p><a href="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cpicsqj30h40c4gps.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cpicsqj30h40c4gps.jpg" alt="img"></a><br><em><a href="https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png" target="_blank" rel="noopener">Source: Graph database</a></em></p>
<blockquote>
<p>Abstraction: graph</p>
</blockquote>
<p>In a graph database, each node is a record and each arc is a relationship between two nodes. Graph databases are optimized to represent complex relationships with many foreign keys or many-to-many relationships.</p>
<p>Graphs databases offer high performance for data models with complex relationships, such as a social network. They are relatively new and are not yet widely-used; it might be more difficult to find development tools and resources. Many graphs can only be accessed with <a href="https://github.com/donnemartin/system-design-primer#representational-state-transfer-rest" target="_blank" rel="noopener">REST APIs</a>.</p>
<h5 id="Source-s-and-further-reading-graph"><a href="#Source-s-and-further-reading-graph" class="headerlink" title="Source(s) and further reading: graph"></a>Source(s) and further reading: graph</h5><ul>
<li><a href="https://en.wikipedia.org/wiki/Graph_database" target="_blank" rel="noopener">Graph database</a></li>
<li><strong><a href="https://neo4j.com/" target="_blank" rel="noopener">Neo4j</a></strong></li>
<li><a href="https://blog.twitter.com/2010/introducing-flockdb" target="_blank" rel="noopener">FlockDB</a></li>
</ul>
<h2 id="SQL-vs-NoSQL-何時用"><a href="#SQL-vs-NoSQL-何時用" class="headerlink" title="SQL vs NoSQL 何時用?"></a>SQL vs NoSQL 何時用?</h2><p>如mysql vs cassandra (mongoDB) 之間的區別之類的？</p>
<p>Reasons for <strong>SQL</strong>:</p>
<ul>
<li>Structured data</li>
<li>Strict schema</li>
<li><strong>Relational data</strong></li>
<li>Need for complex <strong>joins</strong> 如用戶跟group</li>
<li>Transactions　事務</li>
<li>Clear patterns for scaling</li>
<li>More established: developers, community, code, tools, etc</li>
<li>Lookups by <strong><em>index</em></strong> are very fast</li>
</ul>
<p>Reasons for <strong>NoSQL</strong>:</p>
<ul>
<li>Semi-structured data　　</li>
<li><strong><em>Dynamic or flexible schema</em></strong></li>
<li>Non-relational data</li>
<li>No need for complex joins</li>
<li><strong><em>Store many TB (or PB) of data</em></strong>　</li>
<li><strong><em>Very data intensive workload</em></strong> </li>
<li>Very high throughput for IOPS (Input/Output Operations Per Second</li>
</ul>
<p>Sample data well-suited for NoSQL:</p>
<ul>
<li>Rapid ingest of clickstream and <strong><em>log data</em></strong> <strong>之前說的頻繁寫的!!</strong></li>
<li>Leaderboard or scoring data <strong><em>就 eventually consistency 就好的</em></strong></li>
<li>Temporary data, such as a shopping cart  有cache就可以搞定</li>
<li>Frequently accessed (‘hot’) tables</li>
<li>Metadata/lookup tables</li>
</ul>
<h5 id="Source-s-and-further-reading-SQL-or-NoSQL"><a href="#Source-s-and-further-reading-SQL-or-NoSQL" class="headerlink" title="Source(s) and further reading: SQL or NoSQL"></a>Source(s) and further reading: SQL or NoSQL</h5><ul>
<li><a href="https://www.youtube.com/watch?v=w95murBkYmU" target="_blank" rel="noopener">Scaling up to your first 10 million users</a></li>
<li><a href="https://www.sitepoint.com/sql-vs-nosql-differences/" target="_blank" rel="noopener">SQL vs NoSQL differences</a></li>
</ul>
<p>![image-20200206225707917](/Users/joe/Library/Application Support/typora-user-images/image-20200206225707917.png)</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>![image-20200206225824207](/Users/joe/Library/Application Support/typora-user-images/image-20200206225824207.png)</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4crkjxdj311005wdge.jpg" alt="image-20200206225934479"></p>
<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200206230007842.png" alt="image-20200206230007842" style="zoom:50%;" />

<p>量不大時　SQL 就夠了；如ACID、data不會變的或結構的</p>
<p>量大時才會用 NoSQL 學校一般用不到那麼大流量啊 量大時一般沒結構，的確NoSQL也是比較靈活</p>
<p>雲上一般要多個機器，硬體也都比較便宜</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd5cj2dgicj30u00wv1g9.jpg" alt="image-20200324213805414" style="zoom: 33%;" /></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/06/System-Design/2020-02-05-System%20Design%20-%20Cache/">System-Design/2020-02-05-System Design - Cache</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/System/">System</a></span><div class="content"><h3 id="https-kknews-cc-zh-tw-code-8vljmng-html"><a href="#https-kknews-cc-zh-tw-code-8vljmng-html" class="headerlink" title="https://kknews.cc/zh-tw/code/8vljmng.html"></a><a href="https://kknews.cc/zh-tw/code/8vljmng.html" target="_blank" rel="noopener">https://kknews.cc/zh-tw/code/8vljmng.html</a></h3><p><a href="https://www.zhihu.com/question/319817091" target="_blank" rel="noopener">https://www.zhihu.com/question/319817091</a></p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>對比<strong>disk</strong> and <strong>memory</strong>, 內存貴，跟disk比，它寫跟讀快很多</p>
<h4 id="local-disk-V-S-memory"><a href="#local-disk-V-S-memory" class="headerlink" title="local disk V.S. memory"></a>local disk V.S. memory</h4><p>能不能把一部份的數據放到memory讓它快?</p>
<p>讀不到才去worker 找，</p>
<p>Cache kv對，很快，repeated Query可這樣做，當一個fn被多次調用，就是要加 Cache</p>
<img src="https://camo.githubusercontent.com/7acedde6aa7853baf2eb4a53f88e2595ebe43756/687474703a2f2f692e696d6775722e636f6d2f51367a32344c612e706e67" alt="img" style="zoom:48%;" />

<p>方法算法被多次叫怎辦？就是說要加Cache。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnblny6qkj312c0g8qch.jpg" alt="image-20200711204719225"></p>
<p>緩存的應用很多。</p>
<p>DB會受益；同個URL來，他不的</p>
<p>本地的缓存就自己本地拿了，不会再去 server端。</p>
<h4 id="Cacheing-service-Memcache-Redis"><a href="#Cacheing-service-Memcache-Redis" class="headerlink" title="Cacheing service : Memcache, Redis"></a>Cacheing service : Memcache, Redis</h4><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rkssomcj310c0kgaj0.jpg" alt="image-20200206192031055" style="zoom:50%;" />

<h3 id="Cache-aside"><a href="#Cache-aside" class="headerlink" title="Cache aside"></a>Cache aside</h3><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggrhq7cinxj30zk0ign31.jpg" alt="image-20200715112132396" style="zoom: 50%;" />

<p>照理redis不需要知道業務邏輯，應該都是client控制的，所以redis跟db應該沒分前後</p>
<p>並發時噁心</p>
<p>機率非常低，還可以設上個ttl，讓他自動expire，減小髒的機率，髒指的就是cache、db不同</p>
<p>這個是最常用的</p>
<h3 id="Cache-Aside-也會有的併發的問題，但概率很低，也可以設ttl解"><a href="#Cache-Aside-也會有的併發的問題，但概率很低，也可以設ttl解" class="headerlink" title="Cache Aside 也會有的併發的問題，但概率很低，也可以設ttl解"></a>Cache Aside 也會有的併發的問題，但概率很低，也可以設ttl解</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rkxfaonj30uc0hk44g.jpg" alt="image-20200206192751483"></p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>分布式cache</p>
<p>redis是個緩存服務，如果用redis他有很多模式，最好的就是如果有三台機器，希望每台都分擔些</p>
<p>traffic用一致性哈希　不同key知道要去哪台找，每個node 就是 1/n</p>
<p>雲計算就是堆機器。</p>
<h5 id="缺點："><a href="#缺點：" class="headerlink" title="缺點："></a>缺點：</h5><p>要是一個機器掛了，有時有個備份。要是一台機器突然沒了，要是用consistent哈希，會重新算每個從 1/5變1/4。cache miss就是去　DB拿。要是突然一台掛了，瞬間會對，一致性哈希有個hash ring。目標就是當一個走了後，盡量讓原來的機器，每個機器要從1/4 –&gt; 1/3　差為1/12。每台要增加這麼多的數據量。讓遷坤大挪移緩和點。</p>
<p>一致性哈希是說讓遷移。讓</p>
<p>distributed hash　就是取模</p>
<p>CDN　content distributed network，也是緩存，更像file system。縣到市市到省</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rl19ugwj30ze0k0wp2.jpg" alt="image-20200206194335424" style="zoom:50%;" />

<p>　</p>
<h3 id="Read-Write-Through"><a href="#Read-Write-Through" class="headerlink" title="Read/Write Through"></a>Read/Write Through</h3><p>使用者寫到cache, cache自己會負責跟db更新，不用你來管，對應用來說簡單多。</p>
<p>嚴格上跟memorycached、redis不一樣，這種cache是知道業務邏輯是知道schema、數據的。</p>
<h5 id="Cache-就是個Service了"><a href="#Cache-就是個Service了" class="headerlink" title="Cache　就是個Service了"></a>Cache　<strong>就是個Service了</strong></h5><p>調cache的人就舒服了什麼都不用管，服務本身在做cache</p>
<p>它會同步寫到db，必須DB完成後才能返回給３，會慢一點寫慢一點，讀仍是快</p>
<p>把client做的邏輯給cache做</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rl5r877j30ea0k8go4.jpg" alt="img" style="zoom:67%;" />

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggzlagwgjvj30yi0e8qai.jpg" alt="image-20200722112920219"></p>
<h5 id="Disadvantage-s-write-through"><a href="#Disadvantage-s-write-through" class="headerlink" title="Disadvantage(s): write through"></a>Disadvantage(s): write through</h5><ul>
<li><p>When a new node is created due to failure or scaling, the new node will not cache entries until the entry is updated in the database. <strong>Cache-aside in conjunction with write through can mitigate this issue.</strong>　來個新node要去db找來寫代價大</p>
</li>
<li><p>Most data written might never be read, which can be minimized with a TTL.　給個死掉的時間</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rl9vcz3j30s60k0dty.jpg" alt="image-20200206195432938" style="zoom:50%;" />





</li>
</ul>
<h3 id="Write-behind-↓-下面"><a href="#Write-behind-↓-下面" class="headerlink" title="Write-behind　↓　下面"></a>Write-behind　↓　下面</h3><p>cache不是馬上去更新db，當大量高併發寫時，撐不住，所以先buffer一下個10秒</p>
<p>k:v1, v2, v3，直接就一次v3就好了 </p>
<p>DB可batch更新　時間到或queue到其值</p>
<p>萬一buffer時掛了怎辦？linux RO</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cmhb4sj30lu0k8aao.jpg" alt="img"></p>
<h5 id="Refresh-ahead…-↓"><a href="#Refresh-ahead…-↓" class="headerlink" title="Refresh ahead… ↓"></a>Refresh ahead… ↓</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>简单的说就是在缓存数据过期前，能自动的刷新缓存数据。举个例子来说，某条数据在缓存中，过期时间是60秒。我们给他设置一个参数，比如是0.8，60x0.8=48秒，那么在前48秒访问该数据，就照正常的取法，直接返回缓存中的数据。当在48-60秒这个区间取数据时，缓存先将之前缓存的结果返回给外部应用程序，然后异步的再从数据库去更新缓存中的值，以尽可能的保证缓存的值是最新的。如果取数据的的时候超过了60秒，就安装read-through的方式。<br> Refresh-ahead是对未来数据的访问情形的估算，我们猜测这个数据在过期后，仍然可能被频繁的访问，那么这种设计的策略获得的优势会更明显。<br> 但是，如果有大量的数据是用refresh-ahead策略，但是这个数据被重新缓存后，又一次都没有被访问过，那这个策略就是很失算的了。<br> 那么，有人可能会问，既然如此，我把过期的时间延长不就好了，之前60秒过期，改成6000秒过期，这样就不会用Refresh-ahead策略来刷新数据了。<br> 然而，事实是缓存的数据越久，出现脏数据的可能性也就越大，更重要的是，如果你的估算也是失误的，大量的超期缓存数据没有被实际访问，那么你就浪费了很多的内存，做了无用的事情，这也是应该避免的。</p>
<p>作者：周小春<br>链接：<a href="https://www.jianshu.com/p/6321d4f823c1" target="_blank" rel="noopener">https://www.jianshu.com/p/6321d4f823c1</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Joe Huang</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>