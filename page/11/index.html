<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Joe Huang"><meta name="copyright" content="Joe Huang"><title>Awaken Desparado</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Joe Huang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">298</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">25</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">44</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Awaken Desparado</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Awaken Desparado</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/13/Web/2019-12-13-Hexo%20management%20w:%202%20branches/">Web/2019-12-13-Hexo management w: 2 branches</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/">Web</a></span><div class="content"><p>###</p>
<p>From below: </p>
<p>作者：直上云霄<br>链接：<a href="https://www.zhihu.com/question/21193762/answer/489124966" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762/answer/489124966</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>git分支进行多终端工作</strong>问题来了，如果你现在在自己的笔记本上写的博客，部署在了网站上，那么你在家里用台式机，或者实验室的台式机，发现你电脑里面没有博客的文件，或者要换电脑了，最后不知道怎么移动文件，怎么办？在这里我们就可以利用git的分支系统进行多终端工作了，这样每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，就可以无缝操作了。</p>
<p><strong>机制</strong>机制是这样的，由于<code>hexo d</code>上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。<br><img src="https://pic3.zhimg.com/50/v2-32ab30d0d28b916a204c03de4ed0fc4f_hd.jpg" alt="img">)<img src="https://pic3.zhimg.com/80/v2-32ab30d0d28b916a204c03de4ed0fc4f_hd.jpg" alt="img"></p>
<p>也就是上传的是在本地目录里自动生成的<code>.deploy_git</code>里面。其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github<br><img src="https://pic4.zhimg.com/50/v2-59bb330178a4e010d9818911f789082b_hd.jpg" alt="img">)<img src="https://pic4.zhimg.com/80/v2-59bb330178a4e010d9818911f789082b_hd.jpg" alt="img"></p>
<p>所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。<br><strong>上传分支</strong>首先，先在github上新建一个hexo分支，如图：<br><img src="https://pic1.zhimg.com/50/v2-ebb3e05632e85ab036663390305caa1c_hd.jpg" alt="img">)<img src="https://pic1.zhimg.com/80/v2-ebb3e05632e85ab036663390305caa1c_hd.jpg" alt="img"></p>
<p>然后在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。<br><img src="https://pic2.zhimg.com/50/v2-1899b6219f3787832652813b958b9b3d_hd.jpg" alt="img">)<img src="https://pic2.zhimg.com/80/v2-1899b6219f3787832652813b958b9b3d_hd.jpg" alt="img"></p>
<p>然后在本地的任意目录下，打开git bash，<code>git clone git@github.com:ZJUFangzh/ZJUFangzh.github.io.git</code>将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。<br>接下来在克隆到本地的<code>ZJUFangzh.github.io</code>中，把除了.git 文件夹外的所有文件都删掉 把之前我们写的博客源文件全部复制过来，除了<code>.deploy_git</code>。这里应该说一句，复制过来的源文件应该有一个<code>.gitignore</code>，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git：<code>.DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/</code>注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的<code>.git</code>文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。而后<code>git add . git commit –m &quot;add branch&quot; git push</code>这样就上传完了，可以去你的github上看一看hexo分支有没有上传上去，其中<code>node_modules</code>、<code>public</code>、<code>db.json</code>已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装 。<br><img src="https://pic4.zhimg.com/50/v2-a94330ca825f4debde8ce7ceeb8f8394_hd.jpg" alt="img">)<img src="https://pic4.zhimg.com/80/v2-a94330ca825f4debde8ce7ceeb8f8394_hd.jpg" alt="img"></p>
<p>这样就上传完了。<br><strong>更换电脑操作</strong>一样的，跟之前的环境搭建一样，安装git<code>sudo apt-get install git</code>设置git全局邮箱和用户名<code>git config --global user.name &quot;yourgithubname&quot; git config --global user.email &quot;yourgithubemail&quot;</code>设置ssh key<code>ssh-keygen -t rsa -C &quot;youremail&quot; #生成后填到github和coding上（有coding平台的话） #验证是否成功 ssh -T git@github.com ssh -T git@git.coding.net #(有coding平台的话)</code>安装nodejs<code>sudo apt-get install nodejs sudo apt-get install npm</code>安装hexo  <code>sudo npm install hexo-cli -g</code>但是已经不需要初始化了，直接在任意文件夹下，<code>git clone git@………………</code>然后进入克隆到的文件夹：<code>cd xxx.github.io npm install npm install hexo-deployer-git --save</code>生成，部署：<code>hexo g hexo d</code><br>然后就可以开始写你的新博客了<code>hexo new newpage</code><br><strong>Tips:</strong>不要忘了，每次写完最好都把源文件上传一下<code>git add . git commit –m &quot;xxxx&quot; git push</code>如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了<code>git pull</code></p>
<p><a href="">发布于 2018-09-10</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/12/NLP/2019-12-12-LSTM%20Brief.%20&amp;%20Hamming%20Loss/">NLP/2019-12-12-LSTM Brief. &amp; Hamming Loss</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/NLP-AI/">NLP, AI</a></span><div class="content"><h3 id="LSTM-Brief"><a href="#LSTM-Brief" class="headerlink" title="LSTM Brief."></a>LSTM Brief.</h3><p>LSTM是SimpleRNN的变体，它解决了梯度消失的问题。怎么解决的那？</p>
<p>LSTM增加了一个可以相隔多个timesteps来传递信息的方法。想想有一个传送带在你处理sequences时一起运转。每个时间节点的信息都可以放到传送带上，或者从传送带上拿下来，当然你也可以更新传送带上的信息。这样就保存了很久之前的信息，防止了信息的丢失。我们把SimpleRNN中的矩阵记为<code>Wo Uo bo</code>，LSTM的结构图如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-31da92629c2ddbb0a3971d18f1592b03_hd.jpg" alt="img"></p>
<p>我们在SimpleRNN基础上，增加一条传送带（adding a carry track）用来传递信息。传送带上每个时刻的状态我们记为：<code>c t</code> c是carry的意思。</p>
<p>显然，当前时刻的输出就应该收到三个信息的影响</p>
<hr>
<h3 id="Hamming-Distance"><a href="#Hamming-Distance" class="headerlink" title="Hamming Distance"></a>Hamming Distance</h3><p>在<a href="https://zh.wikipedia.org/wiki/信息论" target="_blank" rel="noopener">資訊理論</a>中，兩個等長<a href="https://zh.wikipedia.org/wiki/字符串" target="_blank" rel="noopener">字符串</a>之間的<strong>漢明距離</strong>（英語：Hamming distance）是兩個字符串對應位置的不同字符的個數。換句話說，它就是將一個字符串變換成另外一個字符串所需要<em>替換</em>的字符個數。</p>
<p><strong><a href="https://zh.wikipedia.org/wiki/汉明重量" target="_blank" rel="noopener">漢明重量</a></strong>是字符串相對於同樣長度的零字符串的漢明距離，也就是說，它是字符串中非零的元素個數：對於<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二進位</a><a href="https://zh.wikipedia.org/wiki/字符串" target="_blank" rel="noopener">字符串</a>來說，就是1的個數，所以11101的漢明重量是4。</p>
<p>例如：</p>
<ul>
<li><strong>1011101</strong>與<strong>1001001</strong>之間的漢明距離是2。</li>
<li><strong>2143896</strong>與<strong>2233796</strong>之間的漢明距離是3。</li>
<li>“<strong>toned</strong>“與”<strong>roses</strong>“之間的漢明距離是3。</li>
</ul>
<hr>
<h3 id="Hamming-Loss"><a href="#Hamming-Loss" class="headerlink" title="Hamming Loss"></a>Hamming Loss</h3><p>Hamming Loss 是用来计算多标签分类(Multi-label classification)模型精度的。</p>
<p>HammingLoss=1N∑i=1NXOR(Yi,j,Pi,j)LHammingLoss=1N∑i=1NXOR(Yi,j,Pi,j)L</p>
<p>NN是样本的数量，LL是标签的个数，Yi,jYi,j是第ii个预测结果中第jj个分量的真实值，Pi,jPi,j是第ii个预测结果中第jj个分量的预测值，XORXOR是抑或，XOR(0,1)=XOR(1,0)=1XOR(0,1)=XOR(1,0)=1，XOR(0,0)=XOR(1,1)=0XOR(0,0)=XOR(1,1)=0。</p>
<p>例子：三个样本</p>
<p>Y1=(0,1,1,1,0),P1=(1,1,1,0,0)Y1=(0,1,1,1,0),P1=(1,1,1,0,0)</p>
<p>Y2=(1,0,0,1,1),P2=(1,0,0,0,1)Y2=(1,0,0,1,1),P2=(1,0,0,0,1)</p>
<p>Y3=(1,1,0,0,0),P3=(1,0,1,0,1)Y3=(1,1,0,0,0),P3=(1,0,1,0,1)<br>$$<br>HammingLoss=\frac{1}{3}×\frac{2+1+3}{5}=0.4<br>$$</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/12/NLP/2019-12-12-NLP%20metric%20%3E%20Perplexity/">NLP/2019-12-12-NLP metric &gt; Perplexity</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/NLP-AI/">NLP, AI</a></span><div class="content"><p>from : <a href="https://blog.csdn.net/index20001/article/details/78884646" target="_blank" rel="noopener">https://blog.csdn.net/index20001/article/details/78884646</a></p>
<h1 id="语言模型评价指标Perplexity"><a href="#语言模型评价指标Perplexity" class="headerlink" title="语言模型评价指标Perplexity"></a>语言模型评价指标Perplexity</h1><p>原创<a href="https://me.csdn.net/index20001" target="_blank" rel="noopener">Joy_Shen</a> 发布于2017-12-24 13:33:02 阅读数 26576 收藏</p>
<p>展开</p>
<p>语言模型（Language Model，LM），给出一句话的前k个词，希望它可以预测第k+1个词是什么，即给出一个第k+1个词可能出现的概率的分布p(xk+1|x1,x2,…,xk)。</p>
<p>在报告里听到用PPL衡量语言模型收敛情况，于是从公式角度来理解一下该指标的意义。</p>
<h2 id="Perplexity定义"><a href="#Perplexity定义" class="headerlink" title="Perplexity定义"></a>Perplexity定义</h2><p>PPL是用在自然语言处理领域（NLP）中，衡量语言模型好坏的指标。它主要是根据每个词来估计一句话出现的概率，并用句子长度作normalize，公式为</p>
<p><img src="https://img-blog.csdn.net/20171224134258243" alt="img"></p>
<p>S代表sentence，N是句子长度，p(wi)是第i个词的概率。第一个词就是 p(w1|w0)，而w0是START，表示句子的起始，是个占位符。</p>
<p>这个式子可以这样理解，PPL越小，p(wi)则越大，一句我们期望的sentence出现的概率就越高。</p>
<p>还有人说，Perplexity可以认为是average branch factor（平均分支系数），即预测下一个词时可以有多少种选择。别人在作报告时说模型的PPL下降到90，可以直观地理解为，在模型生成一句话时下一个词有90个合理选择，可选词数越少，我们大致认为模型越准确。这样也能解释，为什么PPL越小，模型越好。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/12/Python/2019-12-12-MapReduce/">Python/2019-12-12-MapReduce</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/BigData-Python/">BigData, Python</a></span><div class="content"><p>Ref: <a href="https://zhuanlan.zhihu.com/p/62135686" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/62135686</a></p>
<h1 id="Ref1"><a href="#Ref1" class="headerlink" title="Ref1"></a>Ref1</h1><h2 id="一、MapReduce是什么"><a href="#一、MapReduce是什么" class="headerlink" title="一、MapReduce是什么"></a>一、MapReduce是什么</h2><ol>
<li>MapReduce是一种分布式计算框架 ，以一种可靠的，具有容错能力的方式并行地处理上TB级别的海量数据集。主要用于搜索领域，解决海量数据的计算问题。</li>
<li>MR有两个阶段组成：Map和Reduce，用户只需实现map()和reduce()两个函数，即可实现分布式计算。</li>
</ol>
<h2 id="二、MapReduce做什么"><a href="#二、MapReduce做什么" class="headerlink" title="二、MapReduce做什么"></a>二、MapReduce做什么</h2><ol>
<li>MapReduce框架由Map和Reduce组成。</li>
<li>Map()负责把一个大的block块进行切片并计算。</li>
<li>Reduce() 负责把Map()切片的数据进行汇总、计算。</li>
</ol>
<h2 id="三、MapReduce怎么做"><a href="#三、MapReduce怎么做" class="headerlink" title="三、MapReduce怎么做"></a>三、MapReduce怎么做</h2><p><img src="https://pic1.zhimg.com/80/v2-956054759aea4352a795452e31754ef0_hd.jpg" alt="img"></p>
<ol>
<li>第一步对输入的数据进行切片，每个切片分配一个map()任务，map()对其中的数据进行计算，对每个数据用键值对的形式记录，然后输出到环形缓冲区（图中sort的位置）。</li>
<li>map（）中输出的数据在环形缓冲区内进行快排，每个环形缓冲区默认大小100M，当数据达到80M时（默认），把数据输出到磁盘上。形成很多个内部有序整体无序的小文件。</li>
<li>框架把磁盘中的小文件传到Reduce()中来，然后进行归并排序，最终输出。</li>
</ol>
<h2 id="四、要点是什么"><a href="#四、要点是什么" class="headerlink" title="四、要点是什么"></a>四、要点是什么</h2><ol>
<li>MapReduce将输入的数据进行逻辑切片，一片对应一个Map任务</li>
<li>Map以并行的方式处理切片</li>
<li>框架对Map输出进行排序，然后发给Reduce</li>
<li>MapReduce的输入输出数据处于同一个文件系统（HDFS）</li>
<li>框架负责任务调度、任务监控、失败任务的重新执行</li>
<li>框架会对键和值进行序列化，因此键和值需要实现writable接口，框架会对键排序，因此必须实现writableComparable接口。</li>
</ol>
<h2 id="五、MapReduce原语"><a href="#五、MapReduce原语" class="headerlink" title="五、MapReduce原语"></a>五、MapReduce原语</h2><p>MapReduce原语：“相同”key的键值对为一组调用一次Reduce方法，方法内迭代这组数据进行计算。</p>
<h1 id="Ref2"><a href="#Ref2" class="headerlink" title="Ref2"></a>Ref2</h1><p><a href="https://www.jianshu.com/p/6b6a42a0740c" target="_blank" rel="noopener">https://www.jianshu.com/p/6b6a42a0740c</a></p>
<h5 id="1-mapreduce-简介"><a href="#1-mapreduce-简介" class="headerlink" title="1. mapreduce 简介"></a>1. mapreduce 简介</h5><p>mapreduce源自google的一篇文章，将海量数据处理的过程拆分为map和reduce。mapreduce 成为了最早的分布式计算框架，这样即使不懂的分布式计算框架的内部运行机制的用户，也可以利用分布式的计算框架实现分布式的计算，并在hadoop上面运行。</p>
<h5 id="1-设计思想"><a href="#1-设计思想" class="headerlink" title="1. 设计思想"></a>1. 设计思想</h5><p>hadoop 文件系统 ，提供了一个分布式的文件系统，但是hadoop文件系统读写的操作都涉及到大量的网络的操作，并不能很好的完成实时性比较强的任务。</p>
<p>但是hadoop可以给上面的应用提供一个很好的支持。比如hadoop文件系统上面可以运行mapreduce。mapreduce是一个计算的框架，mapreduce是一个分布式的计算框架，这样mapreduce利用分布式的文件系统，将不同的机器上完成不同的计算，然后就计算结果返回。这样很好的利用了分布式的文件系统。</p>
<p>数据分布式的存储，然后计算的时候，分布式的计算，然后将结果返回。这样的好处就是不会涉及到大量的网络传输数据。</p>
<p>不知道在哪里看见一句话，觉得很好，记了下来。大数据设计的一个基本的思想是<strong>将计算的任务推送到数据所在的地方，而不是反过来。</strong></p>
<h5 id="2-Mapreduce-的架构"><a href="#2-Mapreduce-的架构" class="headerlink" title="2. Mapreduce 的架构"></a>2. Mapreduce 的架构</h5><p>mrappmaster（管理节点）<br> Maptask（多个）<br> reducetask（多个）</p>
<p>mapreduce 的计算过程，举一个例子 wordcount （单词计数的例子）比如说有一个文件 ，文件内容：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">good better best never it rest </span><br><span class="line">till good <span class="keyword">is</span> better and better <span class="keyword">is</span> best</span><br></pre></td></tr></table></figure>

<p>那么第一步 先map，map的流程是，将单词以空格来切分，然后建立一个key-value的map。</p>
<p>得到的结果是：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">good    <span class="number">1</span></span><br><span class="line">better  <span class="number">1</span></span><br><span class="line">best    <span class="number">1</span></span><br><span class="line">never   <span class="number">1</span></span><br><span class="line">it      <span class="number">1</span></span><br><span class="line">rest    <span class="number">1</span></span><br><span class="line">till    <span class="number">1</span></span><br><span class="line">good    <span class="number">1</span></span><br><span class="line"><span class="keyword">is</span>      <span class="number">1</span></span><br><span class="line">better  <span class="number">1</span></span><br><span class="line">and     <span class="number">1</span></span><br><span class="line">better  <span class="number">1</span></span><br><span class="line"><span class="keyword">is</span>      <span class="number">1</span></span><br><span class="line">best    <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>上面这个map的结果，相当于给每一个每一个单词都建立一个字典，key就是单词本身，value是个数。</p>
<p>第二步是reduce：<br> reduce是将一致的单词，发送个同一个reduce节点。在同一个reduce节点上面，这个reduce节点，负责将相同的key合并再一起。</p>
<p>这样就完成的单词的计数。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4717565-0afa417b7248b948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/767/format/webp" alt="img"></p>
<p>image.png</p>
<h6 id="这里存在几个问题："><a href="#这里存在几个问题：" class="headerlink" title="这里存在几个问题："></a>这里存在几个问题：</h6><p><strong>Q1:</strong> reduce的方式是将一个类型的key，送给同一个节点。比如说，把good都送给第一个节点。till送给第二个节点。那么如果做到这一点呢？</p>
<p>答：使用hash表的方式，一个key，放在hash表里面，就会产生一个为一个code（java 里面的数据结构是 hashcode），然后再给它取余数。比如机器有四个节点，做reduce，那么就取余4，这样计算的任务就分给四台机器。这个就是shuffl机制。（shuffl就是洗牌的意思）（这个算法其实就是<strong>哈希取模</strong>的算法）</p>
<p><strong>Q2:</strong> map 执行完成之后，中间结果保存在哪里？<br> map函数输出的中间结果key/value数据在内存中进行缓存，然后周期性的写入磁盘。每个map函数在写入磁盘之前，通过哈希函数，将自己的key/value对分割成R份。（R是reduce的个数 哈希函数一般是 用key对r进行哈希取模，这样将map函数的中间数据分割成r份，每一份分给一个reduce）。<strong>当某个reduce任务的worker接收到master的通知，其通过rpc远程调用 将map任务产生的m份属于自己的文件远程拉取到本地。</strong></p>
<p><strong>mapreduce的计算特点以及不足：</strong><br> mapreduce的计算框架的优点是，极强的扩展能力，可以在数千台机器上并发的执行。其次，有很好的容错性，另外，就是向上的接口简洁。用户只需要写map和reduce函数，即可完成大规模数据的并行处理。</p>
<p><strong>mapreduce的缺点：</strong><br> mapreduce并不适合对实时性要求比较高的场景，比如交互式查询或者是流式计算。另外，也不适合迭代类的计算（比如机器学习类的应用）。</p>
<p>原因：<br> mapreduce的启动时间比较长，对于批处理的任务，这个问题并不算大。但是对于实时性比较高的任务，其启动时间长的缺点就很不合适了。</p>
<p>mapreduce一次执行的过程里面，往往涉及到多出磁盘读写，以及网络的传输。对于迭代的任务，这样很好的开销需要很多次，明显降低了效率。</p>
<p>而Storm和Spark，一个是流式计算的框架，一个是机器学习的框架。他们更适合解决这类型的任务。</p>
<p>Demo：<br> 一个利用mapreduce思想单词计数的实例：<a href="https://www.jianshu.com/p/59ebf5a36ee5" target="_blank" rel="noopener">http://www.jianshu.com/p/59ebf5a36ee5</a></p>
<p>参考：</p>
<ol>
<li>google的mapreduce 论文</li>
<li>《hadoop权威指南》</li>
<li>《hadoop 海量数据处理》</li>
</ol>
<p>作者：zhaozhengcoder<br>链接：<a href="https://www.jianshu.com/p/6b6a42a0740c" target="_blank" rel="noopener">https://www.jianshu.com/p/6b6a42a0740c</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/11/CVs/2019-12-11-CNN%20&amp;%20RNN%20Review%20&amp;%20Prep/">CVs/2019-12-11-CNN &amp; RNN Review &amp; Prep</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AI/">AI</a></span><div class="content"><blockquote>
<p>Two stages: RPN for localization, then classification &amp; bbox regression on proposals</p>
<p>Single shot: classification + bbox regression at one time</p>
</blockquote>
<h3 id="RCNN"><a href="#RCNN" class="headerlink" title="RCNN"></a>RCNN</h3><ul>
<li><p>~2000 forward passes for each image</p>
</li>
<li><p>Train 3 models seperately</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdd7ffqcltj30pi0ku17e.jpg" alt="image-20200331164611434" style="zoom:50%;" />
</li>
<li><p>Selective search(texture, adjecent color, and intensity) to clustering pixeles as RPN function, and then feed into AlexNet to extract embeddings. </p>
</li>
<li><p>SVM to classify each bbox into categoies.</p>
</li>
<li><p>linear regression on bbox for tighter bbox.</p>
</li>
</ul>
<h3 id="SPP-Net"><a href="#SPP-Net" class="headerlink" title="SPP Net"></a>SPP Net</h3><p>1.結合空間金字塔方法實現CNNs的多尺度輸入。<br>SPP Net的第一個貢獻就是在最後一個卷積層後，接入了金字塔池化層，保證傳到下一層全連線層的輸入固定。<br>換句話說，在普通的CNN機構中，輸入影象的尺寸往往是固定的（比如224*224畫素），輸出則是一個固定維數的向量。SPP Net在普通的CNN結構中加入了ROI池化層（ROI Pooling），使得網路的輸入影象可以是任意尺寸的，輸出則不變，同樣是一個固定維數的向量。</p>
<p>簡言之，CNN原本只能固定輸入、固定輸出，CNN加上SSP之後，便能任意輸入、固定輸出。神奇吧？</p>
<p>ROI池化層一般跟在卷積層後面，此時網路的輸入可以是任意尺度的，在SPP layer中每一個pooling的filter會根據輸入調整大小，而SPP的輸出則是固定維數的向量，然後給到全連線FC層。<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdd8d9rgnxj30al0750sy.jpg" alt="img"><br>2.只對原圖提取一次卷積特徵<br>在R-CNN中，每個候選框先resize到統一大小，然後分別作為CNN的輸入，這樣是很低效的。<br>而SPP Net根據這個缺點做了優化：只對原圖進行一次卷積計算，便得到整張圖的卷積特徵feature map，然後找到每個候選框在feature map上的對映patch，將此patch作為每個候選框的卷積特徵輸入到SPP layer和之後的層，完成特徵提取工作。</p>
<p>如此這般，R-CNN要對每個區域計算卷積，而SPPNet只需要計算一次卷積，從而節省了大量的計算時間，比R-CNN有一百倍左右的提速。</p>
<h3 id="Fast"><a href="#Fast" class="headerlink" title="Fast"></a>Fast</h3><ul>
<li><p>ROI pool to share process</p>
</li>
<li><p>Search selective algorithm is computed base on the output feature map of the previous step. Then, ROI pooling layer is used to ensure the standard and pre-defined output size.</p>
</li>
<li><p>These valid outputs are passed to a fully connected layer as inputs. Finally, two output vectors are used to predict the observed object with a softmax classifier and adapt bounding box localisations with a linear regressor.</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gddbgk1y3dj30in097my5.jpg" alt="img"></p>
</li>
</ul>
<h3 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster RCNN"></a>Faster RCNN</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdd7vl10thj30om0l8q4a.jpg" alt="image-20200331165148305"></p>
<h4 id="VGG-backbone"><a href="#VGG-backbone" class="headerlink" title="VGG backbone"></a><code>VGG</code> backbone</h4><ul>
<li><p>VGG: Input 224x224, therefore, 224/2^4 = 14, 14x14 for conv-5 (ch-512, same as conv-4),  13 conv, 13 ReLU, 4 Pooling</p>
</li>
<li><p>Faster RCNN’s image size :  ==&gt; 800x600 (image’s input by python ‘s cv2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># reshape network inputs</span><br><span class="line"> net.blobs[&#39;data&#39;].reshape(*(blobs[&#39;data&#39;].shape))</span><br></pre></td></tr></table></figure>

<p>As we can see, the input blob <code>&#39;data&#39;</code> is reshaped according to the input image size. Once you <code>forward</code> caffe will reshape all consequent blobs according to the input shape；　<code>*</code> means convert passed argument from tuple to positional parameters</p>
</li>
<li><p>RPN: 3x3x512, as each point fuses 3x3 info arounding it. and then calc + &amp; - anchors as well as bbox regression shift, and then calc proposals;</p>
<p><code>ROI Pooling</code> extract <code>proposal feature</code> from <code>feature map</code>for FC and softmax</p>
</li>
<li><p>9 anchors for each point –&gt; + &amp; -</p>
</li>
<li><p>TRAINING: 128 + anchors and 128 - anchors</p>
<ul>
<li>Suitable Anchors:</li>
</ul>
</li>
</ul>
<p><img src="https://www.zhihu.com/equation?tex=%5Ctext%7Bceil%7D(800%2F16)+%5Ctimes+%5Ctext%7Bceil%7D(600%2F16)+%5Ctimes+9%3D50%5Ctimes38+%5Ctimes9%3D17100" alt="[公式]"></p>
<blockquote>
<p><a href="https://github.com/rbgirshick/py-faster-rcnn/tree/master/models/pascal_voc/VGG16/faster_rcnn_end2end" target="_blank" rel="noopener">https://github.com/rbgirshick/py-faster-rcnn/tree/master/models/pascal_voc/VGG16/faster_rcnn_end2end</a></p>
</blockquote>
<p>那么为何要在softmax前后都接一个reshape layer？其实只是为了便于softmax分类，至于具体原因这就要从caffe的实现形式说起了。在caffe基本数据结构blob中以如下形式保存数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob&#x3D;[batch_size, channel，height，width]</span><br></pre></td></tr></table></figure>

<p>对应至上面的保存positive/negative anchors的矩阵，其在caffe blob中的存储形式为[1, 2x9, H, W]。而在softmax分类时需要进行positive/negative二分类，所以reshape layer会将其变为[1, 2, 9xH, W]大小，即单独“腾空”出来一个维度以便softmax分类，之后再reshape回复原状。贴一段caffe softmax_loss_layer.cpp的reshape函数的解释，非常精辟：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Number of labels must match number of predictions; "</span></span><br><span class="line"><span class="string">"e.g., if softmax axis == 1 and prediction shape is (N, C, H, W), "</span></span><br><span class="line"><span class="string">"label count (number of labels) must be N*H*W, "</span></span><br><span class="line"><span class="string">"with integer values in &#123;0, 1, ..., C-1&#125;."</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>soomth-L1</li>
<li>ROI pooliing 7x7</li>
</ul>
<h4 id="for-ZF-backbone"><a href="#for-ZF-backbone" class="headerlink" title="*for ZF backbone *"></a>*for <code>ZF</code> backbone *</h4><p>==&gt; ch-256 before RPN</p>
<h3 id="★-比較-R-CNN-v-s-Fast-v-s-Faster"><a href="#★-比較-R-CNN-v-s-Fast-v-s-Faster" class="headerlink" title="★ 比較 R-CNN v.s. Fast v.s. Faster"></a>★ 比較 R-CNN v.s. Fast v.s. Faster</h3><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdddgum6x0j31jk0esacq.jpg" alt="img" style="zoom:67%;" />



<hr>
<h3 id="YOLO-v1"><a href="#YOLO-v1" class="headerlink" title="YOLO v1"></a>YOLO v1</h3><ul>
<li><p>45FPS</p>
</li>
<li><p>Can we just out bbox (x,y,w,h) and (c) ? But we found as objected to be detected increase, output dimension of model also increase, not able to be determined.</p>
<p>==&gt; YOLO does this by gridding image into grids, within each of which being able to output class and bbox.</p>
</li>
<li><p>7x7 grids on image, 30 channels, as No RPN, just use a big net to catch all fishes</p>
</li>
<li><p>2 predictor for each cell.</p>
</li>
<li><p><strong>Q: If class prediction is not sharing, can one cell predict two obj?</strong></p>
<ul>
<li>No. In this way,  how do the two predictor divide their works?</li>
<li>Faster RCNN OK because of anhchors and IOU w/ GT, which got introduced in YOLO v2</li>
</ul>
</li>
<li><p><strong>Why 2 bounding boxes?</strong></p>
<ul>
<li>Predictor with bigger IOU with GT while training, is responsible for detecting the corresponding object.</li>
</ul>
</li>
<li><p>x, y means shift relative to cell’s upper-left corner; w, h relative to the whole image</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gamijfkmaej30oy0iy77z.jpg" alt="image-20200106075944588"></p>
</li>
<li><p>confidence = <em>Pr(Object) x IOU</em>,  IOU is calculated during training, Pr(Object) is bool</p>
<p>So, Pr(Classi|Object) x <em>Pr(Object) x IOU</em> , Pr(Classi|Object) is meaningful only when Pr(Object) is not 0.</p>
</li>
</ul>
<p>Ref: <a href="https://zhuanlan.zhihu.com/p/37850811" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37850811</a></p>
<hr>
<h3 id="YOLO-v2"><a href="#YOLO-v2" class="headerlink" title="YOLO v2"></a>YOLO v2</h3><ul>
<li><p>input: 416x416 ==&gt; 13 x 13</p>
</li>
<li><p>No FC (YOLO v1 has FC to turn 1024x7x7 into 30x7x7)</p>
</li>
<li><p>5 Anchor, so that <strong>able to predict not only one obj for each cell</strong>, but 5</p>
</li>
<li><p>BN – quickly converge, and for regularization</p>
</li>
<li><p>Fully convolutional network architecture, so any size of image.</p>
</li>
<li><p>Skipping <code>reorg</code> layer –  after conv5-5, making gradient able forward. </p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gamo1nin68j30u60700ul.jpg" alt="image-20200106111017191"></p>
</li>
<li><p>Prediction:<br>(4 + 1 + num_class) for <code>each anchor</code>。Use sigmoid to make value btw 0~1. Use exponential for scaling.</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gamoddpf2zj30um0ta140.jpg" alt="image-20200106112133343"></p>
</li>
<li><p>anchor with largest IOU (by moving both of anchor and GT_box to upper-left corner) to predict correcponding obj</p>
</li>
<li><p>Loss: </p>
<ul>
<li>anchor predicting obj xywh: L2</li>
<li>anchor not predicing obj xywh: for correct anchor’s xywh</li>
<li>anchor predicting obj confidence: IOU btw predicted bbox and GT bbox</li>
<li>anchor not predicing obj confidence: for correct anchor’s xywh</li>
</ul>
</li>
<li><p>Multi-scale:</p>
<p>[320,320]，[416,416]和[512,512]，==&gt; grids: [10,10], [13,13], [16,16]. </p>
<p>During training, every 10 batches, one size btw 320x320 ~ 608x608 is chosen</p>
</li>
</ul>
<p>Ref: <a href="https://zhuanlan.zhihu.com/p/40659490" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40659490</a></p>
<hr>
<h3 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h3><p>prototxt: <a href="https://github.com/intel/caffe/blob/master/models/intel_optimized_models/ssd/VGGNet/VOC0712/SSD_300x300/deploy.prototxt" target="_blank" rel="noopener">https://github.com/intel/caffe/blob/master/models/intel_optimized_models/ssd/VGGNet/VOC0712/SSD_300x300/deploy.prototxt</a></p>
<ul>
<li><p>as YOLO, turn <code>detection</code> problem into <code>regression</code> problem</p>
</li>
<li><p>as FasterRCNN’s anchor, proposed <code>prior box</code>,  for each feature map</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gamqauu7ioj30l402smxd.jpg" alt="image-20200106122821151"></p>
<p>By this formula, Prior Box size could be determined for each feature map together with <code>aspect ratio</code></p>
<p>m: total feature maps adopted</p>
<ul>
<li><p><code>default box</code> : abstract concept of <code>prior box</code></p>
</li>
<li><p><code>prior box</code>: adopted during training, the actually chosen default box for training</p>
</li>
<li><p>for <code>k default box</code> on their own feature maps: k x  (c+4) x  m x n</p>
<ul>
<li><p>for confidence’s output: c x k x m x n,<br>c x m x n for each of the k default box </p>
<p>if 20 classes, then we have </p>
</li>
<li><p>for localization’s output: 4 x k x m x n<br>4 x m x n for each of the k default box </p>
</li>
<li><p>All prior box amount:<br>$$<br>38x38x4 + 19x19x6 +10x10x6 + 5x5x6 + 3x3x4 +1x1x4 = 8732<br>$$<br>k x (20+1), if k is 6 for each prior box; thus, 6x21 = 126 kernels<br>k x 4, if k is 6 for each prior box; thus, 6x4 = 24 kernels</p>
</li>
<li><p>TRAINING to make prior box regress to GT box </p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>as FPN, use Pyramidal Feature Hierarchy</p>
</li>
<li><p>DIDN’T generate RPN, thus speed-up</p>
</li>
<li><p>VGG-16 as backbone, the final 2 FC were turned into conv layers</p>
</li>
<li><p>Permute: 32x19x19x24 ==&gt; 32x24x19x19</p>
<p>Flatten: 32x19x19x24 ==&gt; 32x8664, where 32 is batch_size</p>
<p>mbox_priorbox – for training only</p>
<p>mbox_loc</p>
<p>mbox_conf</p>
</li>
<li><p><strong>Sample augmentation</strong></p>
</li>
<li><p><strong>+/- sampling</strong></p>
<p>Match <code>prior box</code> and <code>GT</code> according to IOU (Jaccard Overlap). </p>
<p>+ prior box  : matching to GT</p>
<p>- prior box : not mathcing to GT</p>
<p>and soft all - prior boxes according to classificatin loss, to control + : -  is around 1 : 3</p>
</li>
<li><p>GT : each GT has it mapping anchor. anchors are mapped into original image to match GT box</p>
<img src="https://tva1.sinaimg.cn/large/006tNbRwly1gams525z5sj30ha0f67ap.jpg" alt="image-20200106133152958" style="zoom:50%;" />
</li>
<li><p>input 300x300, pooling stride 2, thus conv4_3 length is 38, keep all left equals to 19, and final feature-map’s length is 10</p>
</li>
<li><p><strong>Loss</strong></p>
<ul>
<li>loc-loss: smooth-L1 loss as Faster-RCNN</li>
<li>conf-loss: softmax loss for each class</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gampfyf6l8j31200ju46v.jpg" alt="image-20200106115837659"></p>
<p>ref: <a href="https://www.cnblogs.com/xuanyuyt/p/7222867.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuanyuyt/p/7222867.html</a></p>
<hr>
<h3 id="FPN-–-didn’t-dig-into-this-too-much"><a href="#FPN-–-didn’t-dig-into-this-too-much" class="headerlink" title="FPN – didn’t dig into this too much."></a>FPN – didn’t dig into this too much.</h3><h3 id="梯度消失主角"><a href="#梯度消失主角" class="headerlink" title="梯度消失主角"></a>梯度消失主角</h3><ul>
<li>Sigmoid邊緣區</li>
</ul>
<h3 id="Why-ReLU-Better-than-Sigmoid"><a href="#Why-ReLU-Better-than-Sigmoid" class="headerlink" title="Why ReLU Better than Sigmoid?"></a>Why ReLU Better than Sigmoid?</h3><ul>
<li><p>一方面，ReLU比sigmoid效果好的分析都是基于深度神经网络的前提，比如网络足够深时<strong>sigmoid会有明显的梯度消失问题，如果是浅层神经网络的话这些问题并不存在</strong>。另一方面，它们的用处不同，sigmoid输出范围是01之间，可以当作概率。深度神经网络中sigmoid可以用作门控单元（比如LSTM的三种门都是sigmoid）或attention（比如SENet中excitation部分），这些ReLU并不能取代。</p>
</li>
<li><p>说白了还是具体问题具体分析。如果神经网络是进行二分类，你用relu做输出层激励函数，你的输出是不是很难控制？如果你的神经网络层数很深，你用sigmoid，反向传播过程是不是会有梯度消失？现在sigmoid更多的情况下，在小型神经网络和二分类型的输出层中出现的比较多，relu效果好不代表在任何应用条件下都好</p>
</li>
<li><p>隐含层就放心用Relu吧,</p>
<ul>
<li>relu的好处是可以解决梯度消失问题</li>
<li>sigmoid的好处是可以把输入缩放到0–1之前，并且连续没有绝对的好与坏，具体情况具体分析</li>
</ul>
</li>
<li><p>sigmoid和tanh的gradient在饱和区域非常平缓，接近于0，很容易造成vanishing gradient的问题，减缓收敛速度。vanishing gradient在网络层数多的时候尤其明显，是加深网络结构的主要障碍之一。</p>
</li>
<li><p>Relu的另一个优势是在生物上的合理性, with 0s so sparse network，它是单边的，相比sigmoid和tanh，更符合生物神经元的特征。</p>
</li>
<li><p>Relu的另一个优势是在生物上的合理性，它是单边的，相比sigmoid和tanh，更符合生物神经元的特征。</p>
</li>
</ul>
<h3 id="Why-Non-linear"><a href="#Why-Non-linear" class="headerlink" title="Why Non-linear"></a>Why Non-linear</h3><ul>
<li>or you can just use LR… same meaning.</li>
</ul>
<h3 id="Focal-Loss"><a href="#Focal-Loss" class="headerlink" title="Focal Loss"></a>Focal Loss</h3><h3 id="Optimization-Functions"><a href="#Optimization-Functions" class="headerlink" title="Optimization Functions"></a>Optimization Functions</h3><ul>
<li>SGD =&gt; momentum, to make local minimum to global min</li>
<li>AdaGrad: 衰減 α,  </li>
</ul>
<p>Identify class <strong>imbalance</strong> as the primary obstacle preventing one-stage object detectors from surpassing top-performing, two-stage methods, such as Faster R-CNN variants. To address this, we propose the focal loss which applies a modulating term to the cross entropy loss in order to focus learning on hard examples and down-weight the numerous easy negatives.</p>
<p>ref:</p>
<p><a href="https://medium.com/@chih.sheng.huang821/機器學習-基礎數學-三-梯度最佳解相關算法-gradient-descent-optimization-algorithms-b61ed1478bd7" target="_blank" rel="noopener">https://medium.com/@chih.sheng.huang821/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92-%E5%9F%BA%E7%A4%8E%E6%95%B8%E5%AD%B8-%E4%B8%89-%E6%A2%AF%E5%BA%A6%E6%9C%80%E4%BD%B3%E8%A7%A3%E7%9B%B8%E9%97%9C%E7%AE%97%E6%B3%95-gradient-descent-optimization-algorithms-b61ed1478bd7</a></p>
<ul>
<li><h5 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a><strong>Adam</strong></h5><p>Adam全名Adaptive Moment Estimation。剛剛介紹的Momentum是「計算參數更新方向前會考慮前一次參數更新的方向」， RMSprop則是「在學習率上依據梯度的大小對學習率進行加強或是衰減」。</p>
<p><strong><em>Adam則是兩者合併加強版本(Momentum+RMSprop+各自做偏差的修正)。</em></strong></p>
</li>
</ul>
<h3 id="MobileNet"><a href="#MobileNet" class="headerlink" title="MobileNet"></a>MobileNet</h3><ul>
<li>Explanation:</li>
</ul>
<h3 id="MobileNet-v2"><a href="#MobileNet-v2" class="headerlink" title="MobileNet v2"></a>MobileNet v2</h3><h3 id="ShuffleNet"><a href="#ShuffleNet" class="headerlink" title="ShuffleNet"></a>ShuffleNet</h3><h3 id="1x1"><a href="#1x1" class="headerlink" title="1x1"></a>1x1</h3><h3 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h3><ul>
<li>To solve what problem?</li>
<li>Explanation:</li>
<li>Keywords:<ul>
<li>Downsampling</li>
</ul>
</li>
</ul>
<h3 id="Mask-RCNN"><a href="#Mask-RCNN" class="headerlink" title="Mask RCNN"></a>Mask RCNN</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdnuk0bzxaj31aw0kqtrn.jpg" alt="image-20200409214203203"></p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdnv8pvmiwj315q09qai1.jpg" alt="image-20200409220551821"></p>
<p><strong>双线性插值</strong></p>
<p>双线性插值本质上就是在两个方向上做线性插值。</p>
<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200409221718377.png" alt="image-20200409221718377" style="zoom: 33%;" />

<blockquote>
<p>如图，假设我们想得到P点的插值，我们可以先在x方向上，对Q11和Q21 之间做线性插值得到R1 ，R2 同理可得。然后在y方向上对R1和R2 进行线性插值就可以得到最终的P。其实知道这个就已经理解了双线性插值的意思了，如果用公式表达则如下（注意 f 前面的系数看成权重就很好理解了）。</p>
<p>下面通过一个例子来讲解ROI Align操作。如下图所示，虚线部分表示feature map，实线表示ROI，这里将ROI切分成2x2的单元格。如果采样点数是4，那我们首先将每个单元格子均分成四个小方格（如红色线所示），每个小方格中心就是采样点。这些采样点的坐标通常是浮点数，所以需要对采样点像素进行双线性插值（如四个箭头所示），就可以得到该像素点的值了。然后对每个单元格内的四个采样点进行maxpooling，就可以得到最终的ROIAlign的结果。</p>
</blockquote>
<img src="/Users/joe/Library/Application Support/typora-user-images/image-20200409221825219.png" alt="image-20200409221825219" style="zoom: 33%;" />

<blockquote>
<p>需要说明的是，在相关实验中，作者发现将采样点设为4会获得最佳性能，甚至直接设为1在性能上也相差无几。事实上，ROI Align 在遍历取样点的数量上没有ROIPooling那么多，但却可以获得更好的性能，这主要归功于解决了misalignment的问题。</p>
<p>作者：数据智能谷<br>链接：<a href="https://www.jianshu.com/p/a5c46271dc9e" target="_blank" rel="noopener">https://www.jianshu.com/p/a5c46271dc9e</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="RF-Receptive-Field"><a href="#RF-Receptive-Field" class="headerlink" title="RF (Receptive Field)"></a>RF (Receptive Field)</h3><ul>
<li><p>Top-Down (Easy!)</p>
<p>VGG as e.g.</p>
<table>
<thead>
<tr>
<th>Layer</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1-1</td>
<td>1 + 1x2^1</td>
<td>3</td>
</tr>
<tr>
<td>1-2</td>
<td>1 + 2x2^1</td>
<td>5</td>
</tr>
<tr>
<td>Pooling 1</td>
<td>1 + 2x2^1 + <strong>2^0</strong></td>
<td>6</td>
</tr>
<tr>
<td>2-1</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 1x2^2</td>
<td>10</td>
</tr>
<tr>
<td>2-2</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2</td>
<td>14</td>
</tr>
<tr>
<td>Pooling 2</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong></td>
<td>16</td>
</tr>
<tr>
<td>3-1</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong> + 1x2^3</td>
<td>24</td>
</tr>
<tr>
<td>3-2</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong> + 2x2^3</td>
<td>32</td>
</tr>
<tr>
<td>3-3</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong> + 3x2^3</td>
<td>40</td>
</tr>
<tr>
<td>Pooling 3</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong> + 3x2^3 + <strong>2^2</strong></td>
<td>44</td>
</tr>
<tr>
<td>4-1</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong> + 3x2^3 + <strong>2^2</strong> + 1x2^4</td>
<td>60</td>
</tr>
<tr>
<td>4-2</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong> + 3x2^3 + <strong>2^2</strong> + 2x2^4</td>
<td>76</td>
</tr>
<tr>
<td>4-3</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong> + 3x2^3 + *<em>2^2 *</em>+ 3x2^4</td>
<td>92</td>
</tr>
<tr>
<td>Pooling 4</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong> + 3x2^3 + <strong>2^2</strong> + 3x2^4 + <strong>2^3</strong></td>
<td>100</td>
</tr>
<tr>
<td>5-1</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong> + 3x2^3 + <strong>2^2</strong> + 3x2^4 + <strong>2^3</strong> + 1x2^5</td>
<td>132</td>
</tr>
<tr>
<td>5-2</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong> + 3x2^3 + <strong>2^2</strong> + 3x2^4 + <strong>2^3</strong> + 2x2^5</td>
<td>164</td>
</tr>
<tr>
<td>5-3</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong> + 3x2^3 + <strong>2^2</strong> + 3x2^4 + <strong>2^3</strong> + 3x2^5</td>
<td>196</td>
</tr>
<tr>
<td>Pooling 5</td>
<td>1 + 2x2^1 + <strong>2^0</strong> + 2x2^2 + <strong>2^1</strong> + 3x2^3 + <strong>2^2</strong> + 3x2^4 + <strong>2^3</strong> + 3x2^5 + <strong>2^4</strong></td>
<td>212</td>
</tr>
</tbody></table>
<p>​    </p>
</li>
<li><p>Bottom Up (Hard..)</p>
</li>
</ul>
<h3 id="Gradient-Vanishing"><a href="#Gradient-Vanishing" class="headerlink" title="Gradient Vanishing"></a>Gradient Vanishing</h3><h3 id="Gradient-Explosion"><a href="#Gradient-Explosion" class="headerlink" title="Gradient Explosion"></a>Gradient Explosion</h3><p>ROI Pooling vs ROI Align</p>
<h3 id="BN-梯度消失解決原理"><a href="#BN-梯度消失解決原理" class="headerlink" title="BN 梯度消失解決原理"></a>BN 梯度消失解決原理</h3><ul>
<li>藉由改為正態分布，把data拉回sigmoid中間區那區梯度才不會太平 (兩側都沒梯度了)<ul>
<li>導數最大時是0.25, 在x==0時</li>
</ul>
</li>
</ul>
<p>ref: <a href="https://blog.csdn.net/m0_37477175/article/details/80259773" target="_blank" rel="noopener">https://blog.csdn.net/m0_37477175/article/details/80259773</a></p>
<h3 id="NMS-for-overlapping-boxes"><a href="#NMS-for-overlapping-boxes" class="headerlink" title="NMS - for overlapping boxes"></a>NMS - for overlapping boxes</h3><p>Non-Maximal Suppression</p>
<hr>
<h2 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h2><h3 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h3><ul>
<li><p>Explanation</p>
<p>The delta btw y_hat and y will be fed into another weak classifier </p>
</li>
</ul>
<h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><p><strong>SVM本身是一个二值分类器</strong></p>
<p>　　SVM算法最初是为二值分类问题设计的，当处理多类问题时，就需要构造合适的多类分类器。</p>
<p>　　目前，构造SVM多类分类器的方法主要有两类</p>
<p>　　（1）直接法，直接在目标函数上进行修改，将多个分类面的参数求解合并到一个最优化问题中，通过求解该最优化问题“一次性”实现多类分类。这种方法看似简单，但其计算复杂度比较高，实现起来比较困难，只适合用于小型问题中；</p>
<p>　　（2）间接法，主要是通过组合多个二分类器来实现多分类器的构造，常见的方法有one-against-one和one-against-all两种。</p>
<h3 id="DT"><a href="#DT" class="headerlink" title="DT"></a>DT</h3><p>smaller entropy means less wrongly classified</p>
<ul>
<li><p>ID3 (granually too small), </p>
<p>info gain  = Entropy </p>
</li>
<li><p>C4.5, </p>
</li>
<li><p>CART (binary tree, generally better than previous twos, needs some pruning sometimes)</p>
<p>with gini coefficient</p>
</li>
</ul>
<h2 id="Ensemble"><a href="#Ensemble" class="headerlink" title="Ensemble"></a>Ensemble</h2><h3 id="RF-Random-Forest"><a href="#RF-Random-Forest" class="headerlink" title="RF (Random Forest)"></a>RF (Random Forest)</h3><h3 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h3><ul>
<li><p>Bagging</p>
<p>​    to decrease variance</p>
</li>
<li><p>Boosting </p>
<p>​    to decrease bias</p>
<p>mainly to enhance weak classifier into a strong one. According to the training result from previous classifie, and then train next classifier according to new sample’s distribution.</p>
</li>
<li><p>Adaboost increase wrongly-classifed samples’ weights</p>
</li>
</ul>
<p>Ref: <a href="https://zhuanlan.zhihu.com/p/37358517" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37358517</a></p>
<hr>
<p>used to eliminate the redundant features</p>
<h3 id="SVM-1"><a href="#SVM-1" class="headerlink" title="SVM"></a>SVM</h3><ul>
<li><p>hinge loss</p>
</li>
<li><p>分类间隔为1/||w||，||w||代表向量的模</p>
</li>
<li><p>当参数C越小时，分类间隔越大，分类错误越多，趋于欠学习</p>
<p>考虑软间隔的时候，C对优化问题的影响就在于把a的范围从[0，+inf]限制到了[0,C]。C越小，那么a就会越小，目标函数拉格朗日函数导数为0可以求出w=求和ai∗yi∗xi，a变小使得w变小，因此间隔2/||w||变大</p>
</li>
</ul>
<h3 id="Decision-Tree"><a href="#Decision-Tree" class="headerlink" title="Decision Tree"></a>Decision Tree</h3><p>copied from : <a href="https://chtseng.wordpress.com/2017/02/10/決策樹-decision-trees/" target="_blank" rel="noopener">https://chtseng.wordpress.com/2017/02/10/%E6%B1%BA%E7%AD%96%E6%A8%B9-decision-trees/</a></p>
<ul>
<li>Entropy definition</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gb23fhkw46j30l710otgs.jpg" alt="image-20200119192602821"></p>
<h2 id="Gini-Index-吉尼係數"><a href="#Gini-Index-吉尼係數" class="headerlink" title="Gini Index (吉尼係數)"></a><strong>Gini Index (吉尼係數)</strong></h2><p>採用GINI Index的代表是CART tree。CART是Classification And Regression Tree的縮寫，從字面上可看出它兼具分類與迴歸兩種功能，同時支援分類(Classification)與數字預測(Regression)，由於不限制應變數與自變數的類型，因此在使用上較具彈性，是目前最為常用的決策樹方法。</p>
<p>GINI係數與INFORMATION GAIN兩者有一個最大的差別：INFORMATION GAIN一次可產生多個不同節點，而GINI係數一次僅能產生兩個，即True或False的Binary分類。</p>
<p>下方一樣以板球為例來說明：（Gini係數公式為p2+q2）</p>
<p><strong>用性別來分類：</strong> </p>
<p><img src="https://chtseng.files.wordpress.com/2017/02/3148_gxdl-o-obg.png?w=1140" alt="img"></p>
<p>Femail節點：十位女性，其中有2位打板球10位不打，Gini係數為<br>(0.2)2+(0.8)2=0.68</p>
<p>Male節點：20位男性，其中有13位打板球7位不打，Gini係數為<br>(0.65)2+(0.35)2=0.55</p>
<p>因此以性別分類的Gini係數加權後為：(10/30)<em>0.68+(20/30)</em>0.55 = 0.59。</p>
<p><strong>用班級來分類：</strong></p>
<p><img src="https://chtseng.files.wordpress.com/2017/02/3148_jsuhhmuveq1.png?w=1140" alt="img"></p>
<p>  Class IX節點：此班14位同學，其中6位打板球8位不打，因此Gini係數為<br>(0.43)2+(0.57)2=0.51</p>
<p>  Class X節點：此班16位同學，其中9位打板球7位不打，因此Gini係數為<br>(0.56)2+(0.44)2=0.51</p>
<p>因此以班級分類的決策樹，其Gini係數加權結果：(14/30)<em>0.51+(16/30)</em>0.51 = 0.51。兩樹相互比較，以性別分類的吉尼係數大於以班級分類，因此系統會採用性別來進行節點的分類。</p>
<h3 id="Naive-Bayes"><a href="#Naive-Bayes" class="headerlink" title="Naive Bayes"></a>Naive Bayes</h3><ul>
<li>特征变量X的各个维度是类别条件独立随机变量</li>
</ul>
<h3 id="One-hot"><a href="#One-hot" class="headerlink" title="One-hot"></a>One-hot</h3><p>拆成更多個不同的字段，分別表示０、１</p>
<h3 id="Categorical-特徵處理方式"><a href="#Categorical-特徵處理方式" class="headerlink" title="Categorical 特徵處理方式"></a>Categorical 特徵處理方式</h3><h3 id="感知機"><a href="#感知機" class="headerlink" title="感知機"></a>感知機</h3><p>用的是Step function</p>
<h2 id="決策樹演算法的步驟"><a href="#決策樹演算法的步驟" class="headerlink" title="決策樹演算法的步驟"></a><strong>決策樹演算法的步驟</strong></h2><ol>
<li><strong>資料設定：</strong>將原始資料分成兩組，一部分為訓練資料，一部分為測試資料</li>
<li><strong>決策樹生成：</strong>使用訓練資料來建立決策樹，而在每一個內部節點，則依據屬性選擇指標 (如：資訊理論(Information Theory)…) 來評估選擇哪個屬性做分支的依據。此又稱節點分割 (Splitting Node)</li>
<li><strong>剪枝：</strong>使用測試資料來進行決策樹修剪，將以上1~3步驟不斷重複進行，直到所有的新產生節點都是樹葉節點為止。</li>
</ol>
<p>不過決策樹很容易有「Overfitting（過度擬合）」的問題，因為我們如果沒有對樹的成長作限制，演算法最後就會為每個不同特徵值創建新的分類節點，最後將所有資料作到100%正確的分類，因此為了預防Overfitting，我們會採取下列兩種方式：設限及剪枝。</p>
<h2 id="設限"><a href="#設限" class="headerlink" title="設限"></a><strong>設限</strong></h2><ol>
<li>Minimum samples for a node split：資料數目不得小於多少才能再產生新節點。</li>
<li>Minimum samples for a terminal node (leaf)：要成為葉節點，最少需要多少資料。</li>
<li>Maximum depth of tree (vertical depth)：限制樹的高度最多幾層。</li>
<li>Maximum number of terminal nodes：限制最終葉節點的數目</li>
<li>Maximum features to consider for split：在分離節點時，最多考慮幾種特徵值。</li>
</ol>
<p><img src="https://chtseng.files.wordpress.com/2017/02/3148_vgszibb2dq.png?w=1140" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gb23urtakpj30g410pdkb.jpg" alt="image-20200119194043890"></p>
<h3 id="Training-Imbalance"><a href="#Training-Imbalance" class="headerlink" title="Training Imbalance"></a>Training Imbalance</h3><ul>
<li>Undersampling</li>
<li>Oversampling</li>
<li>SMOTE</li>
<li>圖像而言，有 Focal loss!</li>
</ul>
<h3 id="Why-Regularization-example"><a href="#Why-Regularization-example" class="headerlink" title="Why Regularization ? example?"></a>Why Regularization ? example?</h3><h3 id="Backward"><a href="#Backward" class="headerlink" title="Backward"></a>Backward</h3><hr>
<h3 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison:"></a>Comparison:</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gb20p3423tj30kf0b7dhi.jpg" alt="image-20200119175125694"></p>
<h4 id="Contrastive-loss"><a href="#Contrastive-loss" class="headerlink" title="Contrastive loss"></a>Contrastive loss</h4><p>​        2006, Yann LeCun’s paper, mainly adopted for dimension reduction, 即本来相似的样本，在经过降维（特征提取）后，两个样本仍旧相似；而原本不相似的样本，在经过降维后，两个样本仍旧不相似。同样，该损失函数也可以很好的表达成对样本的匹配程度<br>​        F = kX, as SPRING model</p>
<h4 id="Triplet-loss"><a href="#Triplet-loss" class="headerlink" title="Triplet loss"></a>Triplet loss</h4><p>​        2015, Google</p>
<p>​        三元组损失：最小化锚点和具有相同的身份的正例之间的距离，并最大化锚点和不同身份的负例之间的距离。 目标： 相同标签的两个示例使其嵌入在嵌入空间中靠近在一起，不同标签的两个示例的嵌入距离要很远 但不希望推动每个标签的训练嵌入到非常小的簇中。 唯一的要求是给出同一类的两个正例和一个负例，负例应该比正例的距离至少远margin。 这与SVM中使用的margin非常相似，这里希望每个类的簇由margin分隔。        </p>
<p>​    <strong>Triplet的选取</strong></p>
<ul>
<li><p>如何选择triplet，如何用正负例构建triplet，对模型训练的效率有很大影响。easy negative example比较容易识别，没必要训练，否则会严重降低训练效率。若都采用hard negative example，又可能会影响训练效果。</p>
</li>
<li><p>Facenet论文中采用了随机的semi-hard negative构建triplet进行训练。</p>
</li>
<li><p>基于negative example与anchor和positive距离，分为三类三元组：</p>
</li>
<li><ul>
<li>容易三元组(easy triplets)：损失为0的三元组，因为d(a,n)&gt;d(a,p)+margin</li>
<li>困难三元组(hard triplets) ：其中负例比正例更靠近锚点，即d(a,n)&lt;d(a,p)</li>
<li>半困难三元组(semi-hard triplets)：其中负例不比正例更接近锚点，但仍有大于0的损失，d(a,p)&lt;d(a,n)&lt;d(a,p)+margin</li>
</ul>
</li>
</ul>
<h4 id="Center-loss"><a href="#Center-loss" class="headerlink" title="Center loss"></a>Center loss</h4><p>Center Loss源于深圳先研院乔宇、Yandong Wen等在ECCV 2016上发表的 <a href="https://link.zhihu.com/?target=http%3A//ydwen.github.io/papers/WenECCV16.pdf">A Discriminative Feature Learning Approach for Deep Face Recognition</a>。<br><strong>判别性</strong></p>
<ul>
<li>深度学习的特征需要具有discriminative(判别性)和泛化能力，以便在没有标签预测的情况下识别新的未见类别，如一个人脸即便没有训练过也能判断类别。判别性同时表征了紧凑的类内差异和可分离的类间差异。</li>
<li>判别性特征可以通过最近邻（NN）或k近邻（k-NN）算法进行良好分类，其不一定取决于标签预测。</li>
<li>而softmax损失仅鼓励特征的可分离性，所得到的特征对于人脸识别不是足够有效的。</li>
<li>对比损失和三元组损失分别构成图像对和三元组的损失函数，然而与原样本相比，训练对或三元组的数量急剧增加，导致了网络收敛缓慢。</li>
</ul>
<p><strong>中心损失的定义</strong></p>
<ul>
<li>中心损失：为每一个类别提供一个类别中心，最小化min-batch中每个样本与该类别中心的距离，即缩小类内距离。</li>
<li>有效地表征了深度特征的类内距离，提升深度特征的判别能力，在保持不同类别的特征可分离的同时最小化类内距离是关键。公式如下，c_yi就是第yi个类别的特征中心，xi表示全连接层之前的特征，m表示mini-batch的大小</li>
</ul>
<h4 id="ArcFace-loss"><a href="#ArcFace-loss" class="headerlink" title="ArcFace loss"></a>ArcFace loss</h4><ul>
<li><p>性能高，易于编程实现，复杂性低，训练效率高</p>
</li>
<li><p>ArcFace直接优化geodesic distance margin(弧度)，因为归一化超球体中的角和弧度的对应。</p>
</li>
<li><p>为了性能的稳定，ArcFace不需要与其他loss函数实现联合监督，可以很容易地收敛于任何训练数据集。</p>
</li>
<li><p>缺点：W模型很大</p>
</li>
</ul>
<h3 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h3><ul>
<li>metric</li>
</ul>
<h3 id="seq2seq"><a href="#seq2seq" class="headerlink" title="seq2seq"></a>seq2seq</h3><p><em>Ilya Sutskever, Oriol Vinyals, Quoc V. Le, 2014, “Sequence to Sequence Learning with Neural Networks,” pp. 3104–311 in NIPS 2014</em></p>
<p>Take AlexNet for example, by eliminating softmax, we’ll be able to extract a 4096 dimension embedding.</p>
<p>Now, feed the vector into RNN, as what language translation does, it’ll generate a output sequence, the CAPTION for the image.</p>
<ul>
<li><h5 id="ImageTOseq"><a href="#ImageTOseq" class="headerlink" title="ImageTOseq"></a>ImageTOseq</h5><p>Image Caption, mean</p>
<p><em>Deep Captioning with Multimodal Recurrent Neural Networks (m-RNN) – ICLR2015, San Diego</em><br><em>by Junua Mao</em></p>
<p>Meanwhile, Oriol Vinyals, (Andrej, Fei-Fei Li) also acquired the similar conclusion.</p>
</li>
</ul>
<p>After obtaining this vector, decoder part of the network starts its processing with this fixed vector representation and at <strong>each time step of the decoder network it produces outputs</strong>. <strong>Operation stops when a special token</strong> showing the end of the sentence is produced. Distributed representations of the words are used as inputs to the encoder network. At the output side at each time step, a Word is chosen from a specific vocabulary list. At the decoder side, after decoder part a classifier network is used to produce a Word from the output at each time step. <strong>LSTM networks are used in this paper due to their capability of capturing long term relationships</strong>. Paper also shows experiments on machine translation task, which is from English to French. Simulation results reveal that presented approach outperforms existing studies.</p>
<h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p>The Encoder + Decoder mechanism based on RNN (LSTM or GRU). </p>
<p>For Image caption, it explains different region afftectin the output text series BY</p>
<p>weighing differently in X and therefore extracts important info for model making more precies judgement.</p>
<p><a href="https://zhuanlan.zhihu.com/p/31547842" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31547842</a></p>
<h3 id="Saliency-Detection"><a href="#Saliency-Detection" class="headerlink" title="Saliency Detection"></a>Saliency Detection</h3><p>The region within the image where user most care about.</p>
<p>![image-20200119174713586](/Users/joe/Library/Application Support/typora-user-images/image-20200119174713586.png)</p>
<h3 id="Reason-of-LR-as-Linear"><a href="#Reason-of-LR-as-Linear" class="headerlink" title="Reason of LR as Linear"></a>Reason of LR as Linear</h3><p>有人說，因為邏輯迴歸不是線性的，這個說法是不對的！因為我們可以把邏輯回歸的模型轉成線性的形式如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcx9msq25oj311a0b6411.jpg" alt="螢幕快照 2017-12-22 上午12.41.33"></p>
<p>主要原因很簡單，因為迴歸分析中 <img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcx9mt6yxrj300o00n08d.jpg" alt="Y"> 是已經觀察到的資料，可是邏輯迴歸中 <img src="https://s0.wp.com/latex.php?zoom=2&latex=P%28Y%3D1%7CX%29&bg=ffffff&fg=000&s=0" alt="P(https://tva1.sinaimg.cn/large/00831rSTgy1gcx9mo7366j301q00y0fi.jpg)"> 是資料裡面無法觀察到的，所以我們就沒辦法用傳統的最小平方法估計，而要採用最大概似法 (Maximum Likelihood Estimation)。至於最大概似法的原理是什麼，可以用下面這張圖很清楚的解釋。</p>
<h3 id="关于logit-回归和SVM-不正确的是（A）-机器学习-ML模型-中"><a href="#关于logit-回归和SVM-不正确的是（A）-机器学习-ML模型-中" class="headerlink" title="关于logit 回归和SVM 不正确的是（A） 机器学习 ML模型 中"></a>关于logit 回归和SVM 不正确的是（A） 机器学习 ML模型 中</h3><p>A. Logit回归本质上是一种根据样本对权值进行极大似然估计的方法，而后验概率正比于先验概率和似然函数的乘积。logit仅仅是最大化似然函数，并没有最大化后验概率，更谈不上最小化后验概率。<strong>A错误</strong><br>B. Logit回归的输出就是样本属于正类别的几率，可以计算出概率，正确<br>C. SVM的目标是找到使得训练数据尽可能分开且分类间隔最大的超平面，应该属于结构风险最小化。<br>D. SVM可以通过正则化系数控制模型的复杂度，避免过拟合。<br>@BlackEyes_SGC：<strong>Logit回归目标函数是最小化后验概率，Logit回归可以用于预测事件发生概率的大小，</strong>SVM目标是结构风险最小化，SVM可以有效避免模型过拟合。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcx9mu07mkj314s0u0tjz.jpg" alt="螢幕快照 2017-12-22 上午12.44.31"></p>
<h3 id="为什么xgboost要用泰勒展开，优势在哪里？机器学习-ML模型-难"><a href="#为什么xgboost要用泰勒展开，优势在哪里？机器学习-ML模型-难" class="headerlink" title="为什么xgboost要用泰勒展开，优势在哪里？机器学习 ML模型 难"></a>为什么xgboost要用泰勒展开，优势在哪里？机器学习 ML模型 难</h3><p>@AntZ：xgboost使用了一阶和二阶偏导, 二阶导数有利于梯度下降的更快更准. 使用泰勒展开取得函数做自变量的二阶导数形式, 可以在不选定损失函数具体形式的情况下, 仅仅依靠输入数据的值就可以进行叶子分裂优化计算, 本质上也就把损失函数的选取和模型算法优化/参数选择分开了. 这种去耦合增加了xgboost的适用性, 使得它按需选取损失函数, 可以用于分类, 也可以用于回归。<br>————————————————<br>版权声明：本文为CSDN博主「v_JULY_v」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/v_JULY_v/article/details/78121924" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/78121924</a> </p>
<h3 id="L1和L2正则先验分别服从什么分布。机器学习-ML基础-易"><a href="#L1和L2正则先验分别服从什么分布。机器学习-ML基础-易" class="headerlink" title="L1和L2正则先验分别服从什么分布。机器学习 ML基础 易"></a>L1和L2正则先验分别服从什么分布。机器学习 ML基础 易</h3><ul>
<li>L1和L2正则先验分别服从什么分布，L1是拉普拉斯分布，L2是高斯分布。</li>
<li>先验就是优化的起跑线, 有先验的好处就是可以在较小的数据集中有良好的泛化性能，当然这是在先验分布是接近真实分布的情况下得到的了，从信息论的角度看，向系统加入了正确先验这个信息，肯定会提高系统的性能。<br>对参数引入高斯正态先验分布相当于L2正则化, 这个大家都熟悉：</li>
</ul>
<h3 id="How-to-choose-K-for-K-Means-Clustering"><a href="#How-to-choose-K-for-K-Means-Clustering" class="headerlink" title="How to choose K for K-Means Clustering"></a>How to choose K for K-Means Clustering</h3><ul>
<li>sqrt(n/2) – bad</li>
<li>elbow method - Y-axis means sum(square errors)</li>
</ul>
<p><a href="https://rpubs.com/skydome20/R-Note9-Clustering" target="_blank" rel="noopener">https://rpubs.com/skydome20/R-Note9-Clustering</a></p>
<p><a href="https://www.biaodianfu.com/k-means-choose-k.html" target="_blank" rel="noopener">https://www.biaodianfu.com/k-means-choose-k.html</a></p>
<h3 id="How-to-choose-K-for-kNN"><a href="#How-to-choose-K-for-kNN" class="headerlink" title="How to choose K for kNN"></a>How to choose K for kNN</h3><ul>
<li>CV error might rise after a specific lowest value of K</li>
</ul>
<p>如果选择较小的K值，就相当于用较小的领域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大，换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；<br>如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。<br>K=N，则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的累，模型过于简单，忽略了训练实例中大量有用信息。<br>    在实际应用中，K值一般取一个比较小的数值，例如采用交叉验证法（简单来说，就是一部分样本做训练集，一部分做测试集）来选择最优的K值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">K = <span class="number">10</span></span><br><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">epochs = <span class="number">100</span></span><br><span class="line">error_histories = []</span><br><span class="line">num_val_samples = len(train_data) // K</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(K):</span><br><span class="line">    print(<span class="string">'Processing fold #'</span>, i)</span><br><span class="line">    val_data = train_data[i*num_val_samples : (i+<span class="number">1</span>)*num_val_samples]</span><br><span class="line">    val_targets = train_targets[i*num_val_samples : (i+<span class="number">1</span>)*num_val_samples]</span><br><span class="line">    </span><br><span class="line">    partial_train_data = np.concatenate( </span><br><span class="line">                         [train_data[: i*num_val_samples],</span><br><span class="line">                         train_data[(i+<span class="number">1</span>)*num_val_samples :]],</span><br><span class="line">                         axis = <span class="number">0</span>)</span><br><span class="line">    partial_train_targets = np.concatenate(</span><br><span class="line">                         [train_targets[: i*num_val_samples],</span><br><span class="line">                         train_targets[(i+<span class="number">1</span>)*num_val_samples :]],</span><br><span class="line">                         axis = <span class="number">0</span>)</span><br><span class="line">    model = build_model()</span><br><span class="line">    history = model.fit(partial_train_data,</span><br><span class="line">                        partial_train_targets,</span><br><span class="line">                        validation_data = (val_data, val_targets),</span><br><span class="line">                        epochs = epochs,</span><br><span class="line">                        batch_size = batch_size,</span><br><span class="line">                        verbose = <span class="number">1</span>)</span><br><span class="line">    mae_history = history.history[<span class="string">'val_mean_absolute_error'</span>]</span><br><span class="line">    error_histories.append(mae_history)</span><br><span class="line">    average_error = [ np.mean([x[i] <span class="keyword">for</span> x <span class="keyword">in</span> error_histories]) <span class="keyword">for</span> i <span class="keyword">in</span> range(epochs)]</span><br><span class="line"></span><br><span class="line">fr: </span><br><span class="line">  https://jason-chen<span class="number">-1992.</span>weebly.com/home/-cross-validation</span><br></pre></td></tr></table></figure>



<h3 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h3><p>Density-based spatial clustering of applications with noise</p>
<h3 id="防止过拟合"><a href="#防止过拟合" class="headerlink" title="防止过拟合,"></a>防止过拟合,</h3><p>　　过拟合的原因是算法的学习能力过强；一些假设条件（如样本独立同分布）可能是不成立的；训练样本过少不能对整个空间进行分布估计。<br>　　处理方法：</p>
<p>早停止：如在训练中多次迭代后发现模型性能没有显著提高就停止训练<br>数据集扩增：原有数据增加、原有数据加随机噪声、重采样<br>正则化<br>交叉验证<br>特征选择/特征降维<br>创建一个验证集是最基本的防止过拟合的方法。我们最终训练得到的模型目标是要在验证集上面有好的表现，而不训练集。<br>正则化可以限制模型的复杂度。</p>
<p>在训练中，我们希望在中间箭头的位置停止训练。而Early stopping就可以实现该功能，这时获得的模型泛化能力较强，还可以得到一个中等大小的w的弗罗贝尼乌斯范数。其与L2正则化相似，选择参数w范数较小的神经网络。</p>
<p>可以用L2正则化代替early stopping。因为只要训练的时间足够长，多试几个lambda。总可以得到比较好的结果。</p>
<h3 id="Early-stopping"><a href="#Early-stopping" class="headerlink" title="Early stopping:"></a>Early stopping:</h3><p>优点：只运行一次梯度下降，我们就可以找出w的较小值，中间值和较大值。而无需尝试L2正则化超级参数lambda的很多值。</p>
<p>缺点：不能独立地处理以上两个问题，使得要考虑的东西变得复杂。举例如下：</p>
<p>一般机器学习的步骤分为以上两步，第一步我们确定一个成本函数J，然后可以用梯度下降等方法去优化它；第二步我们不希望模型发生过拟合，就有正则化等方式去操作，这是一个动态的过程。但是如果采用early stopping，这就相当于用一种方式来控制两个问题的结束，这会使得问题变得复杂。如图一所示，在中间位置时，模型已经停止训练了，而成本函数还没有下降到合适的区域。</p>
<h3 id="AUC"><a href="#AUC" class="headerlink" title="AUC"></a>AUC</h3><p>二階混淆矩陣</p>
<p>有了混淆矩陣，就可以定義<strong>ROC</strong>曲線了。<strong>ROC</strong>曲線將假陽性率（FPR）定義為 X 軸，真陽性率（TPR）定義為 Y 軸。其中：</p>
<ul>
<li>TPR：在所有實際為陽性的樣本中，被正確地判斷為陽性的樣本比率。</li>
<li>FPR：在所有實際為陰性的樣本中，被錯誤地判斷為陽性的樣本比率。</li>
<li>TPR = TP / (TP + FN)</li>
<li>FPR = FP / (FP + TN)</li>
<li><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcydclzpf2j30hs0csdgb.jpg" alt="img" style="zoom:50%;" />

</li>
</ul>
<h3 id="ML-Flow"><a href="#ML-Flow" class="headerlink" title="ML Flow"></a>ML Flow</h3><p>Abstract as math problem -&gt; acquire data, pca … -&gt; feature selection -&gt; train &amp; optimize model -&gt; analyze model -&gt; deploy (time complexity, resource consumption, stability)</p>
<h3 id="Linear-vs-Non-linear-classifiers"><a href="#Linear-vs-Non-linear-classifiers" class="headerlink" title="Linear vs Non-linear classifiers"></a>Linear vs Non-linear classifiers</h3><p>非线性分类器效果拟合能力较强，不足之处是数据量不足容易过拟合、计算复杂度高、可解释性不好。<br>常见的线性分类器有：LR,贝叶斯分类，单层感知机、线性回归<br>常见的非线性分类器：决策树、RF、GBDT、多层感知机<br>SVM两种都有（看线性核还是高斯核）</p>
<h3 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h3><p>下面几种方式,随便选一个,结果基本都差不多。但是一定要做。否则可能会减慢收敛速度，影响收敛结果，甚至造成Nan等一系列问题。</p>
<p>下面的n_in为网络的输入大小，n_out为网络的输出大小，n为n_in或(n_in+n_out)*0.5</p>
<p>Xavier初始法论文：<a href="http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf" target="_blank" rel="noopener">http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf</a></p>
<p>He初始化论文：<a href="https://arxiv.org/abs/1502.01852" target="_blank" rel="noopener">https://arxiv.org/abs/1502.01852</a><br>————————————————<br>版权声明：本文为CSDN博主「v_JULY_v」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/v_JULY_v/article/details/78121924" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/78121924</a></p>
<h3 id="k-d-tree"><a href="#k-d-tree" class="headerlink" title="k-d tree"></a>k-d tree</h3><h3 id="Ave-Pooling"><a href="#Ave-Pooling" class="headerlink" title="Ave Pooling"></a>Ave Pooling</h3><p>但是average-pooling在全局平均池化操作中应用也比较广，在ResNet和Inception结构中最后一层都使用了平均池化。有的时候在模型接近分类器的末端使用全局平均池化还可以代替Flatten操作，使输入数据变成一位向量。</p>
<h3 id="Newton’s-method-for-Optimization"><a href="#Newton’s-method-for-Optimization" class="headerlink" title="Newton’s method for Optimization"></a>Newton’s method for Optimization</h3><p>牛顿法的优缺点总结：</p>
<p>优点：二阶收敛，收敛速度快；</p>
<p>缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。</p>
<p>什么是拟牛顿法（Quasi-Newton Methods）？机器学习 ML基础 中</p>
<p>@wtq1993，<a href="http://blog.csdn.net/wtq1993/article/details/51607040" target="_blank" rel="noopener">http://blog.csdn.net/wtq1993/article/details/51607040</a><br>拟牛顿法是求解非线性优化问题最有效的方法之一，于20世纪50年代由美国Argonne国家实验室的物理学家W.C.Davidon所提出来。Davidon设计的这种算法在当时看来是非线性优化领域最具创造性的发明之一。不久R. Fletcher和M. J. D. Powell证实了这种新的算法远比其他方法快速和可靠，使得非线性优化这门学科在一夜之间突飞猛进。</p>
<p>拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。如今，优化软件中包含了大量的拟牛顿算法用来解决无约束，约束，和大规模的优化问题。</p>
<h3 id="共轭梯度法？"><a href="#共轭梯度法？" class="headerlink" title="共轭梯度法？"></a>共轭梯度法？</h3><p>​    共轭梯度法是介于梯度下降法（最速下降法）与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了梯度下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hessian矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解大型非线性最优化最有效的算法之一。在各种优化算法中，共轭梯度法是非常重要的一种。其优点是所需存储量小，具有逐步收敛性，稳定性高，而且不需要任何外来参数。</p>
<h3 id="直觀理解正定、半正定矩陣-positive-definite和positive-semi-definite"><a href="#直觀理解正定、半正定矩陣-positive-definite和positive-semi-definite" class="headerlink" title="直觀理解正定、半正定矩陣　positive definite和positive semi-definite:"></a>直觀理解正定、半正定矩陣　positive definite和positive semi-definite:</h3><p>半正定与正定矩阵同意用半正定矩阵来事例：<br>首先半正定矩阵定义为: <img src="https://www.zhihu.com/equation?tex=X%5ETMX+%5Cgeq+0" alt="[公式]"><br>其中X 是向量，M 是变换矩阵</p>
<p>我们换一个思路看这个问题，矩阵变换中，<img src="https://www.zhihu.com/equation?tex=MX" alt="[公式]">代表对向量 X进行变换，我们假设变换后的向量为Y，记做<img src="https://www.zhihu.com/equation?tex=Y%3DMX" alt="[公式]">。于是半正定矩阵可以写成：<br><img src="https://www.zhihu.com/equation?tex=X%5ETY+%5Cgeq+0" alt="[公式]"></p>
<p>这个是不是很熟悉呢？ 他是两个向量的内积。 同时我们也有公式：</p>
<p><img src="https://www.zhihu.com/equation?tex=cos(%5Ctheta)+%3D+%5Cfrac%7BX%5ETY%7D%7B%7C%7CX%7C%7C*+%7C%7CY%7C%7C%7D" alt="[公式]"></p>
<p>||X||, ||Y||代表向量 X,Y的长度，<img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="[公式]">是他们之间的夹角。 于是半正定矩阵意味着<img src="https://www.zhihu.com/equation?tex=cos(%5Ctheta)%5Cgeq+0" alt="[公式]">, 这下明白了么？</p>
<p>正定、半正定矩阵的直觉代表一个向量经过它的变化后的向量与其本身的夹角小于等于90度。</p>
<h3 id="GAN-1"><a href="#GAN-1" class="headerlink" title="GAN"></a>GAN</h3><h3 id="Convolutinon-實現"><a href="#Convolutinon-實現" class="headerlink" title="Convolutinon 實現"></a>Convolutinon 實現</h3><p>img2col</p>
<p>note: <a href="https://zhuanlan.zhihu.com/p/63974249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/63974249</a></p>
<h3 id="随机森林如何处理缺失值？"><a href="#随机森林如何处理缺失值？" class="headerlink" title="随机森林如何处理缺失值？"></a>随机森林如何处理缺失值？</h3><p>方法一（na.roughfix）简单粗暴，对于训练集,同一个class下的数据，如果是分类变量缺失，用众数补上，如果是连续型变量缺失，用中位数补。<br>方法二（rfImpute）这个方法计算量大，至于比方法一好坏？不好判断。先用na.roughfix补上缺失值，然后构建森林并计算proximity matrix，再回头看缺失值，如果是分类变量，则用没有缺失的观测实例的proximity中的权重进行投票。如果是连续型变量，则用proximity矩阵进行加权平均的方法补缺失值。然后迭代4-6次，这个补缺失值的思想和KNN有些类似12。</p>
<h3 id="Why-Smooth-L1-in-Faster-amp-SSD"><a href="#Why-Smooth-L1-in-Faster-amp-SSD" class="headerlink" title="Why Smooth-L1 in Faster &amp; SSD?"></a>Why Smooth-L1 in Faster &amp; SSD?</h3><p>对于边框预测回归问题，通常也可以选择平方损失函数（L2损失），但L2范数的缺点是当存在离群点（outliers)的时候，这些点会占loss的主要组成部分。比如说真实值为1，预测10次，有一次预测值为1000，其余次的预测值为1左右，显然loss值主要由1000主宰。所以FastRCNN采用稍微缓和一点绝对损失函数（smooth L1损失），它是随着误差线性增长，而不是平方增长。</p>
<p>注意：smooth L1和L1-loss函数的区别在于，L1-loss在0点处导数不唯一，可能影响收敛。smooth L1的解决办法是在0点附近使用平方函数使得它更加平滑。</p>
<p>ref: <a href="https://zhuanlan.zhihu.com/p/48426076" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/48426076</a></p>
<p>根据fast rcnn的说法，”…… L1 loss that is less sensitive to outliers than the L2 loss used in R-CNN and SPPnet.” 也就是smooth L1 loss让loss对于离群点更加鲁棒，即：相比于L2损失函数，其对离群点、异常值（outlier）不敏感，梯度变化相对更小，训练时不容易跑飞。</p>
<h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdc5yneca2j31400g6di2.jpg" alt="img" style="zoom:67%;" />

<h3 id="★-LSTM-amp-GRU"><a href="#★-LSTM-amp-GRU" class="headerlink" title="★ LSTM &amp; GRU"></a>★ LSTM &amp; GRU</h3><p>Ref: <a href="https://kknews.cc/zh-tw/code/vegon84.html" target="_blank" rel="noopener">https://kknews.cc/zh-tw/code/vegon84.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/aV9Rj-CnJZRXRm0rDOK6gg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/aV9Rj-CnJZRXRm0rDOK6gg</a></p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdc37qy1wmj30oo0bbwf7.jpg" alt="img" style="zoom:67%;" />

<p>Ref: <a href="https://blog.floydhub.com/long-short-term-memory-from-zero-to-hero-with-pytorch/" target="_blank" rel="noopener">https://blog.floydhub.com/long-short-term-memory-from-zero-to-hero-with-pytorch/</a></p>
<p>神經元數跟參數個數</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdc734yxpjj307u00kmwy.jpg" alt="img" style="zoom:67%;" />

<p>隱向量長度應該是要比字典短不少，不過例子裡的字在字典裡長度是５，隱向量長度是10，所以　(5+10)x10 + 10 共四個 for３個gates    </p>
<p>Ref: <a href="https://www.cnblogs.com/wushaogui/p/9176617.html" target="_blank" rel="noopener">https://www.cnblogs.com/wushaogui/p/9176617.html</a>, <a href="https://blog.csdn.net/Hello_word5/article/details/88918075" target="_blank" rel="noopener">https://blog.csdn.net/Hello_word5/article/details/88918075</a></p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdc7csb4tuj30u01dn0x9.jpg" alt="img"></p>
<h3 id="Word-Representation-to-Word-Embedding"><a href="#Word-Representation-to-Word-Embedding" class="headerlink" title="Word Representation to Word Embedding"></a>Word Representation to Word Embedding</h3><h2 id="Race-Condition"><a href="#Race-Condition" class="headerlink" title="Race Condition"></a>Race Condition</h2><h1 id="為什麼-a-會發生-race-condition"><a href="#為什麼-a-會發生-race-condition" class="headerlink" title="為什麼 a++ 會發生 race condition"></a>為什麼 a++ 會發生 race condition</h1><p>當你寫了 <code>a++</code> 時電腦實際上做了三件事：</p>
<ol>
<li>CPU 把 a 的值取出來</li>
<li>把剛剛取得的值加 1</li>
<li>把運算的結果存回變數 a</li>
</ol>
<p>但萬一你有<strong>多核 CPU</strong> 就有可能會這樣：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0guxph51j301o00r3y9.jpg" alt="img"></p>
<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0gux2c7vj30kp09c0ss.jpg" alt="img" style="zoom:33%;" />

<p>兩個 CPU 同時去拿變數 a 的值，各自加 1 後存回，導致 a 只被加了一次，因此結果（9903）會小於正確的 10000</p>
<h2 id="解法：互斥鎖"><a href="#解法：互斥鎖" class="headerlink" title="解法：互斥鎖"></a>解法：互斥鎖</h2><p>這裡會發生 race condition 最根本的原因是「兩個 goroutine 可能會同時存取變數 a」，如果能限制<strong>同時只能有一個</strong> goroutine 做 <code>a++</code>，那就能解決這個問題，為了達到這個目的我們要使用 <code>sync.Mutex</code></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Joe Huang</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>