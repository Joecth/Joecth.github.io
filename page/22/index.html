<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Joe Huang"><meta name="copyright" content="Joe Huang"><title>Awaken Desparado</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-180692466-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Joe Huang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">399</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">26</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">70</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Awaken Desparado</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Awaken Desparado</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/06/System-Design/2020-02-05-System%20Design%20-%20NoSQL/">System-Design/2020-02-05-System Design - NoSQL</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/System/">System</a></span><div class="content"><p>SQL - ORM, basics</p>
<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>Not Only SQL</p>
<p>本身有幾個派別如kv, document</p>
<h4 id="4種型式的存儲方式"><a href="#4種型式的存儲方式" class="headerlink" title="4種型式的存儲方式"></a>4種型式的存儲方式</h4><ol>
<li><p>kv    - Redis, Memcached</p>
</li>
<li><p>document store - <strong>MongoDB</strong></p>
</li>
<li><p>wide column store - <strong>Cassandra</strong>, Bigtable, <strong>DynamoDB</strong></p>
</li>
<li><p>graph database - Neo4j</p>
</li>
</ol>
<h4 id="Normalize-–-JOIN-在SQL-ORM用的，往往一個機器"><a href="#Normalize-–-JOIN-在SQL-ORM用的，往往一個機器" class="headerlink" title="Normalize – JOIN　在SQL ORM用的，往往一個機器"></a>Normalize – JOIN　在SQL ORM用的，往往一個機器</h4><p>RDBMS避免冗餘</p>
<h4 id="Denormalize-–-大量重複要寫到多份，寫就麻煩，但讀有利"><a href="#Denormalize-–-大量重複要寫到多份，寫就麻煩，但讀有利" class="headerlink" title="Denormalize – 大量重複要寫到多份，寫就麻煩，但讀有利　"></a>Denormalize – 大量重複要寫到多份，寫就麻煩，但讀有利　</h4><p>多餘的重複寫到多個tables去，就是避免join, </p>
<p>在nosql 裡大量用的 ，nosql往往為了多機器作分布</p>
<p>數據中心要同步數據怎麼辦？跨<code>data-center Denormalize</code>就兩邊都寫</p>
<p>寫時要保證<strong><em>各國的數據中心都寫進去了</em></strong>，</p>
<p>要知道是 <code>read-heavy</code> or <code>write-heavy</code> 大多是讀的多，</p>
<p>如youtube讀的人遠大於寫的人</p>
<h5 id="缺點：不利於寫、冗缺、如果系統write-heavy就很不利，如logging-system、message-que"><a href="#缺點：不利於寫、冗缺、如果系統write-heavy就很不利，如logging-system、message-que" class="headerlink" title="缺點：不利於寫、冗缺、如果系統write-heavy就很不利，如logging system、message que"></a>缺點：不利於寫、冗缺、如果系統write-heavy就很不利，如logging system、message que</h5><p>什麼系統是寫多的? logging系統如卡夫卡</p>
<ul>
<li><p>要做join的話是在<strong>applicatin layer也是middle layer?!</strong>的　＝＝＞　<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h38ag80odjj20dg0ey3yj.jpg" alt="image-20200206221633536" style="zoom: 25%;" /></p>
</li>
<li><p>不支持ACID - <em>ACID</em> (<em>atomicity, consistency, isolation, durability</em>) is a set of properties of database transactions intended to guarantee validity ，那麼多機器不能保證事務</p>
</li>
<li><p>nosql不好鎖，多個當然不好鎖，慢慢才最終一致, 跨機器不容易鎖呀，所以是eventually consistency</p>
<ul>
<li>例如：linkedin發了文章，不是需要馬上好友都看到，可以有latency的，我的follower之後才收到沒差</li>
</ul>
<p>叫作 <strong><em>eventually consistency</em></strong>，可能就不是毫秒級的，是秒級的，也不會到慢到一分鐘之類</p>
<ul>
<li><h4 id="為何是Eventually-Consistency"><a href="#為何是Eventually-Consistency" class="headerlink" title="為何是Eventually Consistency?"></a>為何是Eventually Consistency?</h4><ul>
<li><h4 id="Quorum-就是假如有三個人，2-1，少數服從多數，儘管第三台還沒寫到，它在第二台被寫後，也會要因為大家投票變了，要服從是變第2版"><a href="#Quorum-就是假如有三個人，2-1，少數服從多數，儘管第三台還沒寫到，它在第二台被寫後，也會要因為大家投票變了，要服從是變第2版" class="headerlink" title="Quorum - 就是假如有三個人，2:1，少數服從多數，儘管第三台還沒寫到，它在第二台被寫後，也會要因為大家投票變了，要服從是變第2版"></a>Quorum - 就是假如有三個人，2:1，少數服從多數，儘管第三台還沒寫到，它在第二台被寫後，也會要因為大家投票變了，要服從是變第2版</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggrfjal4ukj30ym0hw0xh.jpg" alt="image-20200715100536958"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ACID-in-SQL-atomicity-consistency-isolation-durability"><a href="#ACID-in-SQL-atomicity-consistency-isolation-durability" class="headerlink" title="ACID in SQL - (atomicity, consistency, isolation, durability)"></a>ACID in SQL - (<em>atomicity, consistency, isolation, durability</em>)</h1><p>一台機器時，SQL就可保證事務，銀行Transaction 銀行的經典例子 - </p>
<p>一個事務裡：原子性。</p>
<p>銀行在意事務，所以ORM比較好。如果在一個地方取，中間</p>
<p>帳號是個變量a, 本來有1000元，一邊要存5000元，另個人從我的帳戶也取1000元。如果沒有事務保護</p>
<p>數據就亂了</p>
<p>DBMS裡在　為保證transation可靠，所以要有ACID,事務中只能有一個會成功</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h38agfne6oj212a0iqjs9.jpg" alt="image-20200206222645993" style="zoom:50%;" />



<h1 id="CAP-General-for-both-SQL-amp-NoSQL"><a href="#CAP-General-for-both-SQL-amp-NoSQL" class="headerlink" title="CAP, General for both SQL &amp; NoSQL"></a>CAP, General for both SQL &amp; NoSQL</h1><ul>
<li><p><strong>CAP Theorem</strong></p>
</li>
<li><p>在<a href="https://zh.wikipedia.org/wiki/理論計算機科學" target="_blank" rel="noopener">理論計算機科學</a>中，<strong>CAP定理</strong>（CAP theorem），又被稱作<strong>布魯爾定理</strong>（Brewer’s theorem），它指出對於一個<a href="https://zh.wikipedia.org/wiki/分布式计算" target="_blank" rel="noopener">分布式計算系統</a>來說，不可能同時滿足以下三點：<a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-Lynch-1" target="_blank" rel="noopener">[1]</a><a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-2" target="_blank" rel="noopener">[2]</a></p>
<ul>
<li>一致性（<strong>C</strong>onsistency） （等同於所有節點訪問同一份最新的數據副本）</li>
<li><a href="https://zh.wikipedia.org/wiki/可用性" target="_blank" rel="noopener">可用性</a>（<strong>A</strong>vailability）（每次請求都能獲取到非錯的響應——但是不保證獲取的數據為最新數據）</li>
<li><a href="https://zh.wikipedia.org/w/index.php?title=网络分区&action=edit&redlink=1" target="_blank" rel="noopener">分區容錯性</a>（<strong>P</strong>artition tolerance）（以實際效果而言，分區相當於對通信的時限要求。系統如果不能在時限內達成數據一致性，就意味著發生了分區的情況，必須就當前操作在C和A之間做出選擇<a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-3" target="_blank" rel="noopener">[3]</a>。）</li>
</ul>
<p>根據定理，分布式系統只能滿足三項中的兩項而不可能滿足全部三項<a href="https://zh.wikipedia.org/wiki/CAP定理#cite_note-4" target="_blank" rel="noopener">[4]</a>。理解CAP理論的最簡單方式是想像兩個節點分處分區兩側。允許至少一個節點更新狀態會導致數據不一致，即喪失了C性質。如果為了保證數據一致性，將分區一側的節點設置為不可用，那麼又喪失了A性質。除非兩個節點可以互相通信，才能既保證C又保證A，這又會導致喪失P性質。</p>
<p><strong>BASE</strong> is often used to describe the properties of NoSQL databases. In comparison with the <a href="https://github.com/donnemartin/system-design-primer#cap-theorem" target="_blank" rel="noopener">CAP Theorem</a>, BASE chooses availability over consistency.</p>
<ul>
<li><strong>Basically available</strong> - the system guarantees availability.</li>
<li><strong>Soft state</strong> - the state of the system may change over time, even without input.</li>
<li><strong>Eventual consistency</strong> - the system will become consistent over a period of time, given that the system doesn’t receive input during that period.</li>
</ul>
</li>
</ul>
<h1 id="NoSQL-Cont"><a href="#NoSQL-Cont" class="headerlink" title="NoSQL Cont."></a>NoSQL Cont.</h1><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p>ORM object relational mapping, mysql oracle都是可以被java裡搞定起來</p>
<p>DDL 時就是schema都是差不多的　－　Data Definition Language，DDL</p>
<h4 id="NoSQL就有分流派了-主要就是四大流派"><a href="#NoSQL就有分流派了-主要就是四大流派" class="headerlink" title="NoSQL就有分流派了 主要就是四大流派"></a>NoSQL就有分流派了 主要就是四大流派</h4><p>Key-Value資料庫、Wide Col、圖學資料庫和Document.</p>
<h4 id="Source-s-and-further-reading-key-value-store"><a href="#Source-s-and-further-reading-key-value-store" class="headerlink" title="Source(s) and further reading: key-value store"></a>Source(s) and further reading: key-value store</h4><ul>
<li><p><a href="https://en.wikipedia.org/wiki/Key-value_database" target="_blank" rel="noopener">Key-value database</a></p>
</li>
<li><p><a href="http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or" target="_blank" rel="noopener">Disadvantages of key-value stores</a></p>
</li>
<li><p><a href="http://qnimate.com/overview-of-redis-architecture/" target="_blank" rel="noopener">Redis architecture</a>　比較是緩存服務; 2.2 後有支援 transaction, lock for <code>Booking System</code></p>
</li>
<li><p><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/" target="_blank" rel="noopener">Memcached architecture</a>　比較是緩存服務</p>
</li>
</ul>
<h4 id="Document-Store-MongoDB"><a href="#Document-Store-MongoDB" class="headerlink" title="Document Store - MongoDB"></a>Document Store - MongoDB</h4><h5 id="最重要的就是Schemaless-–-就是沒有schema"><a href="#最重要的就是Schemaless-–-就是沒有schema" class="headerlink" title="最重要的就是Schemaless – 就是沒有schema,"></a>最重要的就是Schemaless – 就是沒有schema,</h5><h4 id="Document-store，"><a href="#Document-store，" class="headerlink" title="Document store，"></a>Document store，</h4><h5 id="Schemaless"><a href="#Schemaless" class="headerlink" title="Schemaless"></a>Schemaless</h5><p>如JSON就是kv, 就是<code>schemaless</code></p>
<blockquote>
<p>Abstraction: key-value store with documents stored as values</p>
</blockquote>
<p>A document store is centered around documents (XML, JSON, binary, etc), where a document stores all information for a given object. Document stores provide APIs or a query language to query based on the internal structure of the document itself. <em>Note, many key-value stores include features for working with a value’s metadata, blurring the lines between these two storage types.</em></p>
<p>Based on the underlying impleme</p>
<h5 id="Source-s-and-further-reading-document-store"><a href="#Source-s-and-further-reading-document-store" class="headerlink" title="Source(s) and further reading: document store"></a>Source(s) and further reading: document store</h5><ul>
<li><p><a href="https://en.wikipedia.org/wiki/Document-oriented_database" target="_blank" rel="noopener">Document-oriented database</a></p>
</li>
<li><p><a href="https://www.mongodb.com/mongodb-architecture" target="_blank" rel="noopener">MongoDB architecture</a></p>
</li>
<li><p><a href="https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/" target="_blank" rel="noopener">CouchDB architecture</a></p>
</li>
<li><p><a href="https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up" target="_blank" rel="noopener">Elasticsearch architecture</a></p>
</li>
</ul>
<h4 id="Wide-column-store"><a href="#Wide-column-store" class="headerlink" title="Wide column store"></a>Wide column store</h4><p><a href="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cnj0ioj30g506f0t2.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cnj0ioj30g506f0t2.jpg" alt="img"></a><br><strong><em><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html" target="_blank" rel="noopener">Source: SQL &amp; NoSQL, a brief history</a></em></strong></p>
<blockquote>
<p>Abstraction: nested map <code>ColumnFamily&gt;</code></p>
</blockquote>
<p><strong>Google introduced <a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf" target="_blank" rel="noopener">Bigtable</a></strong> as the first wide column store, which influenced the open-source <strong><a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture" target="_blank" rel="noopener">HBase</a> (by Hadoop)</strong> often-used in the Hadoop ecosystem, and <a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html" target="_blank" rel="noopener">Cassandra</a> from Facebook. Stores such as BigTable, HBase, and Cassandra maintain keys in lexicographic order, allowing efficient retrieval of selective key ranges.</p>
<h4 id="Graph-DB-–-for-social-Network"><a href="#Graph-DB-–-for-social-Network" class="headerlink" title="Graph DB – for social Network"></a>Graph DB – for social Network</h4><h5 id="Graph-database"><a href="#Graph-database" class="headerlink" title="Graph database"></a>Graph database</h5><p><a href="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cpicsqj30h40c4gps.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cpicsqj30h40c4gps.jpg" alt="img"></a><br><em><a href="https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png" target="_blank" rel="noopener">Source: Graph database</a></em></p>
<blockquote>
<p>Abstraction: graph</p>
</blockquote>
<p>In a graph database, each node is a record and each arc is a relationship between two nodes. Graph databases are optimized to represent complex relationships with many foreign keys or many-to-many relationships.</p>
<p>Graphs databases offer high performance for data models with complex relationships, such as a social network. They are relatively new and are not yet widely-used; it might be more difficult to find development tools and resources. Many graphs can only be accessed with <a href="https://github.com/donnemartin/system-design-primer#representational-state-transfer-rest" target="_blank" rel="noopener">REST APIs</a>.</p>
<h5 id="Source-s-and-further-reading-graph"><a href="#Source-s-and-further-reading-graph" class="headerlink" title="Source(s) and further reading: graph"></a>Source(s) and further reading: graph</h5><ul>
<li><a href="https://en.wikipedia.org/wiki/Graph_database" target="_blank" rel="noopener">Graph database</a></li>
<li><strong><a href="https://neo4j.com/" target="_blank" rel="noopener">Neo4j</a></strong></li>
<li><a href="https://blog.twitter.com/2010/introducing-flockdb" target="_blank" rel="noopener">FlockDB</a></li>
</ul>
<h2 id="SQL-vs-NoSQL-何時用"><a href="#SQL-vs-NoSQL-何時用" class="headerlink" title="SQL vs NoSQL 何時用?"></a>SQL vs NoSQL 何時用?</h2><p>如<code>mysql</code> vs <code>cassandra (mongoDB)</code> 之間的區別之類的？</p>
<p>Reasons for <strong>SQL</strong>:</p>
<ul>
<li>Structured data</li>
<li>Strict schema</li>
<li><strong>Relational data</strong></li>
<li>Need for complex <strong>joins</strong> 如<code>用戶</code>跟<code>group</code></li>
<li><code>Transactions</code>　事務</li>
<li>Clear patterns for scaling</li>
<li>More established: developers, community, code, tools, etc</li>
<li>Lookups by <strong><em>index</em></strong> are very fast</li>
</ul>
<p>Reasons for <strong>NoSQL</strong>:</p>
<ul>
<li>Semi-structured data　　</li>
<li><strong><em>Dynamic or flexible schema</em></strong></li>
<li>Non-relational data</li>
<li>No need for complex joins</li>
<li><strong><em>Store many TB (or PB) of data</em></strong>　</li>
<li><strong><em>Very data intensive workload</em></strong> </li>
<li><code>Very high throughput for IOPS (Input/Output Operations Per Second</code></li>
</ul>
<h5 id="Sample-data-well-suited-for-NoSQL"><a href="#Sample-data-well-suited-for-NoSQL" class="headerlink" title="Sample data well-suited for NoSQL:"></a>Sample data well-suited for NoSQL:</h5><ul>
<li><p>Rapid ingest of clickstream and <strong><em>log data</em></strong> <strong>之前說的頻繁寫的!!</strong></p>
</li>
<li><p>Leaderboard or scoring data <strong><em>就 eventually consistency 就好的</em></strong></p>
</li>
<li><p>Temporary data, such as a <code>shopping cart</code>  有cache就可以搞定</p>
</li>
<li><p>Frequently accessed (‘hot’) tables</p>
</li>
<li><p>Metadata/lookup tables</p>
</li>
</ul>
<h5 id="Source-s-and-further-reading-SQL-or-NoSQL"><a href="#Source-s-and-further-reading-SQL-or-NoSQL" class="headerlink" title="Source(s) and further reading: SQL or NoSQL"></a>Source(s) and further reading: SQL or NoSQL</h5><ul>
<li><a href="https://www.youtube.com/watch?v=w95murBkYmU" target="_blank" rel="noopener">Scaling up to your first 10 million users</a></li>
<li><a href="https://www.sitepoint.com/sql-vs-nosql-differences/" target="_blank" rel="noopener">SQL vs NoSQL differences</a></li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h38afqt977j210u0iitam.jpg" alt="image-20200206225707917"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h38aftxl8tj210u0fqabr.jpg" alt="image-20200206225824207"></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4crkjxdj311005wdge.jpg" alt="image-20200206225934479"></p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h38afy3hw8j211808mt9h.jpg" alt="image-20200206230007842" style="zoom:50%;" />

<p>量不大時　SQL 就夠了；如ACID、data不會變的或結構的</p>
<p>量大時才會用 NoSQL 學校一般用不到那麼大流量啊 量大時一般沒結構，的確<code>NoSQL</code>也是比較靈活</p>
<p>雲上一般要多個機器，硬體也都比較便宜</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd5cj2dgicj30u00wv1g9.jpg" alt="image-20200324213805414" style="zoom: 33%;" /></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/06/System-Design/2020-02-05-System%20Design%20-%20Cache/">System-Design/2020-02-05-System Design - Cache</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/System/">System</a></span><div class="content"><h3 id="https-kknews-cc-zh-tw-code-8vljmng-html"><a href="#https-kknews-cc-zh-tw-code-8vljmng-html" class="headerlink" title="https://kknews.cc/zh-tw/code/8vljmng.html"></a><a href="https://kknews.cc/zh-tw/code/8vljmng.html" target="_blank" rel="noopener">https://kknews.cc/zh-tw/code/8vljmng.html</a></h3><p><a href="https://www.zhihu.com/question/319817091" target="_blank" rel="noopener">https://www.zhihu.com/question/319817091</a></p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>對比<strong>disk</strong> and <strong>memory</strong>, 內存貴，跟disk比，它寫跟讀快很多</p>
<h4 id="local-disk-V-S-memory"><a href="#local-disk-V-S-memory" class="headerlink" title="local disk V.S. memory"></a>local disk V.S. memory</h4><p>能不能把一部份的數據放到memory讓它快?</p>
<p>讀不到才去worker 找，</p>
<p>Cache kv對，很快，repeated Query可這樣做，當一個fn被多次調用，就是要加 Cache</p>
<img src="https://camo.githubusercontent.com/7acedde6aa7853baf2eb4a53f88e2595ebe43756/687474703a2f2f692e696d6775722e636f6d2f51367a32344c612e706e67" alt="img" style="zoom:48%;" />

<p>方法算法被多次叫怎辦？就是說要加Cache。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnblny6qkj312c0g8qch.jpg" alt="image-20200711204719225"></p>
<p>緩存的應用很多。</p>
<p>DB會受益；同個URL來，他不的</p>
<p>本地的缓存就自己本地拿了，不会再去 server端。</p>
<h4 id="Cacheing-service-Memcache-Redis"><a href="#Cacheing-service-Memcache-Redis" class="headerlink" title="Cacheing service : Memcache, Redis"></a>Cacheing service : Memcache, Redis</h4><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rkssomcj310c0kgaj0.jpg" alt="image-20200206192031055" style="zoom:50%;" />

<h3 id="Cache-aside"><a href="#Cache-aside" class="headerlink" title="Cache aside"></a>Cache aside</h3><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggrhq7cinxj30zk0ign31.jpg" alt="image-20200715112132396" style="zoom: 50%;" />

<p>照理redis不需要知道業務邏輯，應該都是client控制的，所以redis跟db應該沒分前後</p>
<p>並發時噁心</p>
<p>機率非常低，還可以設上個ttl，讓他自動expire，減小髒的機率，髒指的就是cache、db不同</p>
<p>這個是最常用的</p>
<h3 id="Cache-Aside-也會有的併發的問題，但概率很低，也可以設ttl解"><a href="#Cache-Aside-也會有的併發的問題，但概率很低，也可以設ttl解" class="headerlink" title="Cache Aside 也會有的併發的問題，但概率很低，也可以設ttl解"></a>Cache Aside 也會有的併發的問題，但概率很低，也可以設ttl解</h3><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rkxfaonj30uc0hk44g.jpg" alt="image-20200206192751483"></p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>分布式cache</p>
<p>redis是個緩存服務，如果用redis他有很多模式，最好的就是如果有三台機器，希望每台都分擔些</p>
<p>traffic用一致性哈希　不同key知道要去哪台找，每個node 就是 1/n</p>
<p>雲計算就是堆機器。</p>
<h5 id="缺點："><a href="#缺點：" class="headerlink" title="缺點："></a>缺點：</h5><p>要是一個機器掛了，有時有個備份。要是一台機器突然沒了，要是用consistent哈希，會重新算每個從 1/5變1/4。cache miss就是去　DB拿。要是突然一台掛了，瞬間會對，一致性哈希有個hash ring。目標就是當一個走了後，盡量讓原來的機器，每個機器要從1/4 –&gt; 1/3　差為1/12。每台要增加這麼多的數據量。讓遷坤大挪移緩和點。</p>
<p>一致性哈希是說讓遷移。讓</p>
<p>distributed hash　就是取模</p>
<p>CDN　content distributed network，也是緩存，更像file system。縣到市市到省</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rl19ugwj30ze0k0wp2.jpg" alt="image-20200206194335424" style="zoom:50%;" />

<p>　</p>
<h3 id="Read-Write-Through"><a href="#Read-Write-Through" class="headerlink" title="Read/Write Through"></a>Read/Write Through</h3><p>使用者寫到cache, cache自己會負責跟db更新，不用你來管，對應用來說簡單多。</p>
<p>嚴格上跟memorycached、redis不一樣，這種cache是知道業務邏輯是知道schema、數據的。</p>
<h5 id="Cache-就是個Service了"><a href="#Cache-就是個Service了" class="headerlink" title="Cache　就是個Service了"></a>Cache　<strong>就是個Service了</strong></h5><p>調cache的人就舒服了什麼都不用管，服務本身在做cache</p>
<p>它會同步寫到db，必須DB完成後才能返回給３，會慢一點寫慢一點，讀仍是快</p>
<p>把client做的邏輯給cache做</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rl5r877j30ea0k8go4.jpg" alt="img" style="zoom:67%;" />

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggzlagwgjvj30yi0e8qai.jpg" alt="image-20200722112920219"></p>
<h5 id="Disadvantage-s-write-through"><a href="#Disadvantage-s-write-through" class="headerlink" title="Disadvantage(s): write through"></a>Disadvantage(s): write through</h5><ul>
<li><p>When a new node is created due to failure or scaling, the new node will not cache entries until the entry is updated in the database. <strong>Cache-aside in conjunction with write through can mitigate this issue.</strong>　來個新node要去db找來寫代價大</p>
</li>
<li><p>Most data written might never be read, which can be minimized with a TTL.　給個死掉的時間</p>
<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rl9vcz3j30s60k0dty.jpg" alt="image-20200206195432938" style="zoom:50%;" />





</li>
</ul>
<h3 id="Write-behind-↓-下面"><a href="#Write-behind-↓-下面" class="headerlink" title="Write-behind　↓　下面"></a>Write-behind　↓　下面</h3><p>cache不是馬上去更新db，當大量高併發寫時，撐不住，所以先buffer一下個10秒</p>
<p>k:v1, v2, v3，直接就一次v3就好了 </p>
<p>DB可batch更新　時間到或queue到其值</p>
<p>萬一buffer時掛了怎辦？linux RO</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbn4cmhb4sj30lu0k8aao.jpg" alt="img"></p>
<h5 id="Refresh-ahead…-↓"><a href="#Refresh-ahead…-↓" class="headerlink" title="Refresh ahead… ↓"></a>Refresh ahead… ↓</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>简单的说就是在缓存数据过期前，能自动的刷新缓存数据。举个例子来说，某条数据在缓存中，过期时间是60秒。我们给他设置一个参数，比如是0.8，60x0.8=48秒，那么在前48秒访问该数据，就照正常的取法，直接返回缓存中的数据。当在48-60秒这个区间取数据时，缓存先将之前缓存的结果返回给外部应用程序，然后异步的再从数据库去更新缓存中的值，以尽可能的保证缓存的值是最新的。如果取数据的的时候超过了60秒，就安装read-through的方式。<br> Refresh-ahead是对未来数据的访问情形的估算，我们猜测这个数据在过期后，仍然可能被频繁的访问，那么这种设计的策略获得的优势会更明显。<br> 但是，如果有大量的数据是用refresh-ahead策略，但是这个数据被重新缓存后，又一次都没有被访问过，那这个策略就是很失算的了。<br> 那么，有人可能会问，既然如此，我把过期的时间延长不就好了，之前60秒过期，改成6000秒过期，这样就不会用Refresh-ahead策略来刷新数据了。<br> 然而，事实是缓存的数据越久，出现脏数据的可能性也就越大，更重要的是，如果你的估算也是失误的，大量的超期缓存数据没有被实际访问，那么你就浪费了很多的内存，做了无用的事情，这也是应该避免的。</p>
<p>作者：周小春<br>链接：<a href="https://www.jianshu.com/p/6321d4f823c1" target="_blank" rel="noopener">https://www.jianshu.com/p/6321d4f823c1</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/05/System-Design/2019-02-04-System%20Design%20-%20LB/">System-Design/2019-02-04-System Design - LB</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/System/">System</a></span><div class="content"><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>怎麼random選一個server，LB要保證</p>
<p>NGINX 異步</p>
<h2 id="SNAKE"><a href="#SNAKE" class="headerlink" title="SNAKE"></a>SNAKE</h2><ul>
<li>Scenario: case/interface</li>
<li>Necessary: constrain/hypothesis</li>
<li>Application: service/algo</li>
<li>Kilobit: data</li>
<li>Evolve</li>
</ul>
<p>使用redis 緩存的地方</p>
<ul>
<li>獎品，數量少，更新頻率低，最佳的全量緩存對象</li>
<li>優惠券，一次性導入，優惠券編碼緩存為set類型</li>
<li>中獎紀錄，讀寫差不多，可以緩存部分統計數據</li>
<li>黑名單</li>
</ul>
<h2 id="Loading-Balancing"><a href="#Loading-Balancing" class="headerlink" title="Loading Balancing"></a>Loading Balancing</h2><h3 id="Load-Balancer"><a href="#Load-Balancer" class="headerlink" title="Load Balancer"></a>Load Balancer</h3><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd3rkbx8ooj319y0acwkc.jpg" alt="image-20200205225415969" style="zoom:50%;" />

<ol>
<li><p>Smart Clients</p>
<p>如果host recover了，就要能夠識別</p>
<p>系統大了，LB可能是單獨的機器</p>
<p>等著，占著一個線程，回來才release，上面的那條線是同步的假定，異步的效能會比較好</p>
<ul>
<li>nginx async</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>Hardware LB</p>
</li>
<li><p>Software LB</p>
<ul>
<li><strong>HAProxy</strong> 是個比較popular 的software, 加了機器要自己再改配置</li>
<li>Service Discovery 改配置文件</li>
<li><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnaa27ds3j314e0la474.jpg" alt="image-20200711200135289"></li>
<li>9000會forward到其他的三個機上去</li>
</ul>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblx1909c6j31c20i2h6v.jpg" alt="image-20200205225556197" style="zoom:50%;" />

<p>​    </p>
<h3 id="設計-Serverside-Load-Balancer-選server"><a href="#設計-Serverside-Load-Balancer-選server" class="headerlink" title="設計 Serverside Load Balancer 選server"></a>設計 Serverside Load Balancer 選server</h3><p>LB 不是個單獨的機器，只是在運行時在代碼裡的一個 client，如下↓</p>
<p>![image-20200711200432006](/Users/joe/Library/Application Support/typora-user-images/image-20200711200432006.png)</p>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblyao5twoj314a0jk7jx.jpg" alt="image-20200205233939163" style="zoom:50%;" />



<h4 id="Clien-Side-LB"><a href="#Clien-Side-LB" class="headerlink" title="Clien-Side LB"></a>Clien-Side LB</h4><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblyb6gizej314y0lik65.jpg" alt="image-20200205234009523" style="zoom:50%;" />

<p>Load balancing 可以用一致性哈希的機制　key是一樣永遠會去一樣的機器</p>
<p>希望對某一個key去固定的server取緩存</p>
<h5 id="Smart-Consistent-Hash-選-Server"><a href="#Smart-Consistent-Hash-選-Server" class="headerlink" title="Smart Consistent Hash 選 Server"></a>Smart Consistent Hash 選 Server</h5><p>這個是Sticky</p>
<p>也有上面三點可以根據去選</p>
<ol>
<li>Availability</li>
<li>Performance 看誰閒</li>
<li>地理，怎麼判斷route到哪個國家？</li>
</ol>
<h4 id="Spring-Cloud-Ribbon-Library"><a href="#Spring-Cloud-Ribbon-Library" class="headerlink" title="Spring Cloud - Ribbon Library"></a>Spring Cloud - Ribbon Library</h4><p>來了新的ABC Service，LB會知道，因為有Service Registration，LB會考慮第11個進來</p>
<p>Smart LB, 到底該發給哪個Server? 需要SMART!</p>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblyg6va34j30z20pqgw1.jpg" alt="image-20200205234458185" style="zoom:50%;" />

<h5 id="１-AvailabilityFilteringRule"><a href="#１-AvailabilityFilteringRule" class="headerlink" title="１ AvailabilityFilteringRule"></a>１ AvailabilityFilteringRule</h5><p>​        10秒、100, 1000秒再試 exponential</p>
<h5 id="２-WeightedResponseTimeRule"><a href="#２-WeightedResponseTimeRule" class="headerlink" title="２ WeightedResponseTimeRule"></a>２ WeightedResponseTimeRule</h5><p>​        要等愈長，權重給它愈小，我相對應該要發給response快的。</p>
<p>​    <strong>但不知道是DB慢還是API自己慢</strong>，還可講更底層的 TLS(Transpor Layer Security)、握手等機制都是routing的因素，所以smart LB都要考慮</p>
<h2 id="System-Design-Primer-GitHub"><a href="#System-Design-Primer-GitHub" class="headerlink" title="System Design Primer - GitHub"></a>System Design Primer - GitHub</h2><p><a href="https://github.com/kevingo/system-design-primer-zh-tw#how-to-approach-a-system-design-interview-question" target="_blank" rel="noopener">https://github.com/kevingo/system-design-primer-zh-tw#how-to-approach-a-system-design-interview-question</a>　</p>
<p>而</p>
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblyxvhf3ij30sb0ixwfc.jpg" alt="img" style="zoom:48%;" />

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnaryy7bhj312o0icqgf.jpg" alt="image-20200711201841909"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnatffvd9j30xo09wae1.jpg" alt="image-20200711202012221"></p>
<h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL:"></a>SSL:</h4><p> 怕 man in the middle 監聽；但 SSL 到門口就可以停下來了，內部自己人不需要用SSL, SSL需要去裝Certification X.509 的認證，需要被 CA給授權，是頒發下來的</p>
<h4 id="Session-persistent"><a href="#Session-persistent" class="headerlink" title="Session persistent:"></a>Session persistent:</h4><p> 可以根據cookie、一致性哈希去路由到某個固定的機器去維持一個session，每次都發到一個固定的 Worker上，這樣永遠在跟這個Worker打交道，session的數據放在memory，機器會直接記得你放的東西，就是Session Data，</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnaw03p78j30ze0c6aga.jpg" alt="image-20200711202240110"></p>
<ul>
<li><p>Sticky session / cookies 指的就是之前提到的 constant hash</p>
</li>
<li><p>傳輸層安全性協定（英語：Transport Layer Security，縮寫：TLS）及其前身安全通訊協定（英語：Secure Sockets Layer，縮寫：SSL）是一種安全協定，目的是為網際網路通訊提供安全及資料完整性保障。</p>
</li>
<li><p>TLS與SSL協定可加密客戶端與伺服器端的網路通訊，它們利用憑證來建立身分鏈，以確保客戶端所通訊的對象是經過驗證的合法伺服器。而進行HTTPS監聽的方法則是在客戶端與伺服器端之間建立一個中間代理人，類似中間人攻擊（man-in-the-middle）的手法，這些可執行HTTPS監聽的安全產品會先攔截流量、檢查流量內容，再重建連結。</p>
</li>
<li><p>内部自己用RPC</p>
</li>
<li><p>Load balancers can be implemented with hardware (expensive) or with software such as HAProxy.</p>
<p>Additional benefits include:</p>
<ul>
<li>SSL termination</li>
</ul>
</li>
</ul>
<pre><code>\- Decrypt incoming requests and encrypt server responses so backend servers do not have to perform these potentially expensive operations

- Removes the need to install [X.509 certificates](https://en.wikipedia.org/wiki/X.509) on each server</code></pre><ul>
<li><strong>Session persistence</strong> - Issue cookies and route a specific client’s requests to same instance if the web apps do not keep track of sessions === 如購物車時</li>
</ul>
<h4 id="Faile-Over"><a href="#Faile-Over" class="headerlink" title="Faile Over"></a>Faile Over</h4><ul>
<li><ul>
<li><h3 id="Fail-over"><a href="#Fail-over" class="headerlink" title="Fail-over"></a>Fail-over</h3><h4 id="Active-passive-failover-有替補的當主要的掛了時馬上補上去"><a href="#Active-passive-failover-有替補的當主要的掛了時馬上補上去" class="headerlink" title="Active-passive failover 有替補的當主要的掛了時馬上補上去"></a>Active-passive failover 有替補的當主要的掛了時馬上補上去</h4><p>不停發 心動，如果沒有了，就趕緊找候補代替他</p>
<p>With active-passive fail-over, heartbeats are sent between the active and the passive server on standby. If the heartbeat is interrupted, the passive server takes over the active’s IP address and resumes service.</p>
<p>The length of downtime is determined by whether the passive server is already running in ‘hot’ standby or whether it needs to start up from ‘cold’ standby. Only the active server handles traffic.</p>
<p>Active-passive failover can also be referred to as master-slave failover.</p>
<h4 id="Active-active"><a href="#Active-active" class="headerlink" title="Active-active"></a>Active-active</h4><p>In active-active, both servers are managing traffic, spreading the load between them.</p>
<p>If the servers are public-facing, the DNS would need to know about the public IPs of both servers. If the servers are internal-facing, application logic would need to know about both servers.</p>
<p>Active-active failover can also be referred to as master-master failover.</p>
</li>
</ul>
</li>
</ul>
<h3 id="LB-Traffics"><a href="#LB-Traffics" class="headerlink" title="LB Traffics"></a>LB Traffics</h3><ul>
<li><h3 id="Layer-4-load-balancing"><a href="#Layer-4-load-balancing" class="headerlink" title="Layer 4 load balancing"></a>Layer 4 load balancing</h3><p>第四層看不了 Session，只有下面粗字的能看</p>
<p>Layer 4 load balancers look at info at the <a href="https://github.com/kevingo/system-design-primer-zh-tw#communication" target="_blank" rel="noopener">transport layer</a> to decide how to distribute requests. Generally, this involves the <strong>source, destination IP addresses, and ports</strong> in the header, but not the contents of the packet. Layer 4 load balancers forward network packets to and from the upstream server, performing <a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" target="_blank" rel="noopener">Network Address Translation (NAT)</a>.</p>
<h5 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h5><ul>
<li><p><strong>NAT</strong> - Network Address Translation (NAT) </p>
<p>就是 public IP 要 map進去內部的IP</p>
<p>對外會把ip映射成一個對外的ip</p>
<p>當在配置一個data center 時，內外ip的mapping</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnb6o69t6j30ww0a60x6.jpg" alt="image-20200711203254172"></p>
</li>
</ul>
</li>
</ul>
<h3 id="Layer-7-load-balancing"><a href="#Layer-7-load-balancing" class="headerlink" title="Layer 7 load balancing"></a>Layer 7 load balancing</h3><p>  能做的事比 L4更多，愈下面愈快，RPC就是快</p>
<p>  Layer 7 load balancers look at the <a href="https://github.com/kevingo/system-design-primer-zh-tw#communication" target="_blank" rel="noopener">application layer</a> to decide how to distribute requests. This can involve contents of the <strong>header, message, and cookies</strong>. Layer 7 load balancers terminates network traffic, reads the message, makes a load-balancing decision, then opens a connection to the selected server. <strong>For example, a layer 7 load balancer can direct video traffic to servers that host videos while directing more sensitive user billing traffic to security-hardened servers.</strong><br>  比較好的網關，對於REST過來的URL, 會根據 URLroute 到不同的服務</p>
<p>  E.g.: </p>
<pre><code>- xxx.com/account/XXXX -&gt; billing/account service
- xxx.com/video/YYY -&gt; video_service</code></pre><ul>
<li><strong>spring cloud zuul</strong>裡就有得配置　将path ==&gt; serviceId </li>
</ul>
  <img src="https://camo.githubusercontent.com/1d761d5688d28ce1fb12a0f1c8191bca96eece4c/687474703a2f2f692e696d6775722e636f6d2f354b656f6351732e6a7067" alt="img"  />

<p>  At the cost of flexibility, <strong><em>layer 4 load balancing requires less time and computing resources than Layer 7</em></strong>, although the performance impact can be minimal on modern commodity hardware.</p>
<p>  ​        愈底下愈快啊　如Application Server用IPC　肯定比http快</p>
<h3 id="Horizontal-scaling-加機器，而不是加单一台的性能"><a href="#Horizontal-scaling-加機器，而不是加单一台的性能" class="headerlink" title="Horizontal scaling     加機器，而不是加单一台的性能"></a>Horizontal scaling     加機器，而不是加单一台的性能</h3><p>Load balancers can also help with horizontal scaling, improving performance and availability. Scaling out using commodity machines is more cost efficient and results in higher availability than scaling up a single server on more expensive hardware, called <strong>Vertical Scaling　==&gt;　加CPU、RAM</strong>. It is also easier to hire for talent working on commodity hardware than it is for specialized enterprise systems.</p>
<h4 id="Disadvantage-s-horizontal-scaling"><a href="#Disadvantage-s-horizontal-scaling" class="headerlink" title="Disadvantage(s): horizontal scaling"></a>Disadvantage(s): horizontal scaling</h4><ul>
<li><p>Scaling horizontally introduces complexity and involves cloning servers</p>
<ul>
<li><p>Servers should be <strong>stateless</strong>: they should not contain any user-related data like sessions or profile pictures　<strong>不管去哪台web server機器都應該要是一樣的　不該有session這樣的東西</strong></p>
<p><strong><em>↑ Server 是Stateless, ↓ Session是Stateful</em></strong></p>
</li>
<li><p><strong>Sessions</strong> can be stored in a centralized data store such as a <a href="https://github.com/kevingo/system-design-primer-zh-tw#database" target="_blank" rel="noopener">database</a> (SQL, NoSQL) or a persistent <a href="https://github.com/kevingo/system-design-primer-zh-tw#cache" target="_blank" rel="noopener">cache</a> (Redis, Memcached). <strong>Session 就是 Stateful</strong></p>
</li>
</ul>
</li>
<li><p>Downstream servers such as caches and databases need to handle more simultaneous connections as upstream servers scale out</p>
</li>
</ul>
<p>​        </p>
<h3 id="Disadvantage-s-load-balancer"><a href="#Disadvantage-s-load-balancer" class="headerlink" title="Disadvantage(s): load balancer"></a>Disadvantage(s): load balancer</h3><ul>
<li><p>The load balancer can become a performance bottleneck if it does not have enough resources or if it is not configured properly.　掛了就沒</p>
</li>
<li><p>Introducing a load balancer to help eliminate single points of failure results in increased complexity. 系統複雜了，也是會有問題</p>
</li>
</ul>
<ul>
<li><p>A single load balancer is a single point of failure, configuring multiple load balancers further increases complexity.</p>
</li>
<li><h3 id="Source-s-and-further-reading"><a href="#Source-s-and-further-reading" class="headerlink" title="Source(s) and further reading"></a>Source(s) and further reading</h3><ul>
<li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="noopener">NGINX architecture</a></li>
<li><a href="http://www.haproxy.org/download/1.2/doc/architecture.txt" target="_blank" rel="noopener">HAProxy architecture guide</a></li>
<li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones" target="_blank" rel="noopener">Scalability</a></li>
<li><a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)" target="_blank" rel="noopener">Wikipedia</a></li>
<li><a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" target="_blank" rel="noopener">Layer 4 load balancing</a></li>
<li><a href="https://www.nginx.com/resources/glossary/layer-7-load-balancing/" target="_blank" rel="noopener">Layer 7 load balancing</a></li>
<li><a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html" target="_blank" rel="noopener">ELB listener config</a>　　這個是亞馬遜自己開發的</li>
</ul>
</li>
</ul>
<h5 id="LB-某種意義上就是-reversed-proxy-Web-Server-了"><a href="#LB-某種意義上就是-reversed-proxy-Web-Server-了" class="headerlink" title="LB 某種意義上就是 reversed proxy (Web Server)了"></a>LB 某種意義上就是 reversed proxy (Web Server)了</h5><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnbfav77vj31200nunc2.jpg" alt="image-20200711204112504"></p>
<p>ref : </p>
<p><a href="https://www.youtube.com/watch?v=RlkA1NRoYJ8&amp;list=PLbhaS_83B97vSWVslD63vjIi5OTYmSVrk&amp;index=80" target="_blank" rel="noopener">https://www.youtube.com/watch?v=RlkA1NRoYJ8&amp;list=PLbhaS_83B97vSWVslD63vjIi5OTYmSVrk&amp;index=80</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/05/Web/2020-02-03-Database/">Web/2020-02-03-Database</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/">Web</a></span><div class="content"><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>用一條SQL 語句 查詢出每門課都大於80 分的學生姓名<br>name kecheng fenshu<br>張三 語文 81<br>張三 數學 75<br>李四 語文 76<br>李四 數學 90<br>王五 語文 81<br>王五 數學 100<br>王五 英語 90</p>
<p>A: select distinct name from table where name not in (select distinct name from table where fenshu&lt;=80);<br>  select name from table group by name having min(fenshu)&gt;80;</p>
<p> select name from table group by name having count(kecheng)&gt;=3 and min(fenshu)&gt;=80;</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis</span><br><span class="line">rds = StrictRedis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>, db=<span class="number">4</span>, password=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">	info = &#123;<span class="string">"job_id"</span>: job_id, <span class="string">"dir"</span>: E_dir, <span class="string">"paras"</span>: params&#125;</span><br><span class="line">	rds.rpush(task_que_name, json.dumps(info))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">status_checker</span><span class="params">()</span>:</span></span><br><span class="line">  result_check = rds.hmget(result_que_name, job_id)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># job = q.get</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># running = True</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="string">""" Get job_id from task_que """</span></span><br><span class="line">                _, info = rds.blpop(task_que_name)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># &#123;'job_id': '9c5c2780-32e0-11ea-805b-005056ab266c', 'dir': 'M_', 'paras': &#123;'_name': 'testxxxxx7373'&#125;&#125;</span></span><br><span class="line">                info = json.loads(info.decode())    <span class="comment"># info is byte from redis</span></span><br><span class="line">                result = foo(info[<span class="string">"dir"</span>], info[<span class="string">"paras"</span>])</span><br><span class="line">                <span class="comment"># time.sleep(500)</span></span><br><span class="line"></span><br><span class="line">                rds.hmset(result_que_name, &#123;info[<span class="string">"job_id"</span>]: json.dumps(result)&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"Caught exception: &#123;&#125;"</span>.format(e))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/05/Web/2018-02-04-Web-Arrangement/">Web/2018-02-04-Web-Arrangement</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/">Web</a></span><div class="content"><h3 id="TCP-vs-UDP"><a href="#TCP-vs-UDP" class="headerlink" title="TCP vs UDP"></a>TCP vs UDP</h3><img src="/Users/joe/Library/Application Support/typora-user-images/image-20200205172545061.png" alt="image-20200205172545061" style="zoom:50%;" />

<p>ISO, the International Organization for Standardization</p>
<p>Open System Interconnection Model，</p>
<table>
<thead>
<tr>
<th align="right"></th>
<th align="left">TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="right">Acronym for</td>
<td align="left">Transmission Control Protocol</td>
<td>User Datagram Protocol or Universal Datagram Protocol</td>
</tr>
<tr>
<td align="right">Connection</td>
<td align="left">Transmission Control Protocol is a connection-oriented protocol.</td>
<td>User Datagram Protocol is a connectionless protocol.</td>
</tr>
<tr>
<td align="right">Function</td>
<td align="left">As a message makes its way across the <a href="https://www.diffen.com/difference/Internet_vs_World_Wide_Web" target="_blank" rel="noopener">internet</a> from one computer to another. This is connection based.</td>
<td>UDP is also a protocol used in message transport or transfer. This is not connection based which means that one program can send a load of packets to another and that would be the end of the relationship.</td>
</tr>
<tr>
<td align="right">Usage</td>
<td align="left">TCP is suited for applications that require high reliability, and transmission time is relatively less critical.</td>
<td>UDP is suitable for applications that need fast, efficient transmission, such as games. UDP’s stateless nature is also useful for servers that answer small queries from huge numbers of clients.</td>
</tr>
<tr>
<td align="right">Use by other protocols</td>
<td align="left">HTTP, HTTPs, FTP, SMTP, Telnet</td>
<td>DNS, DHCP, TFTP, SNMP, RIP, VOIP.</td>
</tr>
<tr>
<td align="right">Ordering of data packets</td>
<td align="left">TCP rearranges <a href="https://www.diffen.com/difference/Data_vs_Information" target="_blank" rel="noopener">data</a> packets in the order specified.</td>
<td>UDP has no inherent order as all packets are independent of each other. If ordering is required, it has to be managed by the application layer.</td>
</tr>
<tr>
<td align="right">Speed of transfer</td>
<td align="left">The speed for TCP is slower than UDP.</td>
<td>UDP is faster because error recovery is not attempted. It is a “best effort” protocol.</td>
</tr>
<tr>
<td align="right">Reliability</td>
<td align="left">There is absolute guarantee that the data transferred remains intact and arrives in the same order in which it was sent.</td>
<td>There is no guarantee that the messages or packets sent would reach at all.</td>
</tr>
<tr>
<td align="right">Header Size</td>
<td align="left">TCP header size is 20 bytes</td>
<td>UDP Header size is 8 bytes.</td>
</tr>
<tr>
<td align="right">Common Header Fields</td>
<td align="left">Source port, Destination port, Check Sum</td>
<td>Source port, Destination port, Check Sum</td>
</tr>
<tr>
<td align="right">Streaming of data</td>
<td align="left">Data is read as a byte stream, no distinguishing indications are transmitted to signal message (segment) boundaries.</td>
<td>Packets are sent individually and are checked for integrity only if they arrive. Packets have definite boundaries which are honored upon receipt, meaning a read operation at the receiver socket will yield an entire message as it was originally sent.</td>
</tr>
<tr>
<td align="right">Weight</td>
<td align="left">TCP is heavy-weight. TCP requires three packets to set up a socket connection, before any user data can be sent. TCP handles reliability and congestion control.</td>
<td>UDP is lightweight. There is no ordering of messages, no tracking connections, etc. It is a small transport layer designed on top of IP.</td>
</tr>
<tr>
<td align="right">Data Flow Control</td>
<td align="left">TCP does Flow Control. TCP requires three packets to set up a socket connection, before any user data can be sent. TCP handles reliability and congestion control.</td>
<td>UDP does not have an option for flow control</td>
</tr>
<tr>
<td align="right">Error Checking</td>
<td align="left">TCP does error checking and error recovery. Erroneous packets are retransmitted from the source to the destination.</td>
<td>UDP does error checking but simply discards erroneous packets. Error recovery is not attempted.</td>
</tr>
<tr>
<td align="right">Fields</td>
<td align="left">1. Sequence Number, 2. AcK number, 3. Data offset, 4. Reserved, 5. Control bit, 6. Window, 7. Urgent Pointer 8. Options, 9. Padding, 10. Check Sum, 11. Source port, 12. Destination port</td>
<td>1. Length, 2. Source port, 3. Destination port, 4. Check Sum</td>
</tr>
<tr>
<td align="right">Acknowledgement</td>
<td align="left">Acknowledgement segments</td>
<td>No Acknowledgment</td>
</tr>
<tr>
<td align="right">Handshake</td>
<td align="left">SYN, SYN-ACK, ACK</td>
<td>No handshake (connectionless protocol)</td>
</tr>
</tbody></table>
<h3 id="TCP-Keep-Alive"><a href="#TCP-Keep-Alive" class="headerlink" title="TCP Keep Alive"></a>TCP Keep Alive</h3><p>刚刚被问到请求头的keep-alive，虽然没能答上来，但回头一查，真是好问题！</p>
<p>【补习ing……】</p>
<p>1、什么是<strong>Keep-Alive模式</strong>？</p>
<p>HTTP协议采用请求-应答模式，有普通的非KeepAlive模式，也有KeepAlive模式。</p>
<p>非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p>
<p>2、如何启用或者关闭<strong>Keep-Alive模式？</strong></p>
<p><strong>浏览器发起建议，服务器视情况统一。</strong></p>
<p>（1）http 1.0中默认是关闭的，如果客户端浏览器支持Keep-Alive，那么就在HTTP请求头中添加一个字段 <strong>Connection: Keep-Alive</strong>，当服务器收到附带有Connection: Keep-Alive的请求时，它也会在响应头中添加一个同样的字段来使用Keep-Alive。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过Keep-Alive规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。</p>
<p>也有可能是Keep-Alive</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Keep-Alive: timeout&#x3D;5, max&#x3D;100</span><br><span class="line">timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接</span><br></pre></td></tr></table></figure>



<p>（2）http 1.1中默认启用Keep-Alive， 默认情况下所在HTTP1.1中所有连接都被保持，除非在请求头或响应头中指明要关闭：Connection: Close ，这也就是为什么Connection: Keep-Alive字段再没有意义的原因。另外，还添加了一个新的字段Keep-Alive:，因为这个字段并没有详细描述用来做什么，可忽略它</p>
<p>目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。</p>
<p>3、启用Keep-Alive的优点</p>
<p>从上面的分析来看，启用Keep-Alive模式肯定更高效，性能更高。因为避免了建立/释放连接的开销。下面是RFC 2616 上的总结：</p>
<p>（1）TCP连接更少，这样就会节约TCP连接在建立、释放过程中，主机和路由器上的CPU和内存开销。<br>By opening and closing fewer TCP connections, CPU time is saved in routers and hosts (clients, servers, proxies, gateways, tunnels, or caches), and memory used for TCP protocol control blocks can be saved in hosts.<br><strong>HTTP requests and responses can be pipelined on a connection. Pipelining allows a client to make multiple requests without waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time.</strong></p>
<p>（2）网络拥塞也减少了，拿到响应的延时也减少了<br><strong>Network congestion</strong> is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to determine the congestion state of the network.<br><strong>Latency</strong> on subsequent requests is reduced since there is no time spent in TCP’s connection opening handshake.</p>
<p>（3）错误处理更优雅：不会粗暴地直接关闭连接，而是report，retry<br>HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection. Clients using future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old semantics after an error is reported.<br>RFC 2616 （P47）还指出：单用户客户端与任何服务器或代理之间的连接数不应该超过2个。一个代理与其它服务器或代码之间应该使用不超过2 * N的活跃并发连接。这是为了提高HTTP响应时间，避免拥塞（冗余的连接并不能代码执行性能的提升）。</p>
<p>4、Keep-Alive模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？</p>
<p>对于非持续连接，浏览器可以通过连接是否关闭来界定请求或响应实体的边界；而对于持续连接，这种方法显然不奏效。有时，尽管我已经发送完所有数据，但浏览器并不知道这一点，它无法得知这个打开的连接上是否还会有新数据进来，只能傻傻地等了。</p>
<p>（1）使用消息首部字段Conent-Length</p>
<p>Conent-Length表示实体内容长度，当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端 需要接收多少数据。</p>
<p>（2）使用消息首部字段Transfer-Encoding</p>
<p>如果是动态页面等时，服务器是不可能预先知道内容大小。因为对于动态生成的内容来说，在内容创建完之前，长度是不可知的。这时候要想准确获取长度，只能开一个足够大的 buffer，等内容全部生成好再计算。但这样做一方面需要更大的内存开销，另一方面也会让客户端等更久。所以不可能这么做。Conent-Length就失效了。</p>
<p>这时就可以使用Transfer-Encoding：chunk模式：服务器就需要使用Transfer-Encoding: chunked这样的方式来代替Content-Length。即如果要一边产生数据，一边发给客户端。</p>
<p>5、 分块编码（Transfer-Encoding: chunked）</p>
<ol>
<li><p>Transfer-Encoding，是一个 HTTP 头部字段（响应头域），字面意思是「传输编码」。最新的 HTTP 规范里，只定义了一种编码传输：分块编码(chunked)。</p>
</li>
<li><p>分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由网页服务器发送给客户端的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。</p>
</li>
<li><p>数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。</p>
</li>
<li><p>具体方法</p>
</li>
<li><ol>
<li>在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。</li>
<li>每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF(\r\n)，也不包括分块数据结尾的 CRLF。</li>
<li>最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束。</li>
</ol>
</li>
<li><p>Content-Encoding 和 Transfer-Encoding 二者经常会结合来用，其实就是针对 Transfer-Encoding 的分块再进行 Content-Encoding压缩。</p>
</li>
</ol>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25\r\n</span><br><span class="line">This is the data in the first chunk\r\n</span><br><span class="line"></span><br><span class="line">1C\r\n</span><br><span class="line">and this is the second one\r\n</span><br><span class="line"></span><br><span class="line">3\r\n</span><br><span class="line">con\r\n</span><br><span class="line"></span><br><span class="line">8\r\n</span><br><span class="line">sequence\r\n</span><br><span class="line"></span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>



<h3 id="3-ways-handshake"><a href="#3-ways-handshake" class="headerlink" title="3 ways handshake"></a>3 ways handshake</h3><p><a href="https://notfalse.net/7/three-way-handshake" target="_blank" rel="noopener">https://notfalse.net/7/three-way-handshake</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblnwn98uhj30fq0gedgq.jpg" alt="三向交握 範例"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gblnxhmf7cj30xs0mfwi6.jpg" alt="TCP-Header-Format"></p>
<h3 id="HTTP-methods"><a href="#HTTP-methods" class="headerlink" title="HTTP methods"></a>HTTP methods</h3><p>Restfule API - GET POST PUT DELETE</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/21/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/80/">80</a><a class="extend next" rel="next" href="/page/23/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By Joe Huang</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>