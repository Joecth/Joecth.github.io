<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Joe Huang"><meta name="copyright" content="Joe Huang"><title>Awaken Desparado</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.1.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Joe Huang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">210</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">26</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Awaken Desparado</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Awaken Desparado</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/01/16/Python/2018-01-16-Sorting%20&amp;%20Searching%20Rearrangement/">Python/2018-01-16-Sorting &amp; Searching Rearrangement</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/LC/">LC</a></span><div class="content"><h3 id="I-Sort"><a href="#I-Sort" class="headerlink" title="I-Sort"></a>I-Sort</h3><p>Used when playing pokers</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">  val = A[i]</span><br><span class="line">  j = i<span class="number">-1</span></span><br><span class="line">  <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> A[j]&gt;val:</span><br><span class="line">    A[j+<span class="number">1</span>] = A[j]</span><br><span class="line">    j -= <span class="number">1</span></span><br><span class="line">  A[j+<span class="number">1</span>] = val</span><br></pre></td></tr></table></figure>

<p>O(n), O(n^2) Worst when inversed sorted.</p>
<h3 id="B-Sort"><a href="#B-Sort" class="headerlink" title="B-Sort"></a>B-Sort</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(A)-i<span class="number">-1</span>):</span><br><span class="line">  	<span class="comment"># val = A[j]</span></span><br><span class="line">    swapped = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> A[j] &gt; A[j+<span class="number">1</span>]:</span><br><span class="line">      <span class="comment"># A[j] = A[j+1]</span></span><br><span class="line">      A[j], A[j+<span class="number">1</span>] = A[j+<span class="number">1</span>], A[j]</span><br><span class="line">    	swapped = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> swapped == <span class="literal">False</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>O(n), O(n^2) Worst when inversed sorted.</p>
<h3 id="S-Sort"><a href="#S-Sort" class="headerlink" title="S-Sort"></a>S-Sort</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</span><br><span class="line">  min_idx = i</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">    <span class="keyword">if</span> A[j] &lt; A[min_idx]:</span><br><span class="line">      min_idx = j</span><br><span class="line">  A[i], A[min_idx] = A[min_idx], A[i]</span><br></pre></td></tr></table></figure>

<p>O(n^2), O(n^2)</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayoeij9eoj31620h8wpf.jpg" alt="image-20200116202922983"></p>
<h3 id="H-sort-Heap-sort"><a href="#H-sort-Heap-sort" class="headerlink" title="H-sort, Heap-sort"></a>H-sort, Heap-sort</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python program for implementation of heap Sort </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># To heapify subtree rooted at index i. </span></span><br><span class="line"><span class="comment"># n is size of heap </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(arr, n, i)</span>:</span> </span><br><span class="line">    largest = i <span class="comment"># Initialize largest as root </span></span><br><span class="line">    l = <span class="number">2</span> * i + <span class="number">1</span>     <span class="comment"># left = 2*i + 1 </span></span><br><span class="line">    r = <span class="number">2</span> * i + <span class="number">2</span>     <span class="comment"># right = 2*i + 2 </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># See if left child of root exists and is </span></span><br><span class="line">    <span class="comment"># greater than root </span></span><br><span class="line">    <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> arr[i] &lt; arr[l]: </span><br><span class="line">        largest = l </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># See if right child of root exists and is </span></span><br><span class="line">    <span class="comment"># greater than root </span></span><br><span class="line">    <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> arr[largest] &lt; arr[r]: </span><br><span class="line">        largest = r </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Change root, if needed </span></span><br><span class="line">    <span class="keyword">if</span> largest != i: </span><br><span class="line">        arr[i],arr[largest] = arr[largest],arr[i] <span class="comment"># swap </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># Heapify the root. </span></span><br><span class="line">        heapify(arr, n, largest) </span><br><span class="line">  </span><br><span class="line"><span class="comment"># The main function to sort an array of given size </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(arr)</span>:</span> </span><br><span class="line">    n = len(arr) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Build a maxheap. </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, <span class="number">-1</span>, <span class="number">-1</span>): </span><br><span class="line">        heapify(arr, n, i) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># One by one extract elements </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>): </span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i] <span class="comment"># swap </span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>) </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Driver code to test above </span></span><br><span class="line">arr = [ <span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] </span><br><span class="line">heapSort(arr) </span><br><span class="line">n = len(arr) </span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Sorted array is"</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n): </span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"%d"</span> %arr[i]), </span><br><span class="line"><span class="comment"># This code is contributed by Mohit Kumra</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gayphqqjdqj311w0tkgso.jpg" alt="image-20200116210706828"></p>
<hr>
<h3 id="M-Sort"><a href="#M-Sort" class="headerlink" title="M-Sort"></a>M-Sort</h3><p>Nxlg(N), where lg(N) is height</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/12/29/Python/2017-12-29-Multiprocessing%20&amp;%20Multithreading/">Python/2017-12-29-Multiprocessing &amp; Multithreading</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-12-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Web/">Web</a></span><div class="content"><h2 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h2><ul>
<li><code>NoJoin</code> </li>
</ul>
<ul>
<li><p><code>Join</code></p>
</li>
<li><p><code>setDaemon</code></p>
</li>
</ul>
<h4 id="NoJoin"><a href="#NoJoin" class="headerlink" title="NoJoin"></a>NoJoin</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,id)</span>:</span> </span><br><span class="line">                threading.Thread.__init__(self) </span><br><span class="line">                self.id = id </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span> </span><br><span class="line">                x = <span class="number">0</span> </span><br><span class="line">                time.sleep(<span class="number">10</span>) </span><br><span class="line">                <span class="keyword">print</span> self.id </span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: </span><br><span class="line">        t1=MyThread(<span class="number">999</span>) </span><br><span class="line">        t1.start() </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>): </span><br><span class="line">                <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">999</span></span><br></pre></td></tr></table></figure>

<p>Obvious halt between 4 and 999, because of the time.sleep(10) at Line9. </p>
<p>Main <strong><em>THREAD</em></strong> (p.s. not Process) checks whether sub-thread finished or not bfr exiting itself.</p>
<h4 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: </span><br><span class="line">    t1=MyThread(<span class="number">999</span>) </span><br><span class="line">    t1.start() </span><br><span class="line">    t1.join() </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>): </span><br><span class="line">            <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">999</span> </span><br><span class="line"><span class="number">0</span> </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>Main thread stops at t1. join(), waiting until sub-thread finished.</p>
<h4 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon"></a>setDaemon</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span> </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,id)</span>:</span> </span><br><span class="line">                threading.Thread.__init__(self) </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span> </span><br><span class="line">                time.sleep(<span class="number">5</span>) </span><br><span class="line">                <span class="keyword">print</span> <span class="string">"This is "</span> + self.getName() </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: </span><br><span class="line">        t1=MyThread(<span class="number">999</span>) </span><br><span class="line">        t1.setDaemon(<span class="literal">True</span>) </span><br><span class="line">        t1.start() </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am the father thread."</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am the father thread.</span><br></pre></td></tr></table></figure>

<p>setDaemon() should be bfr start() method, or the following Error occurs: </p>
<p>==&gt; <em>RuntimeError: cannot set daemon status of active thread</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">print(threading.active_count()) # 2</span><br><span class="line"></span><br><span class="line">print(threading.enumerate()) # [&lt;_MainThread(MainThread, started 140736627270592)&gt;, &lt;Thread(Thread-1, started 123145466363904)&gt;]</span><br><span class="line"></span><br><span class="line">print(threading.current_thread()) #&lt;_MainThread(MainThread, started 140736627270592)&gt;</span><br></pre></td></tr></table></figure>





<h4 id="Multiple-Processors"><a href="#Multiple-Processors" class="headerlink" title="Multiple Processors:"></a>Multiple Processors:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_job</span><span class="params">(arr, q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        arr[i] = arr[i]**<span class="number">2</span></span><br><span class="line">    q.put(arr) <span class="comment"># 將結果放進 queue</span></span><br><span class="line">    <span class="comment"># return arr # 上面這一步驟取代了 return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multithreading</span><span class="params">()</span>:</span></span><br><span class="line">    q = Queue()   <span class="comment"># 宣告 Queue 物件</span></span><br><span class="line">    threads = []  <span class="comment"># 用來放 thread 的 array</span></span><br><span class="line">    data = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        t = threading.Thread(target=thread_job, args=(data[i], q)) <span class="comment"># 將 data 與 queue 傳入 thread 裡面</span></span><br><span class="line">        t.start()</span><br><span class="line">        threads.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join() <span class="comment"># 每個 thread 都要做 join</span></span><br><span class="line"></span><br><span class="line">    results = [] <span class="comment"># 用來接收與顯示結果的 array</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        results.append(q.get()) <span class="comment"># 取出 queue 裡面的資料</span></span><br><span class="line">    print(results) <span class="comment"># 顯示執行後的結果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    multithreading()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">執行：python3 threading03_queue.py</span></span><br><span class="line"><span class="string">output:</span></span><br><span class="line"><span class="string">[[1, 4, 9], [16, 25, 36], [49, 49, 49], [25, 25, 25]]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>



<p>At Line 17,one thread for one elem in data array. </p>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock:"></a>Lock:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> A, lock</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        A += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'job1'</span>,A)</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> A, lock</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        A += <span class="number">10</span></span><br><span class="line">        print(<span class="string">'job2'</span>,A)</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    A = <span class="number">0</span></span><br><span class="line">    t1 = threading.Thread(target=job1)</span><br><span class="line">    t2 = threading.Thread(target=job2)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line">job1 <span class="number">1</span></span><br><span class="line">job1 <span class="number">2</span></span><br><span class="line">job1 <span class="number">3</span></span><br><span class="line">job1 <span class="number">4</span></span><br><span class="line">job1 <span class="number">5</span></span><br><span class="line">job1 <span class="number">6</span></span><br><span class="line">job1 <span class="number">7</span></span><br><span class="line">job1 <span class="number">8</span></span><br><span class="line">job1 <span class="number">9</span></span><br><span class="line">job1 <span class="number">10</span></span><br><span class="line">job2 <span class="number">20</span></span><br><span class="line">job2 <span class="number">30</span></span><br><span class="line">job2 <span class="number">40</span></span><br><span class="line">job2 <span class="number">50</span></span><br><span class="line">job2 <span class="number">60</span></span><br><span class="line">job2 <span class="number">70</span></span><br><span class="line">job2 <span class="number">80</span></span><br><span class="line">job2 <span class="number">90</span></span><br><span class="line">job2 <span class="number">100</span></span><br><span class="line">job2 <span class="number">110</span></span><br></pre></td></tr></table></figure>







<hr>
<hr>
<h2 id="Multiprocessing"><a href="#Multiprocessing" class="headerlink" title="Multiprocessing"></a>Multiprocessing</h2><h4 id="Unlike-sub-thread-checked-by-main-thread-before-existing-mt-sub-process-is-not-checked-by-main-process-before-main-process-exists…"><a href="#Unlike-sub-thread-checked-by-main-thread-before-existing-mt-sub-process-is-not-checked-by-main-process-before-main-process-exists…" class="headerlink" title="Unlike sub-thread checked by main-thread before existing mt, sub-process is not checked by main-process before main-process exists…"></a>Unlike sub-thread checked by main-thread before existing mt, <em>sub-process is not checked by main-process</em> before main-process exists…</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">daemon</span><span class="params">()</span>:</span></span><br><span class="line">    p = multiprocessing.current_process()</span><br><span class="line">    print(<span class="string">'Starting:'</span>, p.name, p.pid)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'Exiting :'</span>, p.name, p.pid)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">non_daemon</span><span class="params">()</span>:</span></span><br><span class="line">    p = multiprocessing.current_process()</span><br><span class="line">    print(<span class="string">'Starting:'</span>, p.name, p.pid)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    print(<span class="string">'Exiting :'</span>, p.name, p.pid)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    d = multiprocessing.Process(</span><br><span class="line">        name=<span class="string">'daemon'</span>,</span><br><span class="line">        target=daemon,</span><br><span class="line">    )</span><br><span class="line">    d.daemon = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    n = multiprocessing.Process(</span><br><span class="line">        name=<span class="string">'non-daemon'</span>,</span><br><span class="line">        target=non_daemon,</span><br><span class="line">    )</span><br><span class="line">    n.daemon = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    d.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    n.start()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># Starting: daemon 41838</span></span><br><span class="line"><span class="comment"># Starting: non-daemon 41841</span></span><br><span class="line"><span class="comment"># Exiting : non-daemon 41841</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d.join()    <span class="comment"># to print out "Exiting : daemon"</span></span><br><span class="line"><span class="comment">#Starting: daemon 51987</span></span><br><span class="line"><span class="comment">#Starting: non-daemon 51988</span></span><br><span class="line"><span class="comment">#Exiting : non-daemon 51988</span></span><br><span class="line"><span class="comment">#Exiting : daemon 51987</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    d.join(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'d.is_alive()'</span>, d.is_alive())</span><br><span class="line">    n.join()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># Starting: non-daemon</span></span><br><span class="line"><span class="comment"># Exiting : non-daemon</span></span><br><span class="line"><span class="comment"># d.is_alive() True</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Since TIMEOUT of join() smaller than it’s time of sleep, d.is_alive() is True and forced to terminated weith the existing of Main Process.</li>
</ul>
<p>Ref: <a href="https://juejin.im/post/5c07b27af265da611b58234c" target="_blank" rel="noopener">https://juejin.im/post/5c07b27af265da611b58234c</a></p>
<hr>
<hr>
<h2 id="Subprocessing"><a href="#Subprocessing" class="headerlink" title="Subprocessing"></a>Subprocessing</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>但是如果你使用了管道，而又不去处理管道的输出，那么小心点，如果子进程输出数据过多，死锁就会发生了，比如下面的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#96;&#96;&#x3D;&#96;&#96;subprocess.Popen(&#96;&#96;&quot;longprint&quot;&#96;&#96;, shell&#96;&#96;&#x3D;&#96;&#96;True&#96;&#96;, stdout&#96;&#96;&#x3D;&#96;&#96;subprocess.PIPE, stderr&#96;&#96;&#x3D;&#96;&#96;subprocess.STDOUT) &#96;&#96;p.wait()</span><br></pre></td></tr></table></figure>

<p>longprint是一个假想的有大量输出的进程，那么在我的xp, Python2.5的环境下，当输出达到4096时，死锁就发生了。当然，如果我们用p.stdout.readline或者p.communicate去清理输出，那么无论输出多少，死锁都是不会发生的。或者我们不使用管道，比如不做重定向，或者重定向到文件，也都是可以避免死锁的。</p>
<p>Ref: <a href="http://xstarcd.github.io/wiki/Python/python_subprocess_study.html" target="_blank" rel="noopener">http://xstarcd.github.io/wiki/Python/python_subprocess_study.html</a></p>
<h3 id="Copy-on-write"><a href="#Copy-on-write" class="headerlink" title="Copy-on-write"></a>Copy-on-write</h3><h3 id="join-–-等子進程結束後再往下走"><a href="#join-–-等子進程結束後再往下走" class="headerlink" title="join() –  等子進程結束後再往下走"></a>join() –  等子進程結束後再往下走</h3><p>Following copied from : <a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html" target="_blank" rel="noopener">http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-process-thread.html</a></p>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"Run task %s (%s)..."</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"Task %s run %0.f seconds."</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"Parent process %s."</span> % os.getpid())</span><br><span class="line">    p = Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(<span class="string">"Waiting for all subprocess done..."</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">"All subprocess done."</span>)</span><br></pre></td></tr></table></figure>



<p>一篇文章搞懂Python中的进程和线程</p>
<p> Nov 28 2016  •  diggzhang<br> 11543˚C</p>
<p><a href="https://diggzhang.github.io/tags/" target="_blank" rel="noopener">python</a> <a href="https://diggzhang.github.io/tags/" target="_blank" rel="noopener">编程理论</a></p>
<p>进程 线程 廖老师的梗</p>
<h2 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h2><p><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir0" target="_blank" rel="noopener">Directory</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir1" target="_blank" rel="noopener">多进程 multiprocessing</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir2" target="_blank" rel="noopener">进程池 Pool</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir3" target="_blank" rel="noopener">子进程</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir4" target="_blank" rel="noopener">进程间通信</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir5" target="_blank" rel="noopener">进程小结</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir6" target="_blank" rel="noopener">多线程</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir7" target="_blank" rel="noopener">Lock</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir8" target="_blank" rel="noopener">多核CPU</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir9" target="_blank" rel="noopener">ThreadLocal</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir10" target="_blank" rel="noopener">进程 vs. 线程</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir11" target="_blank" rel="noopener">线程切换</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir12" target="_blank" rel="noopener">计算密集型 vs. IO密集型</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir13" target="_blank" rel="noopener">异步IO</a><br><a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html#dir14" target="_blank" rel="noopener">分布式进程</a></p>
<p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<p>使用<code>top</code>命令看有哪些进程在跑:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Processes: 371 total, 2 running, 15 stuck, 354 sleeping, 3142 threads  17:27:27</span><br><span class="line">Load Avg: 2.57, 2.29, 2.07  CPU usage: 5.26% user, 4.79% sys, 89.94% idle</span><br><span class="line">SharedLibs: 151M resident, 18M data, 17M linkedit.</span><br><span class="line">MemRegions: 107884 total, 6773M resident, 131M private, 2803M shared.</span><br><span class="line">PhysMem: 15G used (2386M wired), 988M unused.</span><br><span class="line">VM: 1564G vsize, 527M framework vsize, 20146031(0) swapins, 21455983(0) swapouts</span><br><span class="line">Networks: packets: 39381163&#x2F;32G in, 38877596&#x2F;18G out.</span><br><span class="line">Disks: 4762039&#x2F;190G read, 7146822&#x2F;247G written.</span><br><span class="line"></span><br><span class="line">PID    COMMAND      %CPU TIME     #TH   #WQ  #PORT MEM    PURG   CMPRS  PGRP</span><br><span class="line">96223- Microsoft Ex 0.1  15:30.25 356   2    2216  46M    0B     298M   96223</span><br><span class="line">96200  Microsoft AU 0.0  00:11.45 5     0    169   5956K  0B     2480K  96200</span><br><span class="line">91030  nwjs Helper  0.0  02:06.91 9     0    139   2920K  0B     15M    91027</span><br><span class="line">91029  nwjs Helper  0.0  02:37:00 21    0    178   650M   10M    70M    91027</span><br><span class="line">91028  nwjs Helper  0.0  19:01.66 5     0    76    34M    0B     9464K  91027</span><br></pre></td></tr></table></figure>

<p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>
<p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像<code>Word</code>这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核<code>CPU</code>才可能实现。</p>
<p>我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？</p>
<p>有两种解决方案：</p>
<ul>
<li>一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</li>
<li>还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</li>
<li>当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</li>
</ul>
<p>总结一下就是，多任务的实现有3种方式：</p>
<ul>
<li>多进程模式；</li>
<li>多线程模式；</li>
<li>多进程+多线程模式。</li>
</ul>
<p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p>
<p>多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。</p>
<p>来啊，征服进程和线程，越过Python学习的一个大坎儿吧。</p>
<h3 id="多进程-multiprocessing"><a href="#多进程-multiprocessing" class="headerlink" title="多进程 multiprocessing"></a>多进程 multiprocessing</h3><p>这里有个前菜：</p>
<blockquote>
<p>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
</blockquote>
<blockquote>
<p>子进程永远返回<code>0</code>，而父进程返回子进程的<code>ID</code>。这样做的理由是，一个父进程可以<code>fork</code>出很多子进程，所以，父进程要记下每个子进程的<code>ID</code>，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的<code>ID</code>。</p>
</blockquote>
<p>Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">print(&#39;Process (%s) start...&#39; % os.getpid())</span><br><span class="line"># Only works on Unix&#x2F;Linux&#x2F;Mac:</span><br><span class="line">pid &#x3D; os.fork()</span><br><span class="line">if pid &#x3D;&#x3D; 0:</span><br><span class="line">    print(&#39;I am child process (%s) and my parent is %s.&#39; % (os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">    print(&#39;I (%s) just created a child process (%s).&#39; % (os.getpid(), pid))</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Process (69673) start ...</span><br><span class="line">I (69673) just created a child Process(69674)</span><br><span class="line">I am child proces (69674) and my parent is 69673.</span><br></pre></td></tr></table></figure>

<p>有了<code>fork</code>调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的<code>Apache</code>服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p>
<p>但是这个<code>fork</code>在windows操作系统是没有的。于是出现了处理<code>fork</code>的通用模块，以保证在不同操作系统间的调用。</p>
<p><code>multiprocessing</code>模块就是跨平台版本的多进程模块。</p>
<p><code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># coding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">    子进程要执行的代码</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def run_proc(name):</span><br><span class="line">    print(&#39;Run child process %s (%s)&#39; % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(&#39;Parent process %s.&#39; % os.getpid())</span><br><span class="line">    p &#x3D; Process(target&#x3D;run_proc, args&#x3D;(&#39;test_code&#39;,))</span><br><span class="line">    print(&#39;Child process will start.&#39;)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&#39;Child process end.&#39;)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python forkbymutilprocessing.py</span><br><span class="line">Parent process 70227.</span><br><span class="line">Child process will start.</span><br><span class="line">Run child process test_code (70228)</span><br><span class="line">Child process end.</span><br></pre></td></tr></table></figure>

<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p>
<p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>
<h3 id="进程池-Pool"><a href="#进程池-Pool" class="headerlink" title="进程池 Pool"></a>进程池 Pool</h3><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line">def long_time_task(name):</span><br><span class="line">    print(&quot;Run task %s (%s)...&quot; % (name, os.getpid()))</span><br><span class="line">    start &#x3D; time.time()</span><br><span class="line">    time.sleep(random.random() * 3)</span><br><span class="line">    end &#x3D; time.time()</span><br><span class="line">    print(&quot;Task %s run %0.f seconds.&quot; % (name, (end - start)))</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    print(&quot;Parent process %s.&quot; % os.getpid())</span><br><span class="line">    p &#x3D; Pool(4)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        p.apply_async(long_time_task, args&#x3D;(i,))</span><br><span class="line">    print(&quot;Waiting for all subprocess done...&quot;)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&quot;All subprocess done.&quot;)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜ python3 testpool.py</span><br><span class="line">Parent process 65899.</span><br><span class="line">Waiting for all subprocess done...</span><br><span class="line">Run task 0 (65900)...</span><br><span class="line">Run task 1 (65901)...</span><br><span class="line">Run task 2 (65902)...</span><br><span class="line">Run task 3 (65903)...</span><br><span class="line">Task 3 run 0 seconds.</span><br><span class="line">Run task 4 (65903)...</span><br><span class="line">Task 2 run 1 seconds.</span><br><span class="line">Task 0 run 2 seconds.</span><br><span class="line">Task 1 run 2 seconds.</span><br><span class="line">Task 4 run 2 seconds.</span><br><span class="line">All subprocess done.</span><br></pre></td></tr></table></figure>

<p>代码解读：</p>
<p>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p>
<p>注意输出的结果，task<code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>是立刻执行的，而task<code>4</code>要等待前面某个task完成后才执行，这是因为<code>Pool</code>的默认大小设置成了<code>4</code>(<code>p = Pool(4)</code>)，代表着最多同时执行4个进程。这是<code>Pool</code>有意设计的限制，并不是操作系统的限制。如果改成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; Pool(5)</span><br></pre></td></tr></table></figure>

<p>就可以跑5个进程了。</p>
<p>由于<code>Pool</code>的默认大小是CPU的核数，如果你拥有8核CPU，提交至少9个子进程才能看到上面的等待效果。</p>
<h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。当试图通过python做一些运维工作的时候，<code>subprocess</code>简直是顶梁柱。</p>
<p><code>subprocess</code>模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</p>
<p>下面的例子演示了如何在Python代码中运行命令<code>nslookup &lt;某个域名&gt;</code>，这和命令行直接运行的效果是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># coding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">print(&quot;$ nslookup www.yangcongchufang.com&quot;)</span><br><span class="line">r &#x3D; subprocess.call([&#39;nslookup&#39;, &#39;www.yangcongchufang.com&#39;])</span><br><span class="line">print(&quot;Exit code: &quot;, r)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜ python subcall.py</span><br><span class="line">$ nslookup www.yangcongchufang.com</span><br><span class="line">Server:		219.141.136.10</span><br><span class="line">Address:	219.141.136.10#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:	www.yangcongchufang.com</span><br><span class="line">Address: 103.245.222.133</span><br><span class="line"></span><br><span class="line">(&#39;Exit code: &#39;, 0)</span><br></pre></td></tr></table></figure>

<p>如果子进程还需要输入，则可以通过<code>communicate()</code>方法输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># coding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">print(&quot;$ nslookup&quot;)</span><br><span class="line">p &#x3D; subprocess.Popen([&#39;nslookup&#39;], stdin&#x3D;subprocess.PIPE, stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.PIPE)</span><br><span class="line">output, err &#x3D; p.communicate(b&quot;set q&#x3D;mx\nyangcongchufang.com\nexit\n&quot;)</span><br><span class="line">print(output.decode(&quot;utf-8&quot;))</span><br><span class="line">print(&quot;Exit code:&quot;, p.returncode)</span><br></pre></td></tr></table></figure>

<p>上面的代码相当于在命令行执行命令<code>nslookup</code>，然后手动输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set q&#x3D;mx</span><br><span class="line">yangcongchufang.com</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p><code>Process</code>之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p>
<p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># _*_ coding:utf-8 _*_</span><br><span class="line"></span><br><span class="line">from multiprocessing import Process, Queue</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line"># 写数据进程执行的代码</span><br><span class="line">def write(q):</span><br><span class="line">    print(&quot;Process to write: %s&quot; % os.getpid())</span><br><span class="line">    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:</span><br><span class="line">        print(&quot;Put %s to queue...&quot; % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"># 读数据进程执行的代码</span><br><span class="line">def read(q):</span><br><span class="line">    print(&quot;Process to read: %s&quot; % os.getpid())</span><br><span class="line">    while True:</span><br><span class="line">        value &#x3D; q.get(True)</span><br><span class="line">        print(&quot;Get %s from queue.&quot; % value)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 父进程创建Queue,并传给各个子进程</span><br><span class="line">    q &#x3D; Queue()</span><br><span class="line">    pw &#x3D; Process(target&#x3D;write, args&#x3D;(q,))</span><br><span class="line">    pr &#x3D; Process(target&#x3D;read, args&#x3D;(q,))</span><br><span class="line">    # 启动子进程pw，写入：</span><br><span class="line">    pw.start()</span><br><span class="line">    # 启动子进程pr，读取：</span><br><span class="line">    pr.start()</span><br><span class="line">    # 等待pw结束</span><br><span class="line">    pw.join()</span><br><span class="line">    # pr进程里的死循环，无法等待结束，只能强制终止</span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure>

<p>实际执行效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python process_comm.py</span><br><span class="line">Process to write: 94327</span><br><span class="line">Put A to queue...</span><br><span class="line">Process to read: 94328</span><br><span class="line">Get A from queue.</span><br><span class="line">Put B to queue...</span><br><span class="line">Get B from queue.</span><br><span class="line">Put C to queue...</span><br><span class="line">Get C from queue.</span><br></pre></td></tr></table></figure>

<p>在<code>Unix/Linux</code>下，<code>multiprocessing</code>模块封装了<code>fork()</code>调用，使我们不需要关注<code>fork()</code>的细节。由于<code>Windows</code>没有<code>fork</code>调用，因此，<code>multiprocessing</code>需要“模拟”出<code>fork</code>的效果，父进程所有<code>Python</code>对象必须通过<code>pickle</code>序列化再传到子进程去，所有，如果<code>multiprocessing</code>在<code>Windows</code>下调用失败了，要先考虑是不是<code>pickle</code>失败了。</p>
<h3 id="进程小结"><a href="#进程小结" class="headerlink" title="进程小结"></a>进程小结</h3><p>在<code>Unix/Linux</code>下，可以使用<code>fork()</code>调用实现多进程。</p>
<p>要实现跨平台的多进程，可以使用<code>multiprocessing</code>模块。</p>
<p>进程间通信是通过<code>Queue</code>、<code>Pipes</code>等实现的。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p>
<p>我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。</p>
<p>由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的<code>Posix Thread</code>，而不是模拟出来的线程。</p>
<p>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p>
<p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># _*_ coding:utf-8 _*_</span><br><span class="line">import time, threading</span><br><span class="line"></span><br><span class="line">def loop():</span><br><span class="line">    print(&#39;thread %s is running...&#39; % threading.current_thread().name)</span><br><span class="line">    n &#x3D; 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n &#x3D; n + 1</span><br><span class="line">        print(&#39;thread %s &gt;&gt;&gt; %s&#39; % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    print(&#39;thread %s ended.&#39; % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(&#39;thread %s is running...&#39; % threading.current_thread().name)</span><br><span class="line">t &#x3D; threading.Thread(target&#x3D;loop, name&#x3D;&#39;LoopThread&#39;)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(&#39;thread %s ended.&#39; % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"># 执行效果：</span><br><span class="line">$ python3 thread_test.py</span><br><span class="line">thread MainThread is running...</span><br><span class="line">thread LoopThread is running...</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 1</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 2</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 3</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 4</span><br><span class="line">thread LoopThread &gt;&gt;&gt; 5</span><br><span class="line">thread LoopThread ended.</span><br><span class="line">thread MainThread ended.</span><br></pre></td></tr></table></figure>

<p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前的线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为<code>Thread-1</code>，<code>Thread-2</code>……</p>
<h3 id="Lock-1"><a href="#Lock-1" class="headerlink" title="Lock"></a>Lock</h3><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时修改一个变量，把内容给改乱了。</p>
<p>来看看多个线程同时操作一个变量怎么把内容给改乱了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># _*_ coding:utf-8 _*_</span><br><span class="line">import time, threading</span><br><span class="line"></span><br><span class="line"># 假定这是你银行的存款</span><br><span class="line">balance &#x3D; 0</span><br><span class="line"></span><br><span class="line">def change_it(n):</span><br><span class="line">    # 先存后取，结果应该是0</span><br><span class="line">    global balance</span><br><span class="line">    balance &#x3D; balance + n</span><br><span class="line">    balance &#x3D; balance - n</span><br><span class="line">    print balance</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        change_it(n)</span><br><span class="line"></span><br><span class="line">t1 &#x3D; threading.Thread(target&#x3D;run_thread, args&#x3D;(5,))</span><br><span class="line">t2 &#x3D; threading.Thread(target&#x3D;run_thread, args&#x3D;(8,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(balance)</span><br></pre></td></tr></table></figure>

<p>我们定义了一个共享变量<code>balance</code>，初始值为<code>0</code>，并且启动两个线程，先存后取，理论上结果应该为<code>0</code>，但是，由于线程的调度是由操作系统决定的，当<code>t1</code>、<code>t2</code>交替执行时，只要循环次数足够多，<code>balance</code>的结果就不一定是<code>0</code>了。</p>
<p>实际执行效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python thread_share_var.py</span><br><span class="line">31</span><br><span class="line">$ python thread_share_var.py</span><br><span class="line">42</span><br><span class="line">$ python thread_share_var.py</span><br><span class="line">-6</span><br><span class="line">$ python thread_share_var.py</span><br><span class="line">0</span><br><span class="line">$ python thread_share_var.py</span><br><span class="line">7</span><br><span class="line">$ python thread_share_var.py</span><br><span class="line">13</span><br></pre></td></tr></table></figure>

<p>究其原因，是因为修改balance需要多条语句，而执行这几条语句时，线程可能中断，从而导致多个线程把同一个对象的内容改乱了。</p>
<p>两个线程同时一存一取，就可能导致余额不对，你肯定不希望你的银行存款莫名其妙地变成了负数，所以，我们必须确保一个线程在修改<code>balance</code>的时候，别的线程一定不能改。</p>
<p>如果我们要确保<code>balance</code>计算正确，就要给<code>change_it()</code>上一把锁，当某个线程开始执行<code>change_it()</code>时，我们说，该线程因为获得了锁，因此其他线程不能同时执行<code>change_it()</code>，只能等待，直到锁被释放后，获得该锁以后才能改。由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过<code>threading.Lock()</code>来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">balance &#x3D; 0</span><br><span class="line">lock &#x3D; threading.Lock()</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        # 先要获取锁:</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            # 放心地改吧:</span><br><span class="line">            change_it(n)</span><br><span class="line">        finally:</span><br><span class="line">            # 改完了一定要释放锁:</span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure>

<p>加锁以后实现的实际效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python thread_share_var.py</span><br><span class="line">0</span><br><span class="line">$ python thread_share_var.py</span><br><span class="line">0</span><br><span class="line">$ python thread_share_var.py</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p>
<p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p>
<p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p>
<h3 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h3><p>如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。</p>
<p>如果写一个死循环的话，会出现什么情况呢？</p>
<p>打开<code>Mac OS X</code>的<code>Activity Monitor</code>，或者<code>Windows</code>的<code>Task Manager</code>，都可以监控某个进程的CPU使用率。</p>
<p>我们可以监控到一个死循环线程会<code>100%</code>占用一个CPU。</p>
<p>如果有两个死循环线程，在多核CPU中，可以监控到会占用<code>200%</code>的CPU，也就是占用两个CPU核心。</p>
<p>要想把N核CPU的核心全部跑满，就必须启动N个死循环线程。</p>
<p>试试用Python写个死循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># _*_ coding:utf-8 _*_</span><br><span class="line">import threading, multiprocessing</span><br><span class="line"></span><br><span class="line">def loop():</span><br><span class="line">    x &#x3D; 0</span><br><span class="line">    while True:</span><br><span class="line">        x &#x3D; x ^ 1</span><br><span class="line"></span><br><span class="line">for i in range(multiprocessing.cpu_count()):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;loop)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<p>跑起来就知道什么叫，自己写的bug自己都收不了场了。生活只教会了我们谦逊和努力，然而bug却教会了我们如何抓狂起来。</p>
<p>上面的程序，启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核。</p>
<p>但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p>
<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个<code>GIL</code>锁：<code>Global Interpreter Lock</code>，任何Python线程执行前，必须先获得<code>GIL</code>锁，然后，<code>每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。</code>这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p><code>GIL</code>是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的<code>CPython</code>，要真正利用多核，除非重写一个不带GIL的解释器。</p>
<p>所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p>
<p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
<p>总结一下。</p>
<p>多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。</p>
<p>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</p>
<p>但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def process_student(name):</span><br><span class="line">    std &#x3D; Student(name)</span><br><span class="line">    # std是局部变量，但是每个函数都要用到它，因此必须传进去</span><br><span class="line">    do_task_1(std)</span><br><span class="line">    do_task_2(std)</span><br><span class="line"></span><br><span class="line">def do_task_1(std):</span><br><span class="line">    do_subtask_1(std)</span><br><span class="line">    do_subtask_2(std)</span><br><span class="line"></span><br><span class="line">def do_task_2(std):</span><br><span class="line">    do_subtask_2(std)</span><br><span class="line">    do_subtask_2(std)</span><br></pre></td></tr></table></figure>

<p>每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理的不同<code>Student</code>对象，不能共享。</p>
<p>如果用一个全局<code>dict</code>存放所有的<code>Student</code>对象，然后以<code>thread</code>自身作为<code>key</code>获得线程对应的<code>Student</code>对象如何？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">global_dict &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">def std_thread(name):</span><br><span class="line">    std &#x3D; Student(name)</span><br><span class="line">    # 把std放到全局变量global_dict中：</span><br><span class="line">    global_dict[threading.current_thread()] &#x3D; std</span><br><span class="line">    do_task_1()</span><br><span class="line">    do_task_2()</span><br><span class="line"></span><br><span class="line">def do_task_1():</span><br><span class="line">    # 不传入std,而是根据当前线程查找：</span><br><span class="line">    std &#x3D; global_dict[threading.current_thread()]</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">def do_task_2(arg):</span><br><span class="line">    # 任何函数都可以查找出当前线程的std变量</span><br><span class="line">    std &#x3D; global_dict[threading.current_thread()]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这种方式理论上是可行的，它最大的优点是消除了<code>std</code>对象在每层函数中的传递问题，但是，每个函数获取<code>std</code>的代码有点丑。</p>
<p>有没有更简单的方式？</p>
<p><code>ThreadLocal</code>应运而生，不用查找<code>dict</code>，<code>ThreadLocal</code>帮你自动做这件事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># _*_ coding:utf-8 _*_</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># 创建全局ThreadLocal对象：</span><br><span class="line">local_school &#x3D; threading.local()</span><br><span class="line"></span><br><span class="line">def process_student():</span><br><span class="line">    # 获取当前线程关联的student</span><br><span class="line">    std &#x3D; local_school.student</span><br><span class="line">    print(&#39;Hello, %s (in %s)&#39; % (std, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">def process_thread(name):</span><br><span class="line">    # 绑定ThreadLocal的student</span><br><span class="line">    local_school.student &#x3D; name</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 &#x3D; threading.Thread(target&#x3D;process_thread, args&#x3D;(&#39;Alice&#39;,), name&#x3D;&#39;Thread-A&#39;)</span><br><span class="line">t2 &#x3D; threading.Thread(target&#x3D;process_thread, args&#x3D;(&#39;Bob&#39;,), name&#x3D;&#39;Thread-B&#39;)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line"># 执行结果</span><br><span class="line">$ python thread_local.py</span><br><span class="line">Hello, Alice (in Thread-A)</span><br><span class="line"> Hello, Bob (in Thread-B)</span><br><span class="line">$ python thread_local.py</span><br><span class="line">Hello, Alice (in Thread-A)</span><br><span class="line">Hello, Bob (in Thread-B)</span><br></pre></td></tr></table></figure>

<p>全局变量<code>local_school</code>就是一个<code>ThreadLocal</code>对象，每个<code>Thread</code>对它都可以读写<code>student</code>属性，但互不影响。你可以把<code>local_school</code>看成是全局变量，但每个属性例如<code>local_school.student</code>都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，<code>ThreadLocal</code>内部会处理。</p>
<p>可以理解为全局变量<code>local_school</code>是一个<code>dict</code>，不但可以用<code>local_school.student</code>，还可以绑定其它变量，如<code>local_school.teacher</code>等等。</p>
<p><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，<code>HTTP</code>请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
<p>一个<code>ThreadLocal</code>变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。<code>ThreadLocal</code>解决了参数在一个线程中各个函数之间互相传递的问题。</p>
<h3 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs. 线程"></a>进程 vs. 线程</h3><p>我们介绍了多进程和多线程，这是实现多任务最常用的两种方式。现在，我们来讨论一下这两种方式的优缺点。</p>
<p>首先，要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</p>
<p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</p>
<p>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p>
<p>多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p>
<p>多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p>
<p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>
<p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p>
<h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？</p>
<p>我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。</p>
<p>如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型，或者批处理任务模型。</p>
<p>假设你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以幼儿园小朋友的眼光来看，你就正在同时写5科作业。</p>
<p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</p>
<p>所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。</p>
<h3 id="计算密集型-vs-IO密集型"><a href="#计算密集型-vs-IO密集型" class="headerlink" title="计算密集型 vs. IO密集型"></a>计算密集型 vs. IO密集型</h3><p>是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。</p>
<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p>
<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>
<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>
<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。</p>
<p>现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。</p>
<p>对应到Python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。</p>
<h3 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h3><p>在<code>Thread</code>和<code>Process</code>中，应当优选<code>Process</code>，因为<code>Process</code>更稳定，而且，<code>Process</code>可以分布到多台机器上，而<code>Thread</code>最多只能分布到同一台机器的多个CPU上。</p>
<p>Python的<code>multiprocessing</code>模块不但支持多进程，其中<code>managers</code>子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于<code>managers</code>模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p>
<p>举个例子：如果我们已经有一个通过<code>Queue</code>通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p>
<p>原有的<code>Queue</code>可以继续使用，但是，通过<code>managers</code>模块把<code>Queue</code>通过网络暴露出去，就可以让其他机器的进程访问<code>Queue</code>了。</p>
<p>我们先看服务进程，服务进程负责启动<code>Queue</code>，把Queue注册到网络上，然后往Queue里面写入任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># _*_ coding:utf-8 _*_</span><br><span class="line">import random, time, queue</span><br><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line"></span><br><span class="line"># the queue of send tasks</span><br><span class="line">task_queue &#x3D; queue.Queue()</span><br><span class="line"># the queue of recive tasks</span><br><span class="line">result_queue &#x3D; queue.Queue()</span><br><span class="line"></span><br><span class="line"># cong BaseManager jicheng de QueueManager</span><br><span class="line">class QueueManager(BaseManager):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span><br><span class="line">QueueManager.register(&#39;get_task_queue&#39;, callable&#x3D;lambda: task_queue)</span><br><span class="line">QueueManager.register(&#39;get_result_queue&#39;, callable&#x3D;lambda: result_queue)</span><br><span class="line"></span><br><span class="line"># 绑定端口5000, 设置验证码&#39;abc&#39;:</span><br><span class="line">manager &#x3D; QueueManager(address&#x3D;(&#39;&#39;, 5000), authkey&#x3D;b&#39;abc&#39;)</span><br><span class="line"></span><br><span class="line"># 启动Queue</span><br><span class="line">manager.start()</span><br><span class="line"></span><br><span class="line"># 获得通过网络访问的Queue对象</span><br><span class="line">task &#x3D; manager.get_task_queue()</span><br><span class="line">result &#x3D; manager.get_result_queue()</span><br><span class="line"></span><br><span class="line"># 放几个任务进去</span><br><span class="line">for i in range(10):</span><br><span class="line">    n &#x3D; random.randint(0, 10000)</span><br><span class="line">    print(&#39;Put task %d...&#39; % n)</span><br><span class="line">    task.put(n)</span><br><span class="line"></span><br><span class="line"># 从result队列读取结果:</span><br><span class="line">print(&#39;Try get results...&#39;)</span><br><span class="line">for i in range(10):</span><br><span class="line">    r &#x3D; result.get(timeout&#x3D;10)</span><br><span class="line">    print(&#39;Result: %s&#39; % r)</span><br><span class="line"></span><br><span class="line"># Close</span><br><span class="line">manager.shutdown()</span><br><span class="line">print(&#39;master exit.&#39;)</span><br></pre></td></tr></table></figure>

<p>请注意，当我们在一台机器上写多进程程序时，创建的<code>Queue</code>可以直接拿来用，但是，在分布式多进程环境下，添加任务到<code>Queue</code>不可以直接对原始的<code>task_queue</code>进行操作，那样就绕过了<code>QueueManager</code>的封装，必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加。</p>
<p>然后，在另一台机器上启动任务进程（本机上启动也可以）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># task_worker.py</span><br><span class="line"></span><br><span class="line">import time, sys, queue</span><br><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line"></span><br><span class="line"># 创建类似的QueueManager:</span><br><span class="line">class QueueManager(BaseManager):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span><br><span class="line">QueueManager.register(&#39;get_task_queue&#39;)</span><br><span class="line">QueueManager.register(&#39;get_result_queue&#39;)</span><br><span class="line"></span><br><span class="line"># 连接到服务器，也就是运行task_master.py的机器:</span><br><span class="line">server_addr &#x3D; &#39;127.0.0.1&#39;</span><br><span class="line">print(&#39;Connect to server %s...&#39; % server_addr)</span><br><span class="line"># 端口和验证码注意保持与task_master.py设置的完全一致:</span><br><span class="line">m &#x3D; QueueManager(address&#x3D;(server_addr, 5000), authkey&#x3D;b&#39;abc&#39;)</span><br><span class="line"># 从网络连接:</span><br><span class="line">m.connect()</span><br><span class="line"># 获取Queue的对象:</span><br><span class="line">task &#x3D; m.get_task_queue()</span><br><span class="line">result &#x3D; m.get_result_queue()</span><br><span class="line"># 从task队列取任务,并把结果写入result队列:</span><br><span class="line">for i in range(10):</span><br><span class="line">    try:</span><br><span class="line">        n &#x3D; task.get(timeout&#x3D;1)</span><br><span class="line">        print(&#39;run task %d * %d...&#39; % (n, n))</span><br><span class="line">        r &#x3D; &#39;%d * %d &#x3D; %d&#39; % (n, n, n*n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        result.put(r)</span><br><span class="line">    except Queue.Empty:</span><br><span class="line">        print(&#39;task queue is empty.&#39;)</span><br><span class="line"># 处理结束:</span><br><span class="line">print(&#39;worker exit.&#39;)</span><br></pre></td></tr></table></figure>

<p>任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。</p>
<p>现在，可以试试分布式进程的工作效果了。先启动<code>task_master.py</code>服务进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python3 task_master.py</span><br><span class="line">Put task 3411...</span><br><span class="line">Put task 1605...</span><br><span class="line">Put task 1398...</span><br><span class="line">Put task 4729...</span><br><span class="line">Put task 5300...</span><br><span class="line">Put task 7471...</span><br><span class="line">Put task 68...</span><br><span class="line">Put task 4219...</span><br><span class="line">Put task 339...</span><br><span class="line">Put task 7866...</span><br><span class="line">Try get results...</span><br></pre></td></tr></table></figure>

<p><code>task_master.py</code>进程发送完任务后，开始等待<code>result</code>队列的结果。现在启动<code>task_worker.py</code>进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python3 task_worker.py</span><br><span class="line">Connect to server 127.0.0.1...</span><br><span class="line">run task 3411 * 3411...</span><br><span class="line">run task 1605 * 1605...</span><br><span class="line">run task 1398 * 1398...</span><br><span class="line">run task 4729 * 4729...</span><br><span class="line">run task 5300 * 5300...</span><br><span class="line">run task 7471 * 7471...</span><br><span class="line">run task 68 * 68...</span><br><span class="line">run task 4219 * 4219...</span><br><span class="line">run task 339 * 339...</span><br><span class="line">run task 7866 * 7866...</span><br><span class="line">worker exit.</span><br></pre></td></tr></table></figure>

<p><code>task_worker.py</code>进程结束，在<code>task_master.py</code>进程中会继续打印出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Result: 3411 * 3411 &#x3D; 11634921</span><br><span class="line">Result: 1605 * 1605 &#x3D; 2576025</span><br><span class="line">Result: 1398 * 1398 &#x3D; 1954404</span><br><span class="line">Result: 4729 * 4729 &#x3D; 22363441</span><br><span class="line">Result: 5300 * 5300 &#x3D; 28090000</span><br><span class="line">Result: 7471 * 7471 &#x3D; 55815841</span><br><span class="line">Result: 68 * 68 &#x3D; 4624</span><br><span class="line">Result: 4219 * 4219 &#x3D; 17799961</span><br><span class="line">Result: 339 * 339 &#x3D; 114921</span><br><span class="line">Result: 7866 * 7866 &#x3D; 61873956</span><br></pre></td></tr></table></figure>

<p>这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算n*n的代码换成发送邮件，就实现了邮件队列的异步发送。</p>
<p>Queue对象存储在哪？注意到<code>task_worker.py</code>中根本没有创建Queue的代码，所以，Queue对象存储在<code>task_master.py</code>进程中。</p>
<p>而Queue之所以能通过网络访问，就是通过<code>QueueManager</code>实现的。由于<code>QueueManager</code>管理的不止一个Queue，所以，要给每个Queue的网络调用接口起个名字，比如<code>get_task_queue</code>。</p>
<p><code>authkey</code>有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果<code>task_worker.py</code>的<code>authkey</code>和<code>task_master.py</code>的<code>authkey</code>不一致，肯定连接不上。</p>
<p>Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。</p>
<p>注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</p>
<p>Ref: <a href="http://yangcongchufang.com/高级python编程基础/python-process-thread.html" target="_blank" rel="noopener">http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-process-thread.html</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/12/19/C++/2017-12-19-.a,%20.so,%20and%20DLL/">C++/2017-12-19-.a, .so, and DLL</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-12-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span><div class="content"><p>Migration from my OneNote in my local.</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g99dbljar7j31ks0qk11d.jpg" alt="image-20191124194400743"></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g99d99683mj316u0u07wh.jpg" alt="image-20191124194420542"></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g99d9ia4rpj31kg092aig.jpg" alt="image-20191124194435445"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/12/04/CVs/2017-12-04-SSH%20publickey%20on%20gitllab%20&amp;%20conda/">CVs/2017-12-04-SSH publickey on gitllab &amp; conda</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-12-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DevOps/">DevOps</a></span><div class="content"><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9oejag0wxj31hr0u0gre.jpg" alt="image-20191207195200870"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9oekmmtasj30md019t96.jpg" alt="image-20191207195318751"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@git.xxxxxx</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ conda create -n joe_py36_hpc1 python=3.6</span><br><span class="line">Fetching package metadata .....</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">532  python video_creater.py</span><br><span class="line">533  pip install Pillow</span><br><span class="line">534  python video_creater.py</span><br><span class="line">535  pip install moviepy</span><br><span class="line">536  python video_creater.py</span><br><span class="line">537  pip install ffmpy3</span><br><span class="line">538  python video_creater.py</span><br><span class="line">539  pip install opencv</span><br><span class="line">540  pip install opencv-python</span><br><span class="line">541  python video_creater.py</span><br><span class="line">542  pip install sklearn</span><br><span class="line">543  python video_creater.py</span><br><span class="line">544  <span class="built_in">history</span> | tail -20</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/11/24/DevOps/2017-11-24-Inter%20Process%20communication%20(IPC)/">DevOps/2017-11-24-Inter Process communication (IPC)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-11-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DevOps/">DevOps</a></span><div class="content"><h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><h4 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h4><p>This can be only one directional.</p>
<h5 id="Anonymous-Pipe"><a href="#Anonymous-Pipe" class="headerlink" title="Anonymous Pipe"></a>Anonymous Pipe</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp | grep 8080</span><br></pre></td></tr></table></figure>

<h5 id="Named-Pipe"><a href="#Named-Pipe" class="headerlink" title="Named Pipe"></a>Named Pipe</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfifo pp</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Pipe testing"</span> &gt; <span class="built_in">test</span> // Writing data</span><br><span class="line">cat &lt; pp // Read from pipe</span><br></pre></td></tr></table></figure>

<p>In the example above, Line2 will be blocking until Line3 is executed in other shell.</p>
<ol>
<li><p><strong>Pros: Makin sure data is really taken away by the other process.</strong></p>
</li>
<li><p><strong>Cons: One direction 2. Low efficiency.</strong></p>
</li>
</ol>
<h4 id="Advanced-Pipe"><a href="#Advanced-Pipe" class="headerlink" title="Advanced Pipe"></a>Advanced Pipe</h4><p>Popen; when a process is executed as a whole new process within current process, it’s a sub-process of current process. Also, we called it <code>Advanced Pipe</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pipes = subprocess.Popen([<span class="string">'cp'</span>, <span class="string">'-rf'</span>, src, dest], stderr=subprocess.PIPE, stdout=subprocess.PIPE)</span><br><span class="line">std_o, std_err = pipes.communicate()</span><br><span class="line"><span class="keyword">if</span> pipes.returncode != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">"Copy SC directory Failed.. &#123;&#125;"</span>.format(std_err.decode(<span class="string">'utf-8'</span>)))</span><br></pre></td></tr></table></figure>



<h4 id="Info-Queue"><a href="#Info-Queue" class="headerlink" title="Info Queue"></a>Info Queue</h4><p>Information queue can be used to solve the <code>waiting problem</code> mentioned in <code>Pipe</code>, i.e. not being blocked for the one which sends data, which is  similiar to buffer mechanism.</p>
<ol>
<li><strong>Pros: not being blocked.</strong></li>
<li><strong>Cons: time wasting for huge data. (Copy takes great amount of time to access memory)</strong></li>
</ol>
<h4 id="Shared-Memory"><a href="#Shared-Memory" class="headerlink" title="Shared Memory"></a>Shared Memory</h4><p>Shared mm can be used to solve time-wasting problem when the data copied is huge mentioned in<code>Info Queue</code>.</p>
<p>When a system loads a process, the memory it allocates is the <code>virtual memory</code> rather than the <code>physical memory</code>. Therefore, the virtual addresses fromt the two different processes can be mapped to the same part of physical memory to achieve <code>shared memory</code>  mechanism, even though the twos have disparate virtual memory spaces.</p>
<ol>
<li><p><strong>Pros: No need to wait for so long when the data copied is too large.</strong></p>
</li>
<li><p><strong>Cons: Competitive problem</strong></p>
</li>
</ol>
<h3 id="Semophore"><a href="#Semophore" class="headerlink" title="Semophore"></a>Semophore</h3><p>Competitive problem is the most serious one happened in <code>shared memory</code>. And semaphore physically acting as a counter can be adopted to solve this problem.</p>
<p>It’s just like a traffic light to tell a process whether the other one is occupiing this resource.</p>
<ol>
<li><p><strong>Pros: Have the different process accesses the resource in turn and thus solve the competitve problem.</strong></p>
</li>
<li><p><strong>Cons: LIMITATION, concisely; On one machine</strong></p>
</li>
</ol>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>The 4 mechanisms mentioned above are merely <code>IPC</code> mechanism on one machine. How if we want to make available communication btw tw machines far apart from each other?</p>
<p>Yeah, <code>Socket</code> can be used to solve this problem. </p>
<p>E.g. When we sent a http request via browser, the server returns back the corresponding data. This is what <code>socket</code> is applied in <code>IPC</code>.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/06/07/DevOps/2017-06-07-Mac-Alg-and-Dev-Configuration/">DevOps/2017-06-07-Mac-Alg-and-Dev-Configuration</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-06-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DevOps/">DevOps</a></span><div class="content"><p>#Alg &amp; Dev Configuration for a NEW Mac Pro</p>
<!--![aaa](http://img2.3png.com/efa7ac2948c7148fb02c1cfc57afe5170de6.png)
-->

<p>##Z-shell</p>
<p>##Homebrew</p>
<ol>
<li><a href="http://brew.sh" target="_blank" rel="noopener" title="install_HB">Install</a> homebrew </li>
</ol>
<p>##MacVim</p>
<ol>
<li>Add export PATH=/usr/local/bin:$PATH to .zshrc</li>
<li>brew update</li>
<li>brew install macvim </li>
<li>Run brew link macvim<br><img src="https://i.imgur.com/mOqtUOD.png" alt="aaa"><br><a href="https://imgchr.com/i/A4e9Hg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/07/A4e9Hg.md.png" alt="A4e9Hg.md.png"></a></li>
</ol>
<p>P.S. vim in the same way<br>We now have the latest versions of macvim managed by brew. Run brew update &amp;&amp; brew upgrade every once in a while to upgrade them.</p>
<!--This includes the installation of the CLI mvim and the mac application (which both point to the same thing).-->


<p>##.vimrc<br><a href="https://github.com/Joecth/gvim_Linux" target="_blank" rel="noopener">Joecth’s github</a>  setting<br>Just put .vimrc under $HOME dir (~/), all settings are done (font size, color, theme, etc. )</p>
<p>##iterm2<br>![iterm2_zshell_done](<a href="https://i.imgur.com/iq3gCAu.png" target="_blank" rel="noopener">https://i.imgur.com/iq3gCAu.png</a> =30x) <!-- .element height="50%" width="50%" --></p>
<p>##MacDown</p>
<p>##tmux</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/04/03/DevOps/2017-04-03-awk/">DevOps/2017-04-03-awk</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-04-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DevOps/">DevOps</a></span><div class="content"><p>ref from: <a href="https://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9070.html</a></p>
<p>我从netstat命令中提取了如下信息作为用例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ ``cat` `netstat``.txt``Proto Recv-Q Send-Q Local-Address          Foreign-Address             State``tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN``tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN``tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN``tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT``tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2``tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED``tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED``tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2``tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED``tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT``tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED``tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1``tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED``tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT``tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK``tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED``tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2``tcp        0      0 :::22                  :::*                        LISTEN`</span><br></pre></td></tr></table></figure>

<p>下面是最简单最常用的awk示例，其输出第1列和第4例，</p>
<ul>
<li>其中单引号中的被大括号括着的就是awk的语句，注意，其只能被单引号包含。</li>
<li>其中的$1..$n表示第几例。注：$0表示整个行。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ ``awk` `<span class="string">'&#123;print $1, $4&#125;'</span>` `netstat``.txt``Proto Local-Address``tcp 0.0.0.0:3306``tcp 0.0.0.0:80``tcp 127.0.0.1:9000``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp coolshell.cn:80``tcp :::22`</span><br></pre></td></tr></table></figure>

<p>我们再来看看awk的格式化输出，和C语言的printf没什么两样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39;&#123;printf &quot;%-8s %-8s %-8s %-18s %-22s %-15s\n&quot;,$1,$2,$3,$4,$5,$6&#125;&#39;&#96; &#96;netstat&#96;&#96;.txt&#96;&#96;Proto    Recv-Q   Send-Q   Local-Address      Foreign-Address        State&#96;&#96;tcp      0        0        0.0.0.0:3306       0.0.0.0:*              LISTEN&#96;&#96;tcp      0        0        0.0.0.0:80         0.0.0.0:*              LISTEN&#96;&#96;tcp      0        0        127.0.0.1:9000     0.0.0.0:*              LISTEN&#96;&#96;tcp      0        0        coolshell.cn:80    124.205.5.146:18245    TIME_WAIT&#96;&#96;tcp      0        0        coolshell.cn:80    61.140.101.185:37538   FIN_WAIT2&#96;&#96;tcp      0        0        coolshell.cn:80    110.194.134.189:1032   ESTABLISHED&#96;&#96;tcp      0        0        coolshell.cn:80    123.169.124.111:49809  ESTABLISHED&#96;&#96;tcp      0        0        coolshell.cn:80    116.234.127.77:11502   FIN_WAIT2&#96;&#96;tcp      0        0        coolshell.cn:80    123.169.124.111:49829  ESTABLISHED&#96;&#96;tcp      0        0        coolshell.cn:80    183.60.215.36:36970    TIME_WAIT&#96;&#96;tcp      0        4166     coolshell.cn:80    61.148.242.38:30901    ESTABLISHED&#96;&#96;tcp      0        1        coolshell.cn:80    124.152.181.209:26825  FIN_WAIT1&#96;&#96;tcp      0        0        coolshell.cn:80    110.194.134.189:4796   ESTABLISHED&#96;&#96;tcp      0        0        coolshell.cn:80    183.60.212.163:51082   TIME_WAIT&#96;&#96;tcp      0        1        coolshell.cn:80    208.115.113.92:50601   LAST_ACK&#96;&#96;tcp      0        0        coolshell.cn:80    123.169.124.111:49840  ESTABLISHED&#96;&#96;tcp      0        0        coolshell.cn:80    117.136.20.85:50025    FIN_WAIT2&#96;&#96;tcp      0        0        :::22              :::*                   LISTEN&#96;</span><br></pre></td></tr></table></figure>

<h4 id="脱掉外套"><a href="#脱掉外套" class="headerlink" title="脱掉外套"></a>脱掉外套</h4><h5 id="过滤记录"><a href="#过滤记录" class="headerlink" title="过滤记录"></a>过滤记录</h5><p>我们再来看看如何过滤记录（下面过滤条件为：第三列的值为0 &amp;&amp; 第6列的值为LISTEN）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39;$3&#x3D;&#x3D;0 &amp;&amp; $6&#x3D;&#x3D;&quot;LISTEN&quot; &#39;&#96; &#96;netstat&#96;&#96;.txt&#96;&#96;tcp        0      0 0.0.0.0:3306               0.0.0.0:*              LISTEN&#96;&#96;tcp        0      0 0.0.0.0:80                 0.0.0.0:*              LISTEN&#96;&#96;tcp        0      0 127.0.0.1:9000             0.0.0.0:*              LISTEN&#96;&#96;tcp        0      0 :::22                      :::*                   LISTEN&#96;</span><br></pre></td></tr></table></figure>

<p>其中的“==”为比较运算符。其他比较运算符：!=, &gt;, &lt;, &gt;=, &lt;=</p>
<p>我们来看看各种过滤记录的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39; $3&gt;0 &#123;print $0&#125;&#39;&#96; &#96;netstat&#96;&#96;.txt&#96;&#96;Proto Recv-Q Send-Q Local-Address          Foreign-Address             State&#96;&#96;tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED&#96;&#96;tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1&#96;&#96;tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK&#96;</span><br></pre></td></tr></table></figure>

<p>如果我们需要表头的话，我们可以引入内建变量NR：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39;$3&#x3D;&#x3D;0 &amp;&amp; $6&#x3D;&#x3D;&quot;LISTEN&quot; || NR&#x3D;&#x3D;1 &#39;&#96; &#96;netstat&#96;&#96;.txt&#96;&#96;Proto Recv-Q Send-Q Local-Address          Foreign-Address             State&#96;&#96;tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN&#96;&#96;tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN&#96;&#96;tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN&#96;&#96;tcp        0      0 :::22                  :::*                        LISTEN&#96;</span><br></pre></td></tr></table></figure>

<p>再加上格式化输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39;$3&#x3D;&#x3D;0 &amp;&amp; $6&#x3D;&#x3D;&quot;LISTEN&quot; || NR&#x3D;&#x3D;1 &#123;printf &quot;%-20s %-20s %s\n&quot;,$4,$5,$6&#125;&#39;&#96; &#96;netstat&#96;&#96;.txt&#96;&#96;Local-Address        Foreign-Address      State&#96;&#96;0.0.0.0:3306         0.0.0.0:*            LISTEN&#96;&#96;0.0.0.0:80           0.0.0.0:*            LISTEN&#96;&#96;127.0.0.1:9000       0.0.0.0:*            LISTEN&#96;&#96;:::22                :::*                 LISTEN&#96;</span><br></pre></td></tr></table></figure>

<h5 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a><strong>内建变量</strong></h5><p>说到了内建变量，我们可以来看看awk的一些内建变量：</p>
<table>
<thead>
<tr>
<th>$0</th>
<th>当前记录（这个变量中存放着整个行的内容）</th>
</tr>
</thead>
<tbody><tr>
<td>$1~$n</td>
<td>当前记录的第n个字段，字段间由FS分隔</td>
</tr>
<tr>
<td>FS</td>
<td>输入字段分隔符 默认是空格或Tab</td>
</tr>
<tr>
<td>NF</td>
<td>当前记录中的字段个数，就是有多少列</td>
</tr>
<tr>
<td>NR</td>
<td>已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。</td>
</tr>
<tr>
<td>FNR</td>
<td>当前记录数，与NR不同的是，这个值会是各个文件自己的行号</td>
</tr>
<tr>
<td>RS</td>
<td>输入的记录分隔符， 默认为换行符</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符， 默认也是空格</td>
</tr>
<tr>
<td>ORS</td>
<td>输出的记录分隔符，默认为换行符</td>
</tr>
<tr>
<td>FILENAME</td>
<td>当前输入文件的名字</td>
</tr>
</tbody></table>
<p>怎么使用呢，比如：我们如果要输出行号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39;$3&#x3D;&#x3D;0 &amp;&amp; $6&#x3D;&#x3D;&quot;ESTABLISHED&quot; || NR&#x3D;&#x3D;1 &#123;printf &quot;%02s %s %-20s %-20s %s\n&quot;,NR, FNR, $4,$5,$6&#125;&#39;&#96; &#96;netstat&#96;&#96;.txt&#96;&#96;01 1 Local-Address        Foreign-Address      State&#96;&#96;07 7 coolshell.cn:80      110.194.134.189:1032 ESTABLISHED&#96;&#96;08 8 coolshell.cn:80      123.169.124.111:49809 ESTABLISHED&#96;&#96;10 10 coolshell.cn:80      123.169.124.111:49829 ESTABLISHED&#96;&#96;14 14 coolshell.cn:80      110.194.134.189:4796 ESTABLISHED&#96;&#96;17 17 coolshell.cn:80      123.169.124.111:49840 ESTABLISHED&#96;</span><br></pre></td></tr></table></figure>

<h5 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a><strong>指定分隔符</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$  &#96;&#96;awk&#96;  &#96;&#39;BEGIN&#123;FS&#x3D;&quot;:&quot;&#125; &#123;print $1,$3,$6&#125;&#39;&#96; &#96;&#x2F;etc&#x2F;passwd&#96;&#96;root 0 &#96;&#96;&#x2F;root&#96;&#96;bin 1 &#96;&#96;&#x2F;bin&#96;&#96;daemon 2 &#96;&#96;&#x2F;sbin&#96;&#96;adm 3 &#96;&#96;&#x2F;var&#x2F;adm&#96;&#96;lp 4 &#96;&#96;&#x2F;var&#x2F;spool&#x2F;lpd&#96;&#96;sync&#96; &#96;5 &#96;&#96;&#x2F;sbin&#96;&#96;shutdown&#96; &#96;6 &#96;&#96;&#x2F;sbin&#96;&#96;halt 7 &#96;&#96;&#x2F;sbin&#96;</span><br></pre></td></tr></table></figure>

<p>上面的命令也等价于：（-F的意思就是指定分隔符）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96;  &#96;-F: &#96;&#96;&#39;&#123;print $1,$3,$6&#125;&#39;&#96; &#96;&#x2F;etc&#x2F;passwd&#96;</span><br></pre></td></tr></table></figure>

<p>注：如果你要指定多个分隔符，你可以这样来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;awk&#96; &#96;-F &#96;&#96;&#39;[;:]&#39;&#96;</span><br></pre></td></tr></table></figure>

<p>再来看一个以\t作为分隔符输出的例子（下面使用了/etc/passwd文件，这个文件是以:分隔的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96;  &#96;-F: &#96;&#96;&#39;&#123;print $1,$3,$6&#125;&#39;&#96; &#96;OFS&#x3D;&#96;&#96;&quot;\t&quot;&#96; &#96;&#x2F;etc&#x2F;passwd&#96;&#96;root    0       &#96;&#96;&#x2F;root&#96;&#96;bin     1       &#96;&#96;&#x2F;bin&#96;&#96;daemon  2       &#96;&#96;&#x2F;sbin&#96;&#96;adm     3       &#96;&#96;&#x2F;var&#x2F;adm&#96;&#96;lp      4       &#96;&#96;&#x2F;var&#x2F;spool&#x2F;lpd&#96;&#96;sync&#96;    &#96;5       &#96;&#96;&#x2F;sbin&#96;</span><br></pre></td></tr></table></figure>

<h4 id="脱掉衬衫"><a href="#脱掉衬衫" class="headerlink" title="脱掉衬衫"></a>脱掉衬衫</h4><h5 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h5><p>我们再来看几个字符串匹配的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39;$6 ~ &#x2F;FIN&#x2F; || NR&#x3D;&#x3D;1 &#123;print NR,$4,$5,$6&#125;&#39;&#96; &#96;OFS&#x3D;&#96;&#96;&quot;\t&quot;&#96; &#96;netstat&#96;&#96;.txt&#96;&#96;1       Local-Address   Foreign-Address State&#96;&#96;6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2&#96;&#96;9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2&#96;&#96;13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1&#96;&#96;18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2&#96; &#96;$ $ &#96;&#96;awk&#96; &#96;&#39;$6 ~ &#x2F;WAIT&#x2F; || NR&#x3D;&#x3D;1 &#123;print NR,$4,$5,$6&#125;&#39;&#96; &#96;OFS&#x3D;&#96;&#96;&quot;\t&quot;&#96; &#96;netstat&#96;&#96;.txt&#96;&#96;1       Local-Address   Foreign-Address State&#96;&#96;5       coolshell.cn:80 124.205.5.146:18245     TIME_WAIT&#96;&#96;6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2&#96;&#96;9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2&#96;&#96;11      coolshell.cn:80 183.60.215.36:36970     TIME_WAIT&#96;&#96;13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1&#96;&#96;15      coolshell.cn:80 183.60.212.163:51082    TIME_WAIT&#96;&#96;18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2&#96;</span><br></pre></td></tr></table></figure>

<p>上面的第一个示例匹配FIN状态， 第二个示例匹配WAIT字样的状态。其实 ~ 表示模式开始。/ /中是模式。这就是一个正则表达式的匹配。</p>
<p>其实awk可以像grep一样的去匹配第一行，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39;&#x2F;LISTEN&#x2F;&#39;&#96; &#96;netstat&#96;&#96;.txt&#96;&#96;tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN&#96;&#96;tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN&#96;&#96;tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN&#96;&#96;tcp        0      0 :::22                   :::*                    LISTEN&#96;</span><br></pre></td></tr></table></figure>

<p>我们可以使用 “/FIN|TIME/” 来匹配 FIN 或者 TIME :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39;$6 ~ &#x2F;FIN|TIME&#x2F; || NR&#x3D;&#x3D;1 &#123;print NR,$4,$5,$6&#125;&#39;&#96; &#96;OFS&#x3D;&#96;&#96;&quot;\t&quot;&#96; &#96;netstat&#96;&#96;.txt&#96;&#96;1       Local-Address   Foreign-Address State&#96;&#96;5       coolshell.cn:80 124.205.5.146:18245     TIME_WAIT&#96;&#96;6       coolshell.cn:80 61.140.101.185:37538    FIN_WAIT2&#96;&#96;9       coolshell.cn:80 116.234.127.77:11502    FIN_WAIT2&#96;&#96;11      coolshell.cn:80 183.60.215.36:36970     TIME_WAIT&#96;&#96;13      coolshell.cn:80 124.152.181.209:26825   FIN_WAIT1&#96;&#96;15      coolshell.cn:80 183.60.212.163:51082    TIME_WAIT&#96;&#96;18      coolshell.cn:80 117.136.20.85:50025     FIN_WAIT2&#96;</span><br></pre></td></tr></table></figure>

<p>再来看看模式取反的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39;$6 !~ &#x2F;WAIT&#x2F; || NR&#x3D;&#x3D;1 &#123;print NR,$4,$5,$6&#125;&#39;&#96; &#96;OFS&#x3D;&#96;&#96;&quot;\t&quot;&#96; &#96;netstat&#96;&#96;.txt&#96;&#96;1       Local-Address   Foreign-Address State&#96;&#96;2       0.0.0.0:3306    0.0.0.0:*       LISTEN&#96;&#96;3       0.0.0.0:80      0.0.0.0:*       LISTEN&#96;&#96;4       127.0.0.1:9000  0.0.0.0:*       LISTEN&#96;&#96;7       coolshell.cn:80 110.194.134.189:1032    ESTABLISHED&#96;&#96;8       coolshell.cn:80 123.169.124.111:49809   ESTABLISHED&#96;&#96;10      coolshell.cn:80 123.169.124.111:49829   ESTABLISHED&#96;&#96;12      coolshell.cn:80 61.148.242.38:30901     ESTABLISHED&#96;&#96;14      coolshell.cn:80 110.194.134.189:4796    ESTABLISHED&#96;&#96;16      coolshell.cn:80 208.115.113.92:50601    LAST_ACK&#96;&#96;17      coolshell.cn:80 123.169.124.111:49840   ESTABLISHED&#96;&#96;19      :::22   :::*    LISTEN&#96;</span><br></pre></td></tr></table></figure>

<p>或是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;awk&#96; &#96;&#39;!&#x2F;WAIT&#x2F;&#39;&#96; &#96;netstat&#96;&#96;.txt&#96;</span><br></pre></td></tr></table></figure>

<p><strong>折分文件</strong></p>
<p>awk拆分文件很简单，使用重定向就好了。下面这个例子，是按第6例分隔文件，相当的简单（其中的NR!=1表示不处理表头）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39;NR!&#x3D;1&#123;print &gt; $6&#125;&#39;&#96; &#96;netstat&#96;&#96;.txt&#96; &#96;$ &#96;&#96;ls&#96;&#96;ESTABLISHED  FIN_WAIT1  FIN_WAIT2  LAST_ACK  LISTEN  &#96;&#96;netstat&#96;&#96;.txt  TIME_WAIT&#96; &#96;$ &#96;&#96;cat&#96; &#96;ESTABLISHED&#96;&#96;tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED&#96;&#96;tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED&#96;&#96;tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED&#96;&#96;tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED&#96;&#96;tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED&#96;&#96;tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED&#96; &#96;$ &#96;&#96;cat&#96; &#96;FIN_WAIT1&#96;&#96;tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1&#96; &#96;$ &#96;&#96;cat&#96; &#96;FIN_WAIT2&#96;&#96;tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2&#96;&#96;tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2&#96;&#96;tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2&#96; &#96;$ &#96;&#96;cat&#96; &#96;LAST_ACK&#96;&#96;tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK&#96; &#96;$ &#96;&#96;cat&#96; &#96;LISTEN&#96;&#96;tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN&#96;&#96;tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN&#96;&#96;tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN&#96;&#96;tcp        0      0 :::22                  :::*                        LISTEN&#96; &#96;$ &#96;&#96;cat&#96; &#96;TIME_WAIT&#96;&#96;tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT&#96;&#96;tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT&#96;&#96;tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT&#96;</span><br></pre></td></tr></table></figure>

<p>你也可以把指定的列输出到文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;awk&#96; &#96;&#39;NR!&#x3D;1&#123;print $4,$5 &gt; $6&#125;&#39;&#96; &#96;netstat&#96;&#96;.txt&#96;</span><br></pre></td></tr></table></figure>

<p>再复杂一点：（注意其中的if-else-if语句，可见awk其实是个脚本解释器）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39;NR!&#x3D;1&#123;&#96;&#96;if&#96;&#96;($6 ~ &#96;&#96;&#x2F;TIME&#96;&#96;|ESTABLISHED&#x2F;) print &gt; &#96;&#96;&quot;1.txt&quot;&#96;&#96;;&#96;&#96;else&#96; &#96;if&#96;&#96;($6 ~ &#96;&#96;&#x2F;LISTEN&#x2F;&#96;&#96;) print &gt; &#96;&#96;&quot;2.txt&quot;&#96;&#96;;&#96;&#96;else&#96; &#96;print &gt; &#96;&#96;&quot;3.txt&quot;&#96; &#96;&#125;&#39; &#96;&#96;netstat&#96;&#96;.txt&#96; &#96;$ &#96;&#96;ls&#96; &#96;?.txt&#96;&#96;1.txt  2.txt  3.txt&#96; &#96;$ &#96;&#96;cat&#96; &#96;1.txt&#96;&#96;tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT&#96;&#96;tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED&#96;&#96;tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED&#96;&#96;tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED&#96;&#96;tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT&#96;&#96;tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED&#96;&#96;tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED&#96;&#96;tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT&#96;&#96;tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED&#96; &#96;$ &#96;&#96;cat&#96; &#96;2.txt&#96;&#96;tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN&#96;&#96;tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN&#96;&#96;tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN&#96;&#96;tcp        0      0 :::22                  :::*                        LISTEN&#96; &#96;$ &#96;&#96;cat&#96; &#96;3.txt&#96;&#96;tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2&#96;&#96;tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2&#96;&#96;tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1&#96;&#96;tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK&#96;&#96;tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2&#96;</span><br></pre></td></tr></table></figure>

<h5 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h5><p>下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;ls&#96; &#96;-l  *.cpp *.c *.h | &#96;&#96;awk&#96; &#96;&#39;&#123;sum+&#x3D;$5&#125; END &#123;print sum&#125;&#39;&#96;&#96;2511401&#96;</span><br></pre></td></tr></table></figure>

<p>我们再来看一个统计各个connection状态的用法：（我们可以看到一些编程的影子了，大家都是程序员我就不解释了。注意其中的数组的用法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;awk&#96; &#96;&#39;NR!&#x3D;1&#123;a[$6]++;&#125; END &#123;for (i in a) print i &quot;, &quot; a[i];&#125;&#39;&#96; &#96;netstat&#96;&#96;.txt&#96;&#96;TIME_WAIT, 3&#96;&#96;FIN_WAIT1, 1&#96;&#96;ESTABLISHED, 6&#96;&#96;FIN_WAIT2, 3&#96;&#96;LAST_ACK, 1&#96;&#96;LISTEN, 4&#96;</span><br></pre></td></tr></table></figure>

<p>再来看看统计每个用户的进程的占了多少内存（注：sum的RSS那一列）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;ps&#96; &#96;aux | &#96;&#96;awk&#96; &#96;&#39;NR!&#x3D;1&#123;a[$1]+&#x3D;$6;&#125; END &#123; for(i in a) print i &quot;, &quot; a[i]&quot;KB&quot;;&#125;&#39;&#96;&#96;dbus, 540KB&#96;&#96;mysql, 99928KB&#96;&#96;www, 3264924KB&#96;&#96;root, 63644KB&#96;&#96;hchen, 6020KB&#96;</span><br></pre></td></tr></table></figure>

<h4 id="脱掉内衣"><a href="#脱掉内衣" class="headerlink" title="脱掉内衣"></a>脱掉内衣</h4><h5 id="awk脚本"><a href="#awk脚本" class="headerlink" title="awk脚本"></a>awk脚本</h5><p>在上面我们可以看到一个END关键字。END的意思是“处理完所有的行的标识”，即然说到了END就有必要介绍一下BEGIN，这两个关键字意味着执行前和执行后的意思，语法如下：</p>
<ul>
<li>BEGIN{ 这里面放的是执行前的语句 }</li>
<li>END {这里面放的是处理完所有的行后要执行的语句 }</li>
<li>{这里面放的是处理每一行时要执行的语句}</li>
</ul>
<p>为了说清楚这个事，我们来看看下面的示例：</p>
<p>假设有这么一个文件（学生成绩表）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;cat&#96; &#96;score.txt&#96;&#96;Marry   2143 78 84 77&#96;&#96;Jack    2321 66 78 45&#96;&#96;Tom     2122 48 77 71&#96;&#96;Mike    2537 87 97 95&#96;&#96;Bob     2415 40 57 62&#96;</span><br></pre></td></tr></table></figure>

<p>我们的awk脚本如下（我没有写有命令行上是因为命令行上不易读，另外也在介绍另一种用法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;$ &#96;&#96;cat&#96; &#96;cal&#96;&#96;.&#96;&#96;awk&#96;&#96;#!&#x2F;bin&#x2F;awk -f&#96;&#96;#运行前&#96;&#96;BEGIN &#123;&#96;&#96;    &#96;&#96;math &#x3D; 0&#96;&#96;    &#96;&#96;english &#x3D; 0&#96;&#96;    &#96;&#96;computer &#x3D; 0&#96; &#96;    &#96;&#96;printf&#96; &#96;&quot;NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n&quot;&#96;&#96;    &#96;&#96;printf&#96; &#96;&quot;---------------------------------------------\n&quot;&#96;&#96;&#125;&#96;&#96;#运行中&#96;&#96;&#123;&#96;&#96;    &#96;&#96;math+&#x3D;$3&#96;&#96;    &#96;&#96;english+&#x3D;$4&#96;&#96;    &#96;&#96;computer+&#x3D;$5&#96;&#96;    &#96;&#96;printf&#96; &#96;&quot;%-6s %-6s %4d %8d %8d %8d\n&quot;&#96;&#96;, $1, $2, $3,$4,$5, $3+$4+$5&#96;&#96;&#125;&#96;&#96;#运行后&#96;&#96;END &#123;&#96;&#96;    &#96;&#96;printf&#96; &#96;&quot;---------------------------------------------\n&quot;&#96;&#96;    &#96;&#96;printf&#96; &#96;&quot;  TOTAL:%10d %8d %8d \n&quot;&#96;&#96;, math, english, computer&#96;&#96;    &#96;&#96;printf&#96; &#96;&quot;AVERAGE:%10.2f %8.2f %8.2f\n&quot;&#96;&#96;, math&#96;&#96;&#x2F;NR&#96;&#96;, english&#96;&#96;&#x2F;NR&#96;&#96;, computer&#96;&#96;&#x2F;NR&#96;&#96;&#125;&#96;</span><br></pre></td></tr></table></figure>

<p>我们来看一下执行结果：（也可以这样运行 ./cal.awk score.txt）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ ``awk` `-f ``cal``.``awk` `score.txt``NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL``---------------------------------------------``Marry  2143     78       84       77      239``Jack   2321     66       78       45      189``Tom    2122     48       77       71      196``Mike   2537     87       97       95      279``Bob    2415     40       57       62      159``---------------------------------------------``  ``TOTAL:       319      393      350``AVERAGE:     63.80    78.60    70.00`</span><br></pre></td></tr></table></figure>

<h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><p>即然说到了脚本，我们来看看怎么和环境变量交互：（使用-v参数和ENVIRON，使用ENVIRON的环境变量需要export）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ x=5` `$ y=10``$ ``<span class="built_in">export</span>` `y` `$ ``<span class="built_in">echo</span>` `<span class="variable">$x</span> <span class="variable">$y</span>``5 10` `$ ``awk` `-``v` `val=<span class="variable">$x</span> ``<span class="string">'&#123;print $1, $2, $3, $4+val, $5+ENVIRON["y"]&#125;'</span>` `OFS=``<span class="string">"\t"</span>` `score.txt``Marry   2143    78      89      87``Jack    2321    66      83      55``Tom     2122    48      82      81``Mike    2537    87      102     105``Bob     2415    40      62      72`</span><br></pre></td></tr></table></figure>

<h4 id="几个花活"><a href="#几个花活" class="headerlink" title="几个花活"></a>几个花活</h4><p>最后，我们再来看几个小例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">#从file文件中找出长度大于80的行``awk` `'length&gt;80'` `file` `#按连接数查看客户端IP``netstat` `-ntu | ``awk` `'&#123;print $5&#125;'` `| ``cut` `-d: -f1 | ``sort` `| ``uniq` `-c | ``sort` `-nr` `#打印99乘法表``seq` `9 | ``sed` `'H;g'` `| ``awk` `-``v` `RS=``''` `'&#123;for(i=1;i&lt;=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")&#125;'`</span></span><br></pre></td></tr></table></figure>

<h4 id="自己撸吧"><a href="#自己撸吧" class="headerlink" title="自己撸吧"></a>自己撸吧</h4><p>关于其中的一些知识点可以参看<a href="http://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener">gawk的手册</a>：</p>
<ul>
<li>内建变量，参看：<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din-Variables" target="_blank" rel="noopener">http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din-Variables</a></li>
<li>流控方面，参看：<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Statements" target="_blank" rel="noopener">http://www.gnu.org/software/gawk/manual/gawk.html#Statements</a></li>
<li>内建函数，参看：<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din" target="_blank" rel="noopener">http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din</a></li>
<li>正则表达式，参看：<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Regexp" target="_blank" rel="noopener">http://www.gnu.org/software/gawk/manual/gawk.html#Regexp</a></li>
</ul>
<p>（全文完）</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/12/10/CVs/2016-12-10-ML-Regularization/">CVs/2016-12-10-ML-Regularization</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-12-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ML/">ML</a></span><div class="content"><h2 id="1-The-Problem-of-Overfitting"><a href="#1-The-Problem-of-Overfitting" class="headerlink" title="1. The Problem of Overfitting"></a>1. The Problem of Overfitting</h2><p><a href="https://images0.cnblogs.com/blog/663864/201411/081949249876584.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081949392689088.png" alt="image"></a></p>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>还是来看预测房价的这个例子，我们先对该数据做线性回归，也就是左边第一张图。</p>
<p>如果这么做，我们可以获得拟合数据的这样一条直线，但是，实际上这并不是一个很好的模型。我们看看这些数据，很明显，随着房子面积增大，住房价格的变化趋于稳定或者说越往右越平缓。因此线性回归并没有很好拟合训练数据。</p>
<blockquote>
<p><strong>我们把此类情况称为欠拟合(underfitting)，或者叫作叫做高偏差(bias)。</strong></p>
</blockquote>
<p>这两种说法大致相似，都表示没有很好地拟合训练数据。高偏差这个词是 machine learning 的研究初期传下来的一个专业名词，具体到这个问题，意思就是说如果用线性回归这个算法去拟合训练数据，那么该算法实际上会产生一个非常大的偏差或者说存在一个很强的偏见。</p>
<p>第二幅图，我们在中间加入一个二次项，也就是说对于这幅数据我们用二次函数去拟合。自然，可以拟合出一条曲线，事实也证明这个拟合效果很好。</p>
<p>另一个极端情况是，如果在第三幅图中对于该数据集用一个四次多项式来拟合。因此在这里我们有五个参数θ0到θ4，这样我们同样可以拟合一条曲线，通过我们的五个训练样本，我们可以得到如右图的一条曲线。</p>
<p>一方面，我们似乎对训练数据做了一个很好的拟合，因为这条曲线通过了所有的训练实例。但是，这实际上是一条很扭曲的曲线，它不停上下波动。因此，事实上我们并不认为它是一个预测房价的好模型。</p>
<blockquote>
<p><strong>所以，我们把这类情况叫做过拟合(overfitting)，也叫高方差(variance)。</strong></p>
</blockquote>
<p>与高偏差一样，高方差同样也是一个历史上的叫法。从第一印象上来说，如果我们拟合一个高阶多项式，那么这个函数能很好的拟合训练集（能拟合几乎所有的训练数据），但这也就面临函数可能太过庞大的问题，变量太多。</p>
<p><strong>同时如果我们没有足够的数据集（训练集）去约束这个变量过多的模型，那么就会发生过拟合。</strong></p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>过度拟合的问题通常发生在变量（特征）过多的时候。这种情况下训练出的方程总是能很好的拟合训练数据，也就是说，我们的代价函数可能非常接近于 0 或者就为 0。</p>
<p>但是，这样的曲线千方百计的去拟合训练数据，这样会导致它无法泛化到新的数据样本中，以至于无法预测新样本价格。在这里，<strong>术语”泛化”指的是一个假设模型能够应用到新样本的能力。</strong>新样本数据是指没有出现在训练集中的数据。</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081950012995058.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081950152375432.png" alt="image"></a><br>之前，我们看到了线性回归情况下的过拟合。类似的情况也适用于逻辑回归。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>那么，如果发生了过拟合问题，我们应该如何处理？</p>
<p>过多的变量（特征），同时只有非常少的训练数据，会导致出现过度拟合的问题。因此为了解决过度拟合，有以下两个办法。</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081950204873029.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081950339879703.png" alt="image"></a></p>
<blockquote>
<p>*<em>方法一：尽量减少选取变量的数量<br>*</em></p>
</blockquote>
<p>具体而言，我们可以人工检查每一项变量，并以此来确定哪些变量更为重要，然后，保留那些更为重要的特征变量。至于，哪些变量应该舍弃，我们以后在讨论，这会涉及到模型选择算法，这种算法是可以自动选择采用哪些特征变量，自动舍弃不需要的变量。这类做法非常有效，但是其缺点是当你舍弃一部分特征变量时，你也舍弃了问题中的一些信息。例如，也许所有的特征变量对于预测房价都是有用的，我们实际上并不想舍弃一些信息或者说舍弃这些特征变量。</p>
<blockquote>
<p><strong>方法二：正则化</strong></p>
</blockquote>
<p>正则化中我们将保留所有的特征变量，但是会减小特征变量的数量级（参数数值的大小θ(j)）。</p>
<p>这个方法非常有效，当我们有很多特征变量时，其中每一个变量都能对预测产生一点影响。正如我们在房价预测的例子中看到的那样，我们可以有很多特征变量，其中每一个变量都是有用的，因此我们不希望把它们删掉，这就导致了正则化概念的发生。</p>
<p>接下来我们会讨论怎样应用正则化和什么叫做正则化均值，然后将开始讨论怎样使用正则化来使学习算法正常工作，并避免过拟合。</p>
<h2 id="2-Cost-Function"><a href="#2-Cost-Function" class="headerlink" title="2. Cost Function"></a>2. Cost Function</h2><p><a href="https://images0.cnblogs.com/blog/663864/201411/081950392065543.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081950460499853.png" alt="image"></a></p>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>在前面的介绍中，我们看到了如果用一个二次函数来拟合这些数据，那么它给了我们一个对数据很好的拟合。然而，如果我们用一个更高次的多项式去拟合，最终我们可能会得到一个曲线，它能很好地拟合训练集，但却并不是一个好的结果，因为它过度拟合了数据，因此，一般性并不是很好。</p>
<p>让我们考虑下面的假设，我们想要加上<strong>惩罚项</strong>，从而使参数 θ3 和 θ4 足够的小。</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081950493939765.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081950538152248.png" alt="image"></a></p>
<p>这里我的意思就是，上图的式子是我们的优化目标，也就是说我们需要尽量减少代价函数的均方误差。</p>
<p>对于这个函数我们对它添加一些项，加上 1000 乘以 θ3 的平方，再加上 1000 乘以 θ4 的平方，</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081950595497528.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081951047539138.png" alt="image"></a></p>
<p>1000 只是我随便写的某个较大的数字而已。现在，如果我们要最小化这个函数，那么为了最小化这个新的代价函数，我们要让 θ3 和 θ4 尽可能小。因为，如果你在原有代价函数的基础上加上 1000 乘以 θ3 这一项 ，那么这个新的代价函数将变得很大，所以，当我们最小化这个新的代价函数时， 我们将使 θ3 的值接近于 0，同样 θ4 的值也接近于 0，就像我们忽略了这两个值一样。如果我们做到这一点（ θ3 和 θ4 接近 0 ），那么我们将得到一个近似的二次函数。</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081951193621142.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081951300032292.png" alt="image"></a></p>
<p>因此，我们最终恰当地拟合了数据，我们所使用的正是二次函数加上一些非常小，贡献很小项（因为这些项的 θ3、 θ4 非常接近于0）。显然，这是一个更好的假设。</p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><p><a href="https://images0.cnblogs.com/blog/663864/201411/081951469871136.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081951588935799.png" alt="image"></a></p>
<p>更一般地，这里给出了正规化背后的思路。这种思路就是，如果我们的参数值对应一个较小值的话（参数值比较小），那么往往我们会得到一个形式更简单的假设。</p>
<p>在我们上面的例子中，我们惩罚的只是 θ3 和 θ4 ，使这两个值均接近于零，从而我们得到了一个更简单的假设，实际上这个假设大抵上是一个二次函数。</p>
<p>但更一般地说，如果我们像惩罚 θ3 和 θ4 这样惩罚其它参数，那么我们往往可以得到一个相对较为简单的假设。</p>
<blockquote>
<p>*<em>实际上，这些参数的值越小，通常对应于越光滑的函数，也就是更加简单的函数。因此 就不易发生过拟合的问题。<br>*</em></p>
</blockquote>
<p>我知道，为什么越小的参数对应于一个相对较为简单的假设，对你来说现在不一定完全理解，但是在上面的例子中使 θ3 和 θ4 很小，并且这样做能给我们一个更加简单的假设，这个例子至少给了我们一些直观感受。</p>
<p>来让我们看看具体的例子，对于房屋价格预测我们可能有上百种特征，与刚刚所讲的多项式例子不同，我们并不知道 θ3 和 θ4 是高阶多项式的项。所以，如果我们有一百个特征，我们并不知道如何选择关联度更好的参数，如何缩小参数的数目等等。</p>
<p>因此在正则化里，我们要做的事情，就是把减小我们的代价函数（例子中是线性回归的代价函数）所有的参数值，因为我们并不知道是哪一个或哪几个要去缩小。</p>
<p>因此，我们需要修改代价函数，在这后面添加一项，就像我们在方括号里的这项。当我们添加一个额外的正则化项的时候，我们收缩了每个参数。</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081952091127076.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081952152064015.png" alt="image"></a></p>
<p>顺便说一下，按照惯例，我们没有去惩罚 θ0，因此 θ0 的值是大的。这就是一个约定从 1 到 n 的求和，而不是从 0 到 n 的求和。但其实在实践中<br>这只会有非常小的差异，无论你是否包括这 θ0 这项。但是按照惯例，通常情况下我们还是只从 θ1 到 θn 进行正则化。</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081952259717893.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081952330495431.png" alt="image"></a></p>
<p>下面的这项就是一个正则化项</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081952338934773.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081952345967158.png" alt="image"></a><br>并且 λ 在这里我们称做正则化参数。</p>
<blockquote>
<p><strong>λ 要做的就是控制在两个不同的目标中的平衡关系。</strong></p>
</blockquote>
<p><strong>第一个目标就是我们想要训练，使假设更好地拟合训练数据。</strong>我们希望假设能够很好的适应训练集。</p>
<p><strong>而第二个目标是我们想要保持参数值较小。（通过正则化项）</strong></p>
<p>而 λ 这个正则化参数需要控制的是这两者之间的平衡，即平衡拟合训练的目标和保持参数值较小的目标。从而来保持假设的形式相对简单，来避免过度的拟合。</p>
<p>对于我们的房屋价格预测来说，我们之前所用的非常高的高阶多项式来拟合，我们将会得到一个非常弯曲和复杂的曲线函数，现在我们只需要使用正则化目标的方法，那么你就可以得到一个更加合适的曲线，但这个曲线不是一个真正的二次函数，而是更加的流畅和简单的一个曲线。这样就得到了对于这个数据更好的假设。</p>
<p>再一次说明下，这部分内容的确有些难以明白，为什么加上参数的影响可以具有这种效果？但如果你亲自实现了正规化，你将能够看到这种影响的最直观的感受。</p>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h3><p><a href="https://images0.cnblogs.com/blog/663864/201411/081952576123726.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081953140499371.png" alt="image"></a></p>
<p>在正则化线性回归中，如果正则化参数值 λ 被设定为非常大，那么将会发生什么呢？</p>
<p>我们将会非常大地惩罚参数θ1 θ2 θ3 θ4 … 也就是说，我们最终惩罚θ1 θ2 θ3 θ4 … 在一个非常大的程度，那么我们会使所有这些参数接近于零。</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081953329569128.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081953465963762.png" alt="image"></a></p>
<p>如果我们这么做，那么就是我们的假设中相当于去掉了这些项，并且使我们只是留下了一个简单的假设，这个假设只能表明房屋价格等于 θ0 的值，那就是类似于拟合了一条水平直线，对于数据来说这就是一个欠拟合 (underfitting)。这种情况下这一假设它是条失败的直线，对于训练集来说这只是一条平滑直线，它没有任何趋势，它不会去趋向大部分训练样本的任何值。</p>
<p>这句话的另一种方式来表达就是这种假设有过于强烈的”偏见” 或者过高的偏差 (bais)，认为预测的价格只是等于 θ0 。对于数据来说这只是一条水平线。</p>
<p>因此，为了使正则化运作良好，我们应当注意一些方面，应该去选择一个不错的正则化参数 λ 。当我们以后讲到多重选择时我们将讨论一种方法来自动选择正则化参数 λ ，为了使用正则化，接下来我们将把这些概念应用到到线性回归和逻辑回归中去，那么我们就可以让他们避免过度拟合了。</p>
<h2 id="3-Regularized-Linear-Regression"><a href="#3-Regularized-Linear-Regression" class="headerlink" title="3. Regularized Linear Regression"></a>3. Regularized Linear Regression</h2><p>之前我们已经介绍过，岭回归的代价函数如下：</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081953500814930.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081953557536697.png" alt="image"></a><br>对于线性回归(的求解)，我们之前运用了两种学习算法，一种基于梯度下降，一种基于正规方程。</p>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h3><p>梯度下降，如下：</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081954132218927.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081954274561745.png" alt="image"></a></p>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h3><p>正规方程，如下：</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081954343629568.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081954443152563.png" alt="image"></a></p>
<h3 id="3-2"><a href="#3-2" class="headerlink" title="3"></a>3</h3><p><a href="https://images0.cnblogs.com/blog/663864/201411/081954502994300.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081954592215008.png" alt="image"></a></p>
<p>现在考虑 M（即样本量）， 比 N（即特征的数量）小或等于N。</p>
<p>通过之前的博文，我们知道如果你只有较少的样本，导致特征数量大于样本数量，那么矩阵 XTX 将是不可逆矩阵或奇异（singluar）矩阵，或者用另一种说法是这个矩阵是退化（degenerate）的，那么我们就没有办法使用正规方程来求出 θ 。</p>
<p>幸运的是，正规化也为我们解决了这个问题，具体的说只要正则参数是严格大于零，实际上，可以证明如下矩阵：</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081955003621092.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081955014244135.png" alt="image"></a></p>
<p>将是可逆的。因此，使用正则还可以照顾任何 XTX 不可逆的问题。</p>
<p>所以，你现在知道如何实现岭回归，利用它，你就可以避免过度拟合，即使你在一个相对较小的训练集里有很多特征。这应该可以让你在很多问题上更好的运用线性回归。</p>
<p>在接下来的视频中，我们将把这种正则化的想法应用到 Logistic 回归，这样我们就可以让 logistic 回归也避免过度拟合，从而表现的更好。</p>
<h2 id="4-Regularized-Logistic-Regression"><a href="#4-Regularized-Logistic-Regression" class="headerlink" title="4. Regularized Logistic Regression"></a>4. Regularized Logistic Regression</h2><p>Regularized Logistic Regression 实际上与 Regularized Linear Regression 是十分相似的。</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081955184567964.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081955311908741.png" alt="image"></a></p>
<p>同样使用梯度下降：</p>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081955407211863.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081955489245956.png" alt="image"></a></p>
<p>如果在高级优化算法中，使用正则化技术的话，那么对于这类算法我们需要自己定义costFunction。</p>
<blockquote>
<p>For those methods what we needed to do was to define the function that’s called the cost function.</p>
</blockquote>
<p><a href="https://images0.cnblogs.com/blog/663864/201411/081956439096258.png" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog/663864/201411/081957037373100.png" alt="image"></a></p>
<p>这个我们自定义的 costFunction 的输入为向量 θ ，返回值有两项，分别是代价函数 jVal 以及 梯度gradient。</p>
<p>总之我们需要的就是这个自定义函数costFunction，针对Octave而言，我们可以将这个函数作为参数传入到 fminunc 系统函数中（fminunc 用来求函数的最小值，将@costFunction作为参数代进去，注意 @costFunction 类似于C语言中的函数指针），fminunc返回的是函数 costFunction 在无约束条件下的最小值，即我们提供的代价函数 jVal 的最小值，当然也会返回向量 θ 的解。</p>
<p>上述方法显然对正则化逻辑回归是适用的。</p>
<h2 id="5-尾声"><a href="#5-尾声" class="headerlink" title="5. 尾声"></a>5. 尾声</h2><p>通过最近的几篇文章，我们不难发现，无论是线性回归问题还是逻辑回归问题都可以通过构造多项式来解决。但是，你将逐渐发现其实还有更为强大的非线性分类器可以用来解决多项式回归问题。下篇文章中，我们将会讨论。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/08/09/LC/2016-08-09-LC%20198&amp;213%20House-Robber%20I%20&amp;%20II/">LC/2016-08-09-LC 198&amp;213 House-Robber I &amp; II</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-08-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/LC/">LC</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/LC-DP/">LC-DP</a></span><div class="content"><h3 id="198-house-robber"><a href="#198-house-robber" class="headerlink" title="198. house robber"></a>198. house robber</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums = list(nums)</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">2</span>:   <span class="comment"># duplicated with lineno.19, but OK, clear to understand</span></span><br><span class="line">            <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        <span class="keyword">for</span> idx, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">                dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> idx == <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[idx] = max(dp[idx - <span class="number">2</span>] + nums[idx], dp[idx - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    sol = Solution()</span><br><span class="line">    ex1_in = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">    ex2_in = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    ans = sol.rob(ex1_in)</span><br><span class="line">    print(<span class="string">"ans1: &#123;&#125;"</span>.format(ans))</span><br><span class="line">    <span class="keyword">assert</span> (<span class="number">4</span> == ans)</span><br><span class="line"></span><br><span class="line">    ans = sol.rob(ex2_in)</span><br><span class="line">    print(<span class="string">"ans2: &#123;&#125;"</span>.format(ans))</span><br><span class="line">    <span class="keyword">assert</span> (<span class="number">12</span> == ans)</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2015/05/14/DevOps/2015-05-14-pdb/">DevOps/2015-05-14-pdb</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2015-05-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/DevOps/">DevOps</a></span><div class="content"><h3 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h3><h4 id="Conditional-Break-Point"><a href="#Conditional-Break-Point" class="headerlink" title="Conditional Break Point"></a>Conditional Break Point</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(Pdb) b  <span class="number">3</span>,  ii==<span class="number">3</span></span><br><span class="line">Breakpoint <span class="number">3</span> at /mnt/raid3/home/huangjiancong/test.py:<span class="number">3</span></span><br><span class="line">(Pdb) l</span><br><span class="line">[EOF]</span><br><span class="line">(Pdb) l <span class="number">3</span></span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  2  -&gt; for ii, val in enumerate(range(10)):</span><br><span class="line">  <span class="number">3</span> B           print(ii)</span><br><span class="line">[EOF]</span><br></pre></td></tr></table></figure>

<p><a href="https://www.wandouip.com/t5i100987/#jekyll_33" target="_blank" rel="noopener">https://www.wandouip.com/t5i100987/#jekyll_33</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Joe Huang</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>